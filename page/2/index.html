<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="SHAN">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="SHAN">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SHAN">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>SHAN</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SHAN</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/18/【JAVA】AbstractQueuedSynchronizer源码学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/18/【JAVA】AbstractQueuedSynchronizer源码学习/" itemprop="url">AbstractQueuedSynchronizer源码学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-18T23:30:00+08:00">
                2019-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>AQS内部的同步队列</strong></p>
<p>AQS内部的同步队列是一个双向队列，队列中的元素是AQS中的Node节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 共享锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">// 独占锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 取消状态，处于取消状态的线程不再竞争锁，等待被GC回收 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 前置节点，当前节点的前一个节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 后置节点，当前节点的下一个节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 节点绑定的线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        </span><br><span class="line">        Node nextWaiter;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>waitStatus等待状态的五种情况</strong></p>
<ul>
<li>CANCELLED：对应的值为1，表示节点对应的线程被取消，处于取消状态的节点不会再竞争锁</li>
<li>SIGNAL：对应的值为-1，表示该节点后面的节点的线程处于等待获取锁的状态</li>
<li>CONDITION：对应的值为-2，表示节点在等待队列中</li>
<li>PROPAGATE：对应的值为-3，表示下一次共享式同步状态获取将被无条件的传播</li>
<li>节点的初始状态：对应的值为0</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="1-acquire"><a href="#1-acquire" class="headerlink" title="1. acquire()"></a>1. acquire()</h3><p>（1）调用tryAcquire获取锁，如果获取失败调用addWaiter为当前的线程创建Node节点，并调用acquireQueued处理创建的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用tryAcquire获取锁，如果获取失败，调用addWaiter将任务封装成Node加入队列，调用acquireQueued处理创建的节点</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AQS中并没有实现tryAcquire方法，只是在方法中抛出了一个异常，需要由AQS的子类来实现该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-addWaiter"><a href="#2-addWaiter" class="headerlink" title="2. addWaiter()"></a>2. addWaiter()</h3><p>addWaiter方法主要为当前线程创建节点，然后返回创建的节点，在这个方法中有一个队列尾节点为空的判断：</p>
<p>（1）如果尾节点tail不为空，说明队列中已经存在节点，直接将新建的节点加到队列的尾部，然后通过CAS方式将当前节点置为尾节点即可。</p>
<p>（2）如果尾节点为空，说明同步队列中还没有节点，调用enq方法初始化队列的头结点和尾节点，并将当前节点加入队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建节点，绑定当前线程</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果尾节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将新的节点加入到尾节点之后</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS将新建的节点设置成尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果尾节点为空，在enq中初始化head和tail节点之后再把新节点插入到队列后边</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="enq"><a href="#enq" class="headerlink" title="enq()"></a>enq()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化队列的头结点和尾节点，并将传入的节点加入队列</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          Node t = tail;</span><br><span class="line">          <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 创建一个新节点，当做头结点，并设置尾节点</span></span><br><span class="line">              <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                  tail = head;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 将传入的节点插入到头结点之后并设为尾节点</span></span><br><span class="line">              node.prev = t;</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                  t.next = node;</span><br><span class="line">                  <span class="keyword">return</span> t;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-acquireQueued"><a href="#3-acquireQueued" class="headerlink" title="3. acquireQueued()"></a>3. acquireQueued()</h3><p>acquireQueued方法主要用来对节点进行处理，在方法中有一个for循环不断的在尝试获取锁以及判断当前任务是否应该被阻塞等待：</p>
<p>判断当前节点的前一个节点是否为头结点：</p>
<p>（1）当前节点的前一个节点是头结点，因为当前节点的前一个节点是头结点，此时重新调用tryAcquire方法尝试获取锁，如果获取成功将当前节点置为头结点，并将之前的头结点的next置为空，等待被回收，然后返回线程的中断状态，如果获取失败继续for循环的流程。</p>
<p>（2）当前节点的前一个节点不是头结点，调用shouldParkAfterFailedAcquire方法设置节点的等待状态，shouldParkAfterFailedAcquire方法如果返回true（返回true表示当前节点已处于等待状态可以被阻塞），执行parkAndCheckInterrupt方法，这个方法用来阻塞当前线程直到被唤醒，之后返回线程的中断状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="comment">// 如果当前节点的前一个节点为头结点，重新调用tryAcquire方法尝试获取锁</span></span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   <span class="comment">// 如果获取锁成功，将当前节点置为头结点</span></span><br><span class="line">                   setHead(node);</span><br><span class="line">                   <span class="comment">// 将之前的头结点的next置为空</span></span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="comment">// 返回中断状态</span></span><br><span class="line">                   <span class="keyword">return</span> interrupted;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 如果当前节点的前一个节点不是头结点</span></span><br><span class="line">               <span class="comment">// shouldParkAfterFailedAcquire中设置当前节点的前一个节点的等待状态，让前一个节点知道当前节点进入等待</span></span><br><span class="line">               <span class="comment">// parkAndCheckInterrupt让当前线程进入阻塞状态，直到被唤醒之后，继续执行，并返回中断状态</span></span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                       parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>;<span class="comment">// 记录中断状态</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire()"></a>shouldParkAfterFailedAcquire()</h4><p> 在shouldParkAfterFailedAcquire方法中，==主要是为了让当前节点处于等待状态==，设置的方式是找到当前节点之前第一个waitStatus等于或小于0的节点，然后设置prev的waitStatus。</p>
<blockquote>
<p><strong>为什么要找到waitStatus等于或小于0的节点？</strong></p>
<p>通过waitStatus的几种值可以知道大于0的时候表示这个节点处于取消状态，之后是要从队列中移除的，所以要不断向前找，直到找到waitStatus等于或小于0的节点。</p>
</blockquote>
<p> 因为节点的等待状态可能会发生变化，所以先判断当前节点的前一个节点的等待状态waitStatus:</p>
<p> （1）等待状态是-1，表示这个节点之后的节点处于等待锁的状态，此时直接返回true即可。</p>
<p> （2）等待状态大于0，表示pred节点可能已被取消，此时要跳过这个节点，一直往上一个节点找，直到找到一个等待状态小于或者等于0的节点，并将这个节点的next指向当前节点（此时shouldParkAfterFailedAcquire返回的结果为false）。</p>
<p> （3）如果当前节点的前一个节点perd的等待状态既不等于-1，也不大于0，此时将pred的等待状态设为-1，表示这个节点之后的节点处于等待锁的状态（此时shouldParkAfterFailedAcquire返回的结果为false）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 当前节点的前一个节点的等待状态</span></span><br><span class="line">     <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">     <span class="comment">// 如果是signal状态（-1），返回true</span></span><br><span class="line">     <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 如果当前节点的前一个节点的等待状态大于0，从前一个节点开始一直往前找，直到找到等待状态不大于0的节点，返回false</span></span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">             node.prev = pred = pred.prev;</span><br><span class="line">         &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">         pred.next = node;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 当前节点的前一个节点的状态既不等于-1，也不大于0，设置当前节点的前一个节点的状态为signal（-1）</span></span><br><span class="line">         compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>由上可知shouldParkAfterFailedAcquire中当前节点的前一个节点的等待状态是-1时返回的是true，其他情况返回false，但是返回false之后下一次再执行shouldParkAfterFailedAcquire，就可以满足条件返回true（因为调用了compareAndSetWaitStatus方法设置前一个节点的等待状态是-1，所以第二次进入可以满足条件）。</p>
<h4 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt()"></a>parkAndCheckInterrupt()</h4><p>parkAndCheckInterrupt方法用来阻塞当前线程，然后返回线程的中断状态。LockSupport.park(this)会让当前线程进入阻塞状态，直到被其他线程唤醒（或者被中断），然后会调用Thread.interrupted()返回线程的中断位：</p>
<ul>
<li>如果当前线程处于中断状态，Thread.interrupted()返回true，下次调用Thread.interrupted()将会返回false，因为中断位被重置了。</li>
<li>如果当前线程处于非中断状态，Thread.interrupted()返回false。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 阻塞当前的线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 返回当前线程的中断位</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到acquiredQueue方法：</p>
<p>如果parkAndCheckInterrupt返回true，将 interrupted 设为 true，记录了线程的中断状态，当线程尝试获取锁成功之后，将interrupted中断中断状态返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;<span class="comment">//返回中断状态</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;<span class="comment">//设置中断状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);<span class="comment">//取消竞争锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>为什么要记录中断状态</strong>？</p>
<p> 假设一个线程被中断唤醒，Thread.interrupted()返回线程的中断状态true，之后在acquireQueued方法中并没有中断线程的相关操作，被中断之后还在尝试获取锁，获取成功之后将中断状态返回（此时返回true），再回到acquire方法中，如果acquireQueued返回true代表线程被中断过，此时调用selfInterrupt方法，来中断当前线程，由于调用Thread.interrupted()的时候会重置中断位，此时不能靠Thread.interrupted()判断中断位，所以要记录一下中断状态表明线程被中断过，然后根据这个状态在acquire方法做中断处理。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 调用tryAcquire获取锁，如果获取失败，调用addWaiter将任务封装成Node，调用acquireQueued将node加入队列</span></span><br><span class="line">          <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">                  acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">              selfInterrupt();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-cancelAcquire"><a href="#4-cancelAcquire" class="headerlink" title="4.cancelAcquire()"></a>4.cancelAcquire()</h4><p>在acquireQueued方法的finally语句块中，如果在循环的过程中出现了异常，则执行cancelAcquire方法，用于将该节点标记为取消状态。<br>cancelAcquire()方法中，首先也要找到当前节点之前第一个waitStatus&lt;=0的节点pred，此时当前节点有三种情况：</p>
<p>（1）当前节点如果是尾节点，当前节点直接从队尾删掉即可，先将pred的next置为空，然后pred设为尾节点。</p>
<p>（2）pred不是头结点，也就是说当前节点处于队列中间，并且它的前一个节点pred（指的是第一个waitStatus&lt;=0的节点）不是头结点，此时判断pred的等待状态，如果是SIGNAL或者非SIGNAL，就调用compareAndSetWaitStatus方法将它的状态置为SIGNAL，然后将当前节点的下一个节点置为到pred的下一个节点。</p>
<p>（3）pred是头结点，也就是当前节点在头结点之后，此时直接唤醒后继节点即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点为直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将节点绑定的线程置为空</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前节点的前一个节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="comment">// 从当前节点的前一个节点开始，直到找到waitStatus&lt;=0的节点记为pred</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="comment">// pred的下一个节点</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    <span class="comment">// 将当前节点的等待状态置为取消</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="comment">// （1）如果当前节点是尾节点，将pred置为尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">//将pred的next置为空</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">//（2）当前节点位于队列中间的情况</span></span><br><span class="line">        <span class="comment">// 当前节点不是head节点的下一个节点，或者pred的等待状态是SIGNAL 再或者不是SIGNAL，就将pred的等待状态置为SIGNAL</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">                ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                        (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">                pred.thread != <span class="keyword">null</span>) &#123;<span class="comment">// pred绑定的线程也不能为空</span></span><br><span class="line">            <span class="comment">//当前节点的下一个节点</span></span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="comment">// 如果下一个节点不为空并且不是取消状态</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 将pred的下一个节点指向当前节点的下一个节点</span></span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//（3）当前节点是头结点的下一个节点,唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点的下一个节点指向自己等待回收</span></span><br><span class="line">        node.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-release"><a href="#5-release" class="headerlink" title="5.release()"></a>5.release()</h4><p>release方法用来释放锁，释放锁的实现在tryRelease方法，由AQS的子类来实现这个方法，释放锁成功之后，调用unparkSuccessor方法从头结点开始唤醒之后的节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// tryRelease由AQS子类实现，用来释放锁，如果释放锁成功</span></span><br><span class="line">     <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">         <span class="comment">// 头结点</span></span><br><span class="line">         Node h = head;</span><br><span class="line">         <span class="comment">// 如果队列头节点不为空并且等待装不是0，头结点初始化时等待状态为0，不为0表示它之后的节点处于等待状态</span></span><br><span class="line">         <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">             <span class="comment">// 唤醒头结点的后继节点</span></span><br><span class="line">             unparkSuccessor(h);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 唤醒后继节点</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">     <span class="comment">// 如果当前节点的等待状态小于0，将等待状态置为0</span></span><br><span class="line">     <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">         compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">// 当前节点的下一个节点</span></span><br><span class="line">     Node s = node.next;</span><br><span class="line">     <span class="comment">// 下一个节点为空或者状态是取消</span></span><br><span class="line">     <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         s = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// 从队列的尾部开始向前查找，直到找到第一个等待状态&lt;=0的节点</span></span><br><span class="line">         <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">             <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                 s = t;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">         <span class="comment">// 唤醒节点绑定的线程</span></span><br><span class="line">         LockSupport.unpark(s.thread);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>参考：</strong></p>
<p>[Idea Buffer:深入理解AbstractQueuedSynchronizer（一）]（<a href="http://www.ideabuffer.cn/2017/03/15/深入理解AbstractQueuedSynchronizer（一）/）" target="_blank" rel="noopener">http://www.ideabuffer.cn/2017/03/15/深入理解AbstractQueuedSynchronizer（一）/）</a></p>
<p><a href="https://mp.weixin.qq.com/s/3eUiYIxCU4XVw3p3wy4bKA" target="_blank" rel="noopener">我们都是小青蛙：java并发性能（五）</a></p>
<p><a href="http://blog.zhangjikai.com/2017/04/15/【Java-并发】详解-AbstractQueuedSynchronizer/" target="_blank" rel="noopener">jk’s Blog:【Java并发】详解 AbstractQueuedSynchronizer</a></p>
<p><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">waterystone：Java并发之AQS详解</a></p>
<p><a href="https://www.cnblogs.com/go2sea/p/5618628.html" target="_blank" rel="noopener">go2sea：Java多线程之JUC包：AbstractQueuedSynchronizer（AQS）源码学习笔记</a></p>
<p><strong>jdk版本:1.8</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/25/【Elasticsearch】Master选举流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/【Elasticsearch】Master选举流程/" itemprop="url">【Elasticsearch】Master选举流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-25T21:15:00+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Elasticsearch中Discovery模块负责发现集群中的节点以及Master的选举，其默认的实现称为Zen Discovery。</p>
<p>在Elasticsearch的配置文件中，有一项为node.master，如果将该配置设为true，该节点即可参与Master选举，获得被选举为Master节点的资格。</p>
<h3 id="Master选举算法"><a href="#Master选举算法" class="headerlink" title="Master选举算法"></a>Master选举算法</h3><p>（1）Paxos算法</p>
<pre><code>Paxos算法在分布式系统中是一种比较著名的选举算法，并且非常强大，但是它实现比较复杂，这里不过多讲解。
</code></pre><p>（2）Bully算法</p>
<pre><code>Bully算法假设集群中所有的节点都有一个唯一的ID，通过对ID进行排序，选取ID最大的节点作为Master节点。
</code></pre><p><strong>brain-split问题</strong></p>
<p>一个集群建立起之后会选出一个master,负责管理整个集群，当master负载比较大时或者产生网络分区时，导致其他节点可能认为master节点已失效，从而选举新的节点，出现多个master的情况，这就是brain-split问题。<br>ES在选举master时，获得的投票数必须要达到quorum也就是参选人数需要过半，才能确认Master,quorum的数量可以在配置文件中配置discovery.zen.minimum_master_nodes，一般配置数量为集群中具有master资格的节点数除以2加1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discovery.zen.minimum_master_nodes: 1</span><br></pre></td></tr></table></figure>
<h3 id="Elasticsearch-Master选举流程"><a href="#Elasticsearch-Master选举流程" class="headerlink" title="Elasticsearch Master选举流程"></a>Elasticsearch Master选举流程</h3><p>Elasticsearch基于Bully算法，选举流程如下：</p>
<h4 id="1-Ping所有的节点，选举临时的Master"><a href="#1-Ping所有的节点，选举临时的Master" class="headerlink" title="1.Ping所有的节点，选举临时的Master"></a>1.Ping所有的节点，选举临时的Master</h4><ul>
<li><strong>fullPingResponses</strong></li>
</ul>
<p>选举过程的实现位于ZenDiscovery类的findMaster方法中，在该方法中首先Ping集群中的所有节点，得到返回结果fullPingResponses，fullPingResponses是由集群中的节点组成的列表，但是不包含当前的节点，当前节点单独被添加到fullPingResponses中。接着，将discovery.zen.master_election.ignore_non_master_pings为true并且不具备Master资格的节点过滤掉，并放入pingResponses中。</p>
<ul>
<li><strong>activeMasters</strong></li>
</ul>
<p>activeMasters存储当前活跃的Master列表，它是通过遍历pingResponses，将每个节点认为的Master节点（并且不是当前节点）加入到activeMasters列表中。</p>
<ul>
<li><strong>masterCandidates</strong></li>
</ul>
<p>masterCandidates存储Master候选者列表，也就是具有Master资格的节点，它也是通过遍历pingResponses，判断每个节点是否具有Master资格得到的候选者列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZenDiscovery</span> <span class="keyword">extends</span> <span class="title">AbstractLifecycleComponent</span> <span class="keyword">implements</span> <span class="title">Discovery</span>, <span class="title">PingContextProvider</span>, <span class="title">IncomingClusterStateListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">innerJoinCluster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DiscoveryNode masterNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> Thread currentThread = Thread.currentThread();</span><br><span class="line">        nodeJoinController.startElectionContext();</span><br><span class="line">        <span class="comment">// 如果master为空</span></span><br><span class="line">        <span class="keyword">while</span> (masterNode == <span class="keyword">null</span> &amp;&amp; joinThreadControl.joinThreadActive(currentThread)) &#123;</span><br><span class="line">            <span class="comment">// 选举临时的Master</span></span><br><span class="line">            masterNode = findMaster();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DiscoveryNode <span class="title">findMaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.trace(<span class="string">"starting to ping"</span>);</span><br><span class="line">        <span class="comment">//ping所有的节点，得到节点列表，列表中不包含当前节点</span></span><br><span class="line">        List&lt;ZenPing.PingResponse&gt; fullPingResponses = pingAndWait(pingTimeout).toList();</span><br><span class="line">        <span class="keyword">if</span> (fullPingResponses == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.trace(<span class="string">"No full ping responses"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">if</span> (fullPingResponses.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">" &#123;none&#125;"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (ZenPing.PingResponse pingResponse : fullPingResponses) &#123;</span><br><span class="line">                    sb.append(<span class="string">"\n\t--&gt; "</span>).append(pingResponse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.trace(<span class="string">"full ping responses:&#123;&#125;"</span>, sb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前节点</span></span><br><span class="line">        <span class="keyword">final</span> DiscoveryNode localNode = transportService.getLocalNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add our selves</span></span><br><span class="line">        <span class="keyword">assert</span> fullPingResponses.stream().map(ZenPing.PingResponse::node)</span><br><span class="line">            .filter(n -&gt; n.equals(localNode)).findAny().isPresent() == <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 将当前节点加入节点列表</span></span><br><span class="line">        fullPingResponses.add(<span class="keyword">new</span> ZenPing.PingResponse(localNode, <span class="keyword">null</span>, <span class="keyword">this</span>.clusterState()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤节点，将discovery.zen.master_election.ignore_non_master_pings为true并且不具备Master资格的节点过滤掉</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;ZenPing.PingResponse&gt; pingResponses = filterPingResponses(fullPingResponses, masterElectionIgnoreNonMasters, logger);</span><br><span class="line">        <span class="comment">// activeMasters存储当前活跃的Master列表</span></span><br><span class="line">        List&lt;DiscoveryNode&gt; activeMasters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历ping后得到的节点列表</span></span><br><span class="line">        <span class="keyword">for</span> (ZenPing.PingResponse pingResponse : pingResponses) &#123;</span><br><span class="line">            <span class="comment">// 如果每个节点选举出的Master节点不为空并且不是当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (pingResponse.master() != <span class="keyword">null</span> &amp;&amp; !localNode.equals(pingResponse.master())) &#123;</span><br><span class="line">                <span class="comment">// 将推举出的master节点加入到activeMasters中</span></span><br><span class="line">                activeMasters.add(pingResponse.master());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// masterCandidates存储Master候选者列表</span></span><br><span class="line">        List&lt;ElectMastermasterCandidatesService.MasterCandidate&gt; masterCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 再次遍历集群中的节点列表</span></span><br><span class="line">        <span class="keyword">for</span> (ZenPing.PingResponse pingResponse : pingResponses) &#123;</span><br><span class="line">            <span class="comment">// 如果节点具有Master资格</span></span><br><span class="line">            <span class="keyword">if</span> (pingResponse.node().isMasterNode()) &#123;</span><br><span class="line">                <span class="comment">// 加入到masterCandidates候选者列表中</span></span><br><span class="line">                masterCandidates.add(<span class="keyword">new</span> ElectMasterService.MasterCandidate(pingResponse.node(), pingResponse.getClusterStateVersion()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前活跃的Master列表为空</span></span><br><span class="line">        <span class="keyword">if</span> (activeMasters.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 从候选者Master列表中判断是否达到法定人数</span></span><br><span class="line">            <span class="keyword">if</span> (electMaster.hasEnoughCandidates(masterCandidates)) &#123;</span><br><span class="line">                <span class="comment">// 选举出Master节点</span></span><br><span class="line">                <span class="keyword">final</span> ElectMasterService.MasterCandidate winner = electMaster.electMaster(masterCandidates);</span><br><span class="line">                logger.trace(<span class="string">"candidate &#123;&#125; won election"</span>, winner);</span><br><span class="line">                <span class="comment">// 返回Master节点</span></span><br><span class="line">                <span class="keyword">return</span> winner.getNode();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有足够的候选者，返回空</span></span><br><span class="line">                logger.warn(<span class="string">"not enough master nodes discovered during pinging (found [&#123;&#125;], but needed [&#123;&#125;]), pinging again"</span>,</span><br><span class="line">                            masterCandidates, electMaster.minimumMasterNodes());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 判断当前节点是否在活跃的Master列表中</span></span><br><span class="line">            <span class="keyword">assert</span> !activeMasters.contains(localNode) : <span class="string">"local node should never be elected as master when other nodes indicate an active master"</span>;</span><br><span class="line">            <span class="comment">// 选举Master节点</span></span><br><span class="line">            <span class="keyword">return</span> electMaster.tieBreakActiveMasters(activeMasters);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="具体选举过程"><a href="#具体选举过程" class="headerlink" title="具体选举过程"></a>具体选举过程</h5><p>首先判断activeMasters是否为空，如果不为空，从activeMasters选举。如果为空，判断masterCandidates中候选者是否达到了法定人数  quorum，如果达到，从中选举Master节点，如果未到达，重新获取节点。</p>
<p><strong>（1）从masterCandidates选举</strong></p>
<p>具体的实现在ElectMasterService中:</p>
<p><strong>判断是否到达法定人数</strong></p>
<ul>
<li>判断masterCandidates是否为空，为空返回false</li>
<li>判断discovery.zen.minimum_master_nodes配置的值（默认值为-1）是否小于1，确保单节点情况下的正常选主</li>
<li>判断masterCandidates中具备master资格的节点数据是否大于等于minimum_master_nodes</li>
</ul>
<p><strong>选举临时Master</strong></p>
<ul>
<li>首先对masterCandidates中的节点进行排序，优先使用版本号，版本号最高的排在前面，如果版本号一致，再跟进节点ID进行排序，节点ID小的排在前面</li>
<li>返回排序后最前面的节点，也就是第一个节点作为Master节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectMasterService</span> <span class="keyword">extends</span> <span class="title">AbstractComponent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否达到法定人数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEnoughCandidates</span><span class="params">(Collection&lt;MasterCandidate&gt; candidates)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果为空返回false</span></span><br><span class="line">        <span class="keyword">if</span> (candidates.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// minimumMasterNodes默认值为-1，确保单节点情况下正常选主</span></span><br><span class="line">        <span class="keyword">if</span> (minimumMasterNodes &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> candidates.stream().map(MasterCandidate::getNode).collect(Collectors.toSet()).size() == candidates.size() :</span><br><span class="line">            <span class="string">"duplicates ahead: "</span> + candidates;</span><br><span class="line">        <span class="comment">// 判断是否达到法定人数</span></span><br><span class="line">        <span class="keyword">return</span> candidates.size() &gt;= minimumMasterNodes;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选举Master</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MasterCandidate <span class="title">electMaster</span><span class="params">(Collection&lt;MasterCandidate&gt; candidates)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">hasEnoughCandidates</span><span class="params">(candidates)</span></span>;</span><br><span class="line">        List&lt;MasterCandidate&gt; sortedCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;(candidates);</span><br><span class="line">        <span class="comment">// 对节点进行排序</span></span><br><span class="line">        sortedCandidates.sort(MasterCandidate::compare);</span><br><span class="line">        <span class="comment">// 获取排序后的第一个节点作为Master节点</span></span><br><span class="line">        <span class="keyword">return</span> sortedCandidates.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部类，自定义比较函数在此类中实现</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterCandidate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> UNRECOVERED_CLUSTER_VERSION = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DiscoveryNode node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> clusterStateVersion;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MasterCandidate</span><span class="params">(DiscoveryNode node, <span class="keyword">long</span> clusterStateVersion)</span> </span>&#123;</span><br><span class="line">            Objects.requireNonNull(node);</span><br><span class="line">            <span class="keyword">assert</span> clusterStateVersion &gt;= -<span class="number">1</span> : <span class="string">"got: "</span> + clusterStateVersion;</span><br><span class="line">            <span class="keyword">assert</span> node.isMasterNode();</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.clusterStateVersion = clusterStateVersion;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DiscoveryNode <span class="title">getNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getClusterStateVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> clusterStateVersion;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Candidate&#123;"</span> +</span><br><span class="line">                <span class="string">"node="</span> + node +</span><br><span class="line">                <span class="string">", clusterStateVersion="</span> + clusterStateVersion +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自定义比较函数，早期版本中对节点ID排序，现在优先使集群状态版本号排序，版本号高的放在前面，版本号一致的再对比节点ID，节点ID小的排前面</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(MasterCandidate c1, MasterCandidate c2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 比较版本号，注意这里c2在前</span></span><br><span class="line">            <span class="keyword">int</span> ret = Long.compare(c2.clusterStateVersion, c1.clusterStateVersion);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果版本号一致比较节点的ID</span></span><br><span class="line">                ret = compareNodes(c1.getNode(), c2.getNode());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *  根据节点ID比较大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareNodes</span><span class="params">(DiscoveryNode o1, DiscoveryNode o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否具有master节点资格是为了给其他函数调用的，masterCandidates中的节点都已经具备了master节点资格</span></span><br><span class="line">        <span class="comment">// 如果o1具备Master节点资格，o2不具备，返回-1，也就是o1排前面</span></span><br><span class="line">        <span class="keyword">if</span> (o1.isMasterNode() &amp;&amp; !o2.isMasterNode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果o1不具备master节点资格而o2有，返回1，o2排前面</span></span><br><span class="line">        <span class="keyword">if</span> (!o1.isMasterNode() &amp;&amp; o2.isMasterNode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较节点的ID</span></span><br><span class="line">        <span class="keyword">return</span> o1.getId().compareTo(o2.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（2）从activeMasters选举</strong></p>
<p>从activeMasters选举的过程比较简单，具体的实现也在ElectMasterService中。首先通过compareNodes方法对节点ID排序，然后取节点ID最小的作为临时的Master。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectMasterService</span> <span class="keyword">extends</span> <span class="title">AbstractComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DiscoveryNode <span class="title">tieBreakActiveMasters</span><span class="params">(Collection&lt;DiscoveryNode&gt; activeMasters)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取activeMasters中节点ID最小的作为Master，同样使用compareNodes进行排序</span></span><br><span class="line">        <span class="keyword">return</span> activeMasters.stream().min(ElectMasterService::compareNodes).get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *  根据节点ID比较大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareNodes</span><span class="params">(DiscoveryNode o1, DiscoveryNode o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否具有master节点资格是为了给其他函数调用的，masterCandidates中的节点都已经具备了master节点资格</span></span><br><span class="line">        <span class="comment">// 如果o1具备Master节点资格，o2不具备，返回-1，也就是o1排前面</span></span><br><span class="line">        <span class="keyword">if</span> (o1.isMasterNode() &amp;&amp; !o2.isMasterNode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果o1不具备master节点资格而o2有，返回1，o2排前面</span></span><br><span class="line">        <span class="keyword">if</span> (!o1.isMasterNode() &amp;&amp; o2.isMasterNode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较节点的ID</span></span><br><span class="line">        <span class="keyword">return</span> o1.getId().compareTo(o2.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-确立Master"><a href="#2-确立Master" class="headerlink" title="2.确立Master"></a>2.确立Master</h4><p>上一步选举出的临时的Master有两种情况，临时Master就是当前节点或者临时Master不是当前节点。<br>在ES中，向节点发送join请求就是发送投票，被发送请求的节点将会得到一票。</p>
<p><strong>（1）临时Master节点为当前节点</strong></p>
<ul>
<li>等待足够多的具有Master资格的节点加入本节点，达到法定人数的投票数量时完成选主</li>
<li>如果等待超时后还没有满足法定数量，选举失败，将会进行新一轮的选举</li>
<li>如果选主成功，将会发布新的cluster state version</li>
</ul>
<p><strong><strong>ZenDiscovery</strong></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZenDiscovery</span> <span class="keyword">extends</span> <span class="title">AbstractLifecycleComponent</span> <span class="keyword">implements</span> <span class="title">Discovery</span>, <span class="title">PingContextProvider</span>, <span class="title">IncomingClusterStateListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">innerJoinCluster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DiscoveryNode masterNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> Thread currentThread = Thread.currentThread();</span><br><span class="line">        nodeJoinController.startElectionContext();</span><br><span class="line">        <span class="comment">// 如果master为空</span></span><br><span class="line">        <span class="keyword">while</span> (masterNode == <span class="keyword">null</span> &amp;&amp; joinThreadControl.joinThreadActive(currentThread)) &#123;</span><br><span class="line">            <span class="comment">// 选举临时的Master</span></span><br><span class="line">            masterNode = findMaster();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!joinThreadControl.joinThreadActive(currentThread)) &#123;</span><br><span class="line">            logger.trace(<span class="string">"thread is no longer in currentJoinThread. Stopping."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果选举出的Master节点是当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (transportService.getLocalNode().equals(masterNode)) &#123;</span><br><span class="line">            <span class="comment">// 因为选举出的Master节点是当前节点，所以minimum_master_nodes数量-1，得到被选举为Master需要的最少节点数量，也就是法定人数</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> requiredJoins = Math.max(<span class="number">0</span>, electMaster.minimumMasterNodes() - <span class="number">1</span>); </span><br><span class="line">            logger.debug(<span class="string">"elected as master, waiting for incoming joins ([&#123;&#125;] needed)"</span>, requiredJoins);</span><br><span class="line">            <span class="comment">// 根据法定人数等待其他节点的加入（投票），等待完成选举</span></span><br><span class="line">            nodeJoinController.waitToBeElectedAsMaster(requiredJoins, masterElectionWaitForJoinsTimeout,</span><br><span class="line">                    <span class="keyword">new</span> NodeJoinController.ElectionCallback() &#123;<span class="comment">// 回调函数</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onElectedAsMaster</span><span class="params">(ClusterState state)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">synchronized</span> (stateMutex) &#123;</span><br><span class="line">                               <span class="comment">// 选举完成 joinThreadControl.markThreadAsDone(currentThread);</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;<span class="comment">// 如果选举失败</span></span><br><span class="line">                            logger.trace(<span class="string">"failed while waiting for nodes to join, rejoining"</span>, t);</span><br><span class="line">                            <span class="keyword">synchronized</span> (stateMutex) &#123;</span><br><span class="line">                               <span class="comment">// 重新选举 joinThreadControl.markThreadAsDoneAndStartNew(currentThread);</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（2）临时Master节点不是当前节点</strong></p>
<ul>
<li>当前节点停止接收其他节点的join请求</li>
<li>最终当选的Master会先发布集群状态，之后确认其他节点的join请求。</li>
<li>当前节点向Master节点发送join请求，并且等待Master的回复（默认为1分钟），如果失败重新发送join请求（默认重试3次），如果回复成功，从集群中获取Master节点，判断与临时Master是否一致，如果不一致重新选举。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZenDiscovery</span> <span class="keyword">extends</span> <span class="title">AbstractLifecycleComponent</span> <span class="keyword">implements</span> <span class="title">Discovery</span>, <span class="title">PingContextProvider</span>, <span class="title">IncomingClusterStateListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">innerJoinCluster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果选举出的Master节点是当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (transportService.getLocalNode().equals(masterNode)) &#123;</span><br><span class="line">           ......</span><br><span class="line">           </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 选举出的Master节点不是当前节点</span></span><br><span class="line">            <span class="comment">// 停止其他节点的join请求</span></span><br><span class="line">            nodeJoinController.stopElectionContext(masterNode + <span class="string">" elected"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为当前节点不是当选的临时master节点,临时Master节点当做最终的Master节点，向Master节点发出join请求</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> success = joinElectedMaster(masterNode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (stateMutex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (success) &#123;<span class="comment">// 如果成功</span></span><br><span class="line">                    <span class="comment">// 从集群中获取Master节点</span></span><br><span class="line">                    DiscoveryNode currentMasterNode = <span class="keyword">this</span>.clusterState().getNodes().getMasterNode();</span><br><span class="line">                    <span class="keyword">if</span> (currentMasterNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果master为空，重新选举</span></span><br><span class="line">                        logger.debug(<span class="string">"no master node is set, despite of join request completing. retrying pings."</span>);</span><br><span class="line">                        joinThreadControl.markThreadAsDoneAndStartNew(currentThread);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentMasterNode.equals(masterNode) == <span class="keyword">false</span>) &#123; <span class="comment">//如果当选的master节点不是之前选出的临时Master节点</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 停止当前线程并且重新join joinThreadControl.stopRunningThreadAndRejoin("master_switched_while_finalizing_join");</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//选举</span></span><br><span class="line">                    joinThreadControl.markThreadAsDone(currentThread);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果请求失败，重新发出join请求</span></span><br><span class="line">                    joinThreadControl.markThreadAsDoneAndStartNew(currentThread);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>投票与得票的实现</strong></p>
<p>在确定Master节点的时候，如果推选的临时Master为当前节点，有一步是调用waitToBeElectedAsMaster方法，等待当前节点被推举为真正的Master节点，借助waitToBeElectedAsMaster方法看一下投票与得票的实现。</p>
<p><strong>NodeJoinController</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeJoinController</span> <span class="keyword">extends</span> <span class="title">AbstractComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitToBeElectedAsMaster</span><span class="params">(<span class="keyword">int</span> requiredMasterJoins, TimeValue timeValue, <span class="keyword">final</span> ElectionCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个计数器</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch done = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建回调函数</span></span><br><span class="line">        <span class="keyword">final</span> ElectionCallback wrapperCallback = <span class="keyword">new</span> ElectionCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onElectedAsMaster</span><span class="params">(ClusterState state)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 选举成功，计数器减1</span></span><br><span class="line">                done.countDown();</span><br><span class="line">                callback.onElectedAsMaster(state);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 如果选举失败，计数器减1</span></span><br><span class="line">                done.countDown();</span><br><span class="line">                callback.onFailure(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ElectionContext myElectionContext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断ElectionContext是否为空</span></span><br><span class="line">                <span class="keyword">assert</span> electionContext != <span class="keyword">null</span> : <span class="string">"waitToBeElectedAsMaster is called we are not accumulating joins"</span>;</span><br><span class="line">                myElectionContext = electionContext;</span><br><span class="line">                <span class="comment">// 设置回调函数和法定人数，为选举做准备</span></span><br><span class="line">                electionContext.onAttemptToBeElected(requiredMasterJoins, wrapperCallback);</span><br><span class="line">                <span class="comment">// 这里判断是否到达法定人数，如果达到，被选为Master</span></span><br><span class="line">                checkPendingJoinsAndElectIfNeeded();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 选主成功或失败都会将计数器减1，这里等待选举结束（设置了超时时间，如果在这段时间内选举还没有结束，放弃等待）</span></span><br><span class="line">                <span class="keyword">if</span> (done.await(timeValue.millis(), TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                    <span class="comment">// callback handles everything</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                <span class="comment">// 再次收集投票数量</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pendingNodes = myElectionContext.getPendingMasterJoinsCount();</span><br><span class="line">                logger.trace(<span class="string">"timed out waiting to be elected. waited [&#123;&#125;]. pending master node joins [&#123;&#125;]"</span>, timeValue, pendingNodes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 停止选举</span></span><br><span class="line">            failContextIfNeeded(myElectionContext, <span class="string">"timed out waiting to be elected"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"unexpected failure while waiting for incoming joins"</span>, e);</span><br><span class="line">            <span class="keyword">if</span> (myElectionContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">                failContextIfNeeded(myElectionContext, <span class="string">"unexpected failure while waiting for pending joins ["</span> + e.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查发送请求的数量（投票数）是否达到成为Master的条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">checkPendingJoinsAndElectIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> electionContext != <span class="keyword">null</span> : <span class="string">"election check requested but no active context"</span>;</span><br><span class="line">        <span class="comment">// 获取投票数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pendingMasterJoins = electionContext.getPendingMasterJoinsCount();</span><br><span class="line">        <span class="comment">// 判断投票数是否达到法定人数</span></span><br><span class="line">        <span class="keyword">if</span> (electionContext.isEnoughPendingJoins(pendingMasterJoins) == <span class="keyword">false</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"not enough joins for election. Got [&#123;&#125;], required [&#123;&#125;]"</span>, pendingMasterJoins,</span><br><span class="line">                    electionContext.requiredMasterJoins);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果达到了法定人数</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"have enough joins for election. Got [&#123;&#125;], required [&#123;&#125;]"</span>, pendingMasterJoins,</span><br><span class="line">                    electionContext.requiredMasterJoins);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 成为Master节点</span></span><br><span class="line">            electionContext.closeAndBecomeMaster();</span><br><span class="line">            electionContext = <span class="keyword">null</span>; <span class="comment">// clear this out so future joins won't be accumulated</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选举为Master</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">closeAndBecomeMaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> callback != <span class="keyword">null</span> : <span class="string">"becoming a master but the callback is not yet set"</span>;</span><br><span class="line">            <span class="function"><span class="keyword">assert</span> <span class="title">isEnoughPendingJoins</span><span class="params">(getPendingMasterJoinsCount()</span>) : "becoming a master but pending joins of "</span></span><br><span class="line"><span class="function">                + <span class="title">getPendingMasterJoinsCount</span><span class="params">()</span> + " are not enough. needs [" + requiredMasterJoins + "]</span>;<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            innerClose();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            Map&lt;DiscoveryNode, ClusterStateTaskListener&gt; tasks = getPendingAsTasks();</span></span><br><span class="line"><span class="string">            final String source = "</span>zen-disco-elected-as-master ([<span class="string">" + tasks.size() + "</span>] nodes joined)<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            tasks.put(BECOME_MASTER_TASK, (source1, e) -&gt; &#123;&#125;); // noop listener, the election finished listener determines result</span></span><br><span class="line"><span class="string">            tasks.put(FINISH_ELECTION_TASK, electionFinishedListener);</span></span><br><span class="line"><span class="string">            // 这里更新cluster state version</span></span><br><span class="line"><span class="string">            masterService.submitStateUpdateTasks(source, tasks, ClusterStateTaskConfig.build(Priority.URGENT), joinTaskExecutor);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    // 是否达到法定人数</span></span><br><span class="line"><span class="string">    public synchronized boolean isEnoughPendingJoins(int pendingMasterJoins) &#123;</span></span><br><span class="line"><span class="string">            final boolean hasEnough;</span></span><br><span class="line"><span class="string">            // 如果法定人数小于0</span></span><br><span class="line"><span class="string">            if (requiredMasterJoins &lt; 0) &#123;</span></span><br><span class="line"><span class="string">                hasEnough = false;</span></span><br><span class="line"><span class="string">            &#125; else &#123;</span></span><br><span class="line"><span class="string">                assert callback != null : "</span>requiredMasterJoins is set but not the callback<span class="string">";</span></span><br><span class="line"><span class="string">                // 判断投票数是否达到法定人数</span></span><br><span class="line"><span class="string">                hasEnough = pendingMasterJoins &gt;= requiredMasterJoins;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            return hasEnough;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    class ElectionContext &#123;</span></span><br><span class="line"><span class="string">        private ElectionCallback callback = null;</span></span><br><span class="line"><span class="string">        private int requiredMasterJoins = -1;</span></span><br><span class="line"><span class="string">        private final Map&lt;DiscoveryNode, List&lt;MembershipAction.JoinCallback&gt;&gt; joinRequestAccumulator = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        final AtomicBoolean closed = new AtomicBoolean();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        public synchronized void onAttemptToBeElected(int requiredMasterJoins, ElectionCallback callback) &#123;</span></span><br><span class="line"><span class="string">            ensureOpen();</span></span><br><span class="line"><span class="string">            assert this.requiredMasterJoins &lt; 0;</span></span><br><span class="line"><span class="string">            assert this.callback == null;</span></span><br><span class="line"><span class="string">            this.requiredMasterJoins = requiredMasterJoins;</span></span><br><span class="line"><span class="string">            this.callback = callback;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       ......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // 获取投票数</span></span><br><span class="line"><span class="string">        public synchronized int getPendingMasterJoinsCount() &#123;</span></span><br><span class="line"><span class="string">            int pendingMasterJoins = 0;</span></span><br><span class="line"><span class="string">            // 节点收到的join连接被存储在joinRequestAccumulator，遍历joinRequestAccumulator.</span></span><br><span class="line"><span class="string">            for (DiscoveryNode node : joinRequestAccumulator.keySet()) &#123;</span></span><br><span class="line"><span class="string">                // 如果发送请求的节点具有master节点资格</span></span><br><span class="line"><span class="string">                if (node.isMasterNode()) &#123;</span></span><br><span class="line"><span class="string">                    // 投票数+1</span></span><br><span class="line"><span class="string">                    pendingMasterJoins++;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            return pendingMasterJoins;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        ......</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>参考：</strong></p>
<p>Elasticsearch源码解析与优化实战【张超】</p>
<p><a href="https://zhuanlan.zhihu.com/p/34858035" target="_blank" rel="noopener">Elasticsearch分布式一致性原理剖析(一)-节点篇</a></p>
<p><strong>Elasticsearch版本:6.1.2</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/31/【Elasticsearch】GET流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/31/【Elasticsearch】GET流程/" itemprop="url">【Elasticsearch】GET流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-31T13:50:00+08:00">
                2019-01-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="GET基本流程"><a href="#GET基本流程" class="headerlink" title="GET基本流程"></a>GET基本流程</h3><p>GET是根据index、type和ID向ES发送请求，获取文档数据，是读取操作，因此主分片或者副本分片都可以返回文档，不过新增的文档已经写入到主分片中但是还没有复制到副本分片时，副本分片可能会报告文档不存在。</p>
<p>假设有三个节点，分别存储着分片0和分片1，P开头的为主分片，R开头的为副本分片：</p>
<p><img src="/images/es_get_1.png" alt=""> </p>
<p>1.客户端向节点1发送GET请求</p>
<p>2.节点根据文档的ID判断文档属于哪个分片，这里假设文档属于分片0，通过集群状态中的内容路由表得知三个节点Node1、Node2、Node3中都含有分片0，此时节点1可以将请求发送给任意节点，假设发给了节点2</p>
<p>3.节点2根据ID从分片0上获取文档，然后将文档返回给节点1，由节点1返回给客户端</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="协调节点"><a href="#协调节点" class="headerlink" title="协调节点"></a>协调节点</h4><h5 id="1-路由"><a href="#1-路由" class="headerlink" title="1.路由"></a>1.路由</h5><ul>
<li>首先获取集群状态、节点列表等信息</li>
<li>根据路由算法（或者是请求参数中指定的优先级和集群状态确定）获取文档所在的分片，因为分片可能存在副本，因此得到的是一个列表</li>
</ul>
<p><strong>TransportSingleShardAction</strong></p>
<p>TransportSingleShardAction.AsyncSingleAction的构造函数中，准备集群状态、节点列表等信息，并计算文档所在分片：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportSingleShardAction</span>&lt;<span class="title">Request</span> <span class="keyword">extends</span> <span class="title">SingleShardRequest</span>&lt;<span class="title">Request</span>&gt;, <span class="title">Response</span> <span class="keyword">extends</span> <span class="title">ActionResponse</span>&gt; <span class="keyword">extends</span> <span class="title">TransportAction</span>&lt;<span class="title">Request</span>, <span class="title">Response</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AsyncSingleAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ActionListener&lt;Response&gt; listener;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ShardsIterator shardIt;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> InternalRequest internalRequest;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DiscoveryNodes nodes;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Exception lastFailure;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">AsyncSingleAction</span><span class="params">(Request request, ActionListener&lt;Response&gt; listener)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.listener = listener;</span><br><span class="line">            <span class="comment">// 集群状态</span></span><br><span class="line">            ClusterState clusterState = clusterService.state();</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"executing [&#123;&#125;] based on cluster state version [&#123;&#125;]"</span>, request, clusterState.version());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 集群中的节点列表</span></span><br><span class="line">            nodes = clusterState.nodes();</span><br><span class="line">            ClusterBlockException blockException = checkGlobalBlock(clusterState);</span><br><span class="line">            <span class="keyword">if</span> (blockException != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> blockException;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String concreteSingleIndex;</span><br><span class="line">            <span class="keyword">if</span> (resolveIndex(request)) &#123;</span><br><span class="line">                <span class="comment">// 获取索引名称</span></span><br><span class="line">                concreteSingleIndex = indexNameExpressionResolver.concreteSingleIndex(clusterState, request).getName();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                concreteSingleIndex = request.index();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建InternalRequest对象</span></span><br><span class="line">            <span class="keyword">this</span>.internalRequest = <span class="keyword">new</span> InternalRequest(request, concreteSingleIndex);</span><br><span class="line">            <span class="comment">// 解析请求</span></span><br><span class="line">            resolveRequest(clusterState, internalRequest);</span><br><span class="line">            blockException = checkRequestBlock(clusterState, internalRequest);</span><br><span class="line">            <span class="keyword">if</span> (blockException != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> blockException;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据路由算法得到文档属于哪个shard，或者根据请求中设置的参数选择，因为分片可能存在多个副本，因此得到的是一个迭代器</span></span><br><span class="line">            <span class="keyword">this</span>.shardIt = shards(clusterState, internalRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-转发"><a href="#2-转发" class="headerlink" title="2.转发"></a>2.转发</h5><ul>
<li>根据分片所在的节点ID从集群中的节点列表获取该节点，得到目标节点</li>
<li><p>调用TransportService的sendRequest方法向目标节点转发请求，在转发之前判断本机节点是否是目标节点：</p>
<p>  （1）如果本机节点是目标节点，返回的连接是localNodeConnection，进入TransportService的sendLocalRequest流程</p>
<p>  （2）如果本机节点不是目标节点，返回一个连接目标节点的Connection，然后异步发送请求到网络，等待处理的Response</p>
</li>
<li>等待数据节点的回复，如果数据节点处理成功，返回给客户端，如果处理失败进行重试</li>
</ul>
<p><strong>TransportSingleShardAction</strong></p>
<p>TransportSingleShardAction.AsyncSingleAction的perform方法向目标节点转发请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(@Nullable <span class="keyword">final</span> Exception currentFailure)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> ShardRouting shardRouting = shardIt.nextOrNull();</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据分片所在的节点ID从集群中的节点列表获取该节点，得到目标节点</span></span><br><span class="line">    DiscoveryNode node = nodes.get(shardRouting.currentNodeId());</span><br><span class="line">    <span class="comment">// 如果节点为空抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onFailure(shardRouting, <span class="keyword">new</span> NoShardAvailableActionException(shardRouting.shardId()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 目标分片的id</span></span><br><span class="line">        internalRequest.request().internalShardId = shardRouting.shardId();</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(</span><br><span class="line">                    <span class="string">"sending request [&#123;&#125;] to shard [&#123;&#125;] on node [&#123;&#125;]"</span>,</span><br><span class="line">                    internalRequest.request(),</span><br><span class="line">                    internalRequest.request().internalShardId,</span><br><span class="line">                    node</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向目标节点转发请求</span></span><br><span class="line">        transportService.sendRequest(node, transportShardAction, internalRequest.request(), <span class="keyword">new</span> TransportResponseHandler&lt;Response&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Response <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> newResponse();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">executor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ThreadPool.Names.SAME;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(<span class="keyword">final</span> Response response)</span> </span>&#123;</span><br><span class="line">                listener.onResponse(response);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(TransportException exp)</span> </span>&#123;</span><br><span class="line">                onFailure(shardRouting, exp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>TransportService</strong></p>
<p>TransportService实现了sendRequest方法，在转发请求前，调用getConnection判断当前节点是否是目标节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TransportService extends AbstractLifecycleComponent &#123;</span><br><span class="line">    public &lt;T extends TransportResponse&gt; void sendRequest(final DiscoveryNode node, final String action,</span><br><span class="line">                                                                final TransportRequest request,</span><br><span class="line">                                                                final TransportResponseHandler&lt;T&gt; handler) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取目标节点的连接</span><br><span class="line">            Transport.Connection connection = getConnection(node);</span><br><span class="line">            // 向目标节点发送请求</span><br><span class="line">            sendRequest(connection, action, request, TransportRequestOptions.EMPTY, handler);</span><br><span class="line">        &#125; catch (NodeNotConnectedException ex) &#123;</span><br><span class="line">            // the caller might not handle this so we invoke the handler</span><br><span class="line">            handler.handleException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Transport.Connection getConnection(DiscoveryNode node) &#123;</span><br><span class="line">        // 判断当前节点是否是目标节点</span><br><span class="line">        if (isLocalNode(node)) &#123;</span><br><span class="line">            return localNodeConnection;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果当前节点不是目标节点，获取目标节点的连接</span><br><span class="line">            return transport.getConnection(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h4><p>数据节点收到协调节点的请求，读取数据并返回Response，入口在TransportSingleShardAction.ShardTransportHandler的messageReceived方法中。</p>
<p><strong>TransportSingleShardAction</strong></p>
<p>TransportSingleShardAction.ShardTransportHandler的messageReceived是接收协调节点请求的入口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class TransportSingleShardAction&lt;Request extends SingleShardRequest&lt;Request&gt;, Response extends ActionResponse&gt; extends TransportAction&lt;Request, Response&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private class ShardTransportHandler implements TransportRequestHandler&lt;Request&gt; &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void messageReceived(final Request request, final TransportChannel channel) throws Exception &#123;</span><br><span class="line">            if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(&quot;executing [&#123;&#125;] on shard [&#123;&#125;]&quot;, request, request.internalShardId);</span><br><span class="line">            &#125;</span><br><span class="line">            // 读取数据并封装成Response</span><br><span class="line">            Response response = shardOperation(request, request.internalShardId);</span><br><span class="line">            // 发送响应</span><br><span class="line">            channel.sendResponse(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>具体的读取过程</strong>：</p>
<p><strong>TransportGetAction</strong></p>
<p>TransportGetAction的shardOperation方法中调用了ShardGetService的get方法读取数据并存入GetResult中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TransportGetAction extends TransportSingleShardAction&lt;GetRequest, GetResponse&gt; &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">    protected GetResponse shardOperation(GetRequest request, ShardId shardId) &#123;</span><br><span class="line">        IndexService indexService = indicesService.indexServiceSafe(shardId.getIndex());</span><br><span class="line">        IndexShard indexShard = indexService.getShard(shardId.id());</span><br><span class="line">        // 检查是否需要refresh</span><br><span class="line">        if (request.refresh() &amp;&amp; !request.realtime()) &#123;</span><br><span class="line">            indexShard.refresh(&quot;refresh_flag_get&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 调用ShardGetService的get方法读取数据并存入GetResult中</span><br><span class="line">        GetResult result = indexShard.getService().get(request.type(), request.id(), request.storedFields(),</span><br><span class="line">                request.realtime(), request.version(), request.versionType(), request.fetchSourceContext());</span><br><span class="line">        return new GetResponse(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>ShardGetService</strong></p>
<p>ShardGetService的get中又调用了innerGet方法，这里才是核心的数据读取实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public final class ShardGetService extends AbstractIndexShardComponent &#123;</span><br><span class="line">    private GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext) &#123;</span><br><span class="line">        fetchSourceContext = normalizeFetchSourceContent(fetchSourceContext, gFields);</span><br><span class="line">        final Collection&lt;String&gt; types;</span><br><span class="line">        // 处理_all选项</span><br><span class="line">        if (type == null || type.equals(&quot;_all&quot;)) &#123;</span><br><span class="line">            types = mapperService.types();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            types = Collections.singleton(type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Engine.GetResult get = null;</span><br><span class="line">        for (String typeX : types) &#123;</span><br><span class="line">            Term uidTerm = mapperService.createUidTerm(typeX, id);</span><br><span class="line">            if (uidTerm != null) &#123;</span><br><span class="line">                // 调用indexShard.get获取读取数据，</span><br><span class="line">                get = indexShard.get(new Engine.Get(realtime, typeX, id, uidTerm)</span><br><span class="line">                        .version(version).versionType(versionType));</span><br><span class="line">                if (get.exists()) &#123;</span><br><span class="line">                    type = typeX;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    get.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (get == null || get.exists() == false) &#123;</span><br><span class="line">            // 返回结果</span><br><span class="line">            return new GetResult(shardId.getIndexName(), type, id, -1, false, null, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 对读取的数据进行过滤</span><br><span class="line">            return innerGetLoadFromStoredFields(type, id, gFields, fetchSourceContext, get, mapperService);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            get.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>indexShard.get()方法返回的Engine.GetResult类型，在get方法中又调用了InternalEngine的get方法读取数据</p>
<p><strong>IndexShard</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class IndexShard extends AbstractIndexShardComponent implements IndicesClusterStateService.Shard &#123;</span><br><span class="line">    public Engine.GetResult get(Engine.Get get) &#123;</span><br><span class="line">        readAllowed();</span><br><span class="line">        return getEngine().get(get, this::acquireSearcher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>InternalEngine</strong></p>
<p>InternalEngine的get方法读取数据，在早期的ES版本中，刚写入的数据可以从translog读取，以此达到实时搜索，所以读取过程中会加锁，处理realtime选项，如果realtime为true，判断是否需要刷盘。ES 5之后不再从translog中读取，只从Lucene中读取，实时搜索依靠refresh实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class InternalEngine extends Engine &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public GetResult get(Get get, BiFunction&lt;String, SearcherScope, Searcher&gt; searcherFactory) throws EngineException &#123;</span><br><span class="line">        assert Objects.equals(get.uid().field(), uidField) : get.uid().field();</span><br><span class="line">        // 加锁</span><br><span class="line">        try (ReleasableLock ignored = readLock.acquire()) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            SearcherScope scope;</span><br><span class="line">            // 处理realtime选项。判断是否需要刷盘</span><br><span class="line">            if (get.realtime()) &#123;</span><br><span class="line">                VersionValue versionValue = versionMap.getUnderLock(get.uid().bytes());</span><br><span class="line">                if (versionValue != null) &#123;</span><br><span class="line">                    if (versionValue.isDelete()) &#123;</span><br><span class="line">                        return GetResult.NOT_EXISTS;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (get.versionType().isVersionConflictForReads(versionValue.version, get.version())) &#123;</span><br><span class="line">                        throw new VersionConflictEngineException(shardId, get.type(), get.id(),</span><br><span class="line">                            get.versionType().explainConflictForReads(versionValue.version, get.version()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 执行刷盘操作</span><br><span class="line">                    refresh(&quot;realtime_get&quot;, SearcherScope.INTERNAL);</span><br><span class="line">                &#125;</span><br><span class="line">                scope = SearcherScope.INTERNAL;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                </span><br><span class="line">                scope = SearcherScope.EXTERNAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 调用searcher读取数据</span><br><span class="line">            return getFromSearcher(get, searcherFactory, scope);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>数据节点读取流程总结</strong>：</p>
<ul>
<li>数据节点接收到协调节点的请求读取数据</li>
<li>读取数据的核心实现是在ShardGetService的innerGet方法中实现的，在这个过程中，又依靠InternalEngine的get方法通过Searcher从Lucene中读取数据，然后innerGetLoadFromStoredFields方法对得到的数据进行过滤</li>
<li>数据节点将返回结果封装到Response中返回</li>
</ul>
<p><strong>参考：</strong></p>
<p>Elasticsearch源码解析与优化实战【张超】</p>
<p><strong>Elasticsearch版本:6.1.2</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/30/【Elasticsearch】写入流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/30/【Elasticsearch】写入流程/" itemprop="url">【Elasticsearch】写入流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-30T22:55:00+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Elasticsearch写入分为单个文档的写入和批量写入，单个文档的写入称作Index请求，批量写入称为Bulk请求，他们具有相同的处理逻辑，请求被统一封装为BuklRequest。</p>
<p><img src="/images/es_index_1.png" alt=""> </p>
<p>单个文档的写入流程：</p>
<p>1.客户端向Node1发送写入请求</p>
<p>2.Node1使用文档的id确定文档属于分片0,因为分片0的主分片不在当前节点，此时Node1充当协调节点，通过集群状态中的路由表可知分片0的主分片位于Node3，请求将会被转发到Node3</p>
<p>3.Node3上的主分片执行写入操作(需要有足够的活跃分片数)，如果写入成功，将请求转发到Node1和Node2上，因为这两个节点都有分片0的副本分片，Node3等待所有副本分片的响应结果，当所有的分片都写入成功时，Node3向协调节点发送响应，再由协调节点Node1向客户端报告写入成功</p>
<p><strong>1.活跃的分片数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final Request waitForActiveShards(ActiveShardCount waitForActiveShards) &#123;</span><br><span class="line">     this.waitForActiveShards = waitForActiveShards;</span><br><span class="line">     return (Request) this;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>ES写入一致性的默认策略是quorum，即多数的分片在写入操作时处于可用状态，计算方式如下：<br>quorum = int（（primary + number_of_replicas）/ 2）+ 1 </p>
<p>primary是主分片数量，number_of_replicas是副本分片数量，假设一个索引，每个主分片有3个副本分片，那么quorum =(1+3)/2+1 = 3，往这个索引的主分片写入数据时，活跃的分片数至少为3才能写入成功，如果有两个副本分片失效，活跃分片数为1个主分片和1个副本分片。此时活跃分片数为2，那么此时就不允许向此分片写入数据。</p>
<p>可以通过配置文件index.write.wait_for_active_shards设置活跃分片数，也可以在请求中添加参数，默认是1，只要主分片可以即可写入。</p>
<p>详细信息可参考官方文档：</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.1/docs-index_.html#index-wait-for-active-shards" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.1/docs-index_.html#index-wait-for-active-shards</a></p>
<p><strong>2.路由算法</strong></p>
<p>一般情况下，路由计算方式如下：</p>
<p>shard_num = hash(_routing) % num_primary_shards</p>
<p>_routing：默认情况下就是文档的id</p>
<p>num_primary_shards：主分片的数量</p>
<h3 id="协调节点流程"><a href="#协调节点流程" class="headerlink" title="协调节点流程"></a>协调节点流程</h3><ul>
<li>参数检查，遇到异常拒绝当前请求</li>
<li>写入时，如果索引未创建，自动创建对应的index，具体在TransportBulkAction的doExecute方法中</li>
<li>协调节点开始处理请求，入口为TransportBulkAction的executeBulk方法，之后进入TransportBulkAction的内部类BulkOperation中的doRun方法</li>
<li>doRun方法中，检查集群状态，如果集群有异常如Master节点不存在，写入请求会阻塞等待Master节点.</li>
<li>从集群中获取集群的元数据信息metaData.</li>
<li>遍历bulkRequest,从请求中获取每一个索引concreteIndex，判断请求类型，如果是写入操作，将请求转为IndexRequest，根据concreteIndex从metaData中获取该索引的元数据，之后获取索引的Mapping、创建版本号，并检查Mapping、ID等信息，如果ID为空将自动生成ID.</li>
<li>再次遍历bulkRequest，将每一个请求重新封装为基于shard的请求列表，这么做是为了将路由到同一个分片的所有请求封装到同一个Request中。在这个过程中，会使用路由算法计算文档应该存储到哪个分片上，得到分片的ID，然后将写入到同一个分片的请求合并到同一个shardRequests中.</li>
<li>遍历requestsByShard，里面记录了每个分片对应的所有写入请求，然后将分片请求封装为BulkShardRequest，等待有足够活跃的分片数，之后向分片执行请求，并在listener中等待响应，每个响应也是以shard为单位的，响应信息被设置到Response中.</li>
<li>向分片转发请求具体的实现位于TransportReplicationAction中，转发前同样获取最新的集群状态，根据集群状态中的内容路由表找到目的shard对应主分片所在的节点，如果主分片在当前节点中，直接在本地执行，否则转发到相应的节点中执行.</li>
</ul>
<p><strong>TransportBulkAction</strong></p>
<p>TransportBulkAction中BulkOperation的doRun方法解析用户请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportBulkAction</span> <span class="keyword">extends</span> <span class="title">HandledTransportAction</span>&lt;<span class="title">BulkRequest</span>, <span class="title">BulkResponse</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doExecute</span><span class="params">(Task task, BulkRequest bulkRequest, ActionListener&lt;BulkResponse&gt; listener)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needToCheck()) &#123;</span><br><span class="line">            <span class="comment">// 获取请求中所有的索引</span></span><br><span class="line">            <span class="keyword">final</span> Set&lt;String&gt; indices = bulkRequest.requests.stream()</span><br><span class="line">                .filter(request -&gt; request.opType() != DocWriteRequest.OpType.DELETE</span><br><span class="line">                        || request.versionType() == VersionType.EXTERNAL</span><br><span class="line">                        || request.versionType() == VersionType.EXTERNAL_GTE)</span><br><span class="line">                .map(DocWriteRequest::index)</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line">            <span class="keyword">final</span> Map&lt;String, IndexNotFoundException&gt; indicesThatCannotBeCreated = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            Set&lt;String&gt; autoCreateIndices = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            ClusterState state = clusterService.state();</span><br><span class="line">            <span class="comment">// 遍历所有的索引</span></span><br><span class="line">            <span class="keyword">for</span> (String index : indices) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> shouldAutoCreate;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 是否自动创建索引</span></span><br><span class="line">                    shouldAutoCreate = shouldAutoCreate(index, state);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexNotFoundException e) &#123;</span><br><span class="line">                    shouldAutoCreate = <span class="keyword">false</span>;</span><br><span class="line">                    indicesThatCannotBeCreated.put(index, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldAutoCreate) &#123;</span><br><span class="line">                    <span class="comment">// 自动创建索引</span></span><br><span class="line">                    autoCreateIndices.add(index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            ......</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executeBulk(task, bulkRequest, startTime, listener, responses, emptyMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BulkOperation</span> <span class="keyword">extends</span> <span class="title">AbstractRunnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理请求</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 检查集群状态，如果master节点不存在，会阻塞等待Master节点，甚至超时</span></span><br><span class="line">            <span class="keyword">final</span> ClusterState clusterState = observer.setAndGetObservedState();</span><br><span class="line">            <span class="keyword">if</span> (handleBlockExceptions(clusterState)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> ConcreteIndices concreteIndices = <span class="keyword">new</span> ConcreteIndices(clusterState, indexNameExpressionResolver);</span><br><span class="line">            <span class="comment">// 获取集群元数据</span></span><br><span class="line">            MetaData metaData = clusterState.metaData();</span><br><span class="line">            <span class="comment">// 遍历请求</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bulkRequest.requests.size(); i++) &#123;</span><br><span class="line">                DocWriteRequest docWriteRequest = bulkRequest.requests.get(i);</span><br><span class="line">                <span class="comment">//the request can only be null because we set it to null in the previous step, so it gets ignored</span></span><br><span class="line">                <span class="keyword">if</span> (docWriteRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (addFailureIfIndexIsUnavailable(docWriteRequest, i, concreteIndices, metaData)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取索引信息</span></span><br><span class="line">                Index concreteIndex = concreteIndices.resolveIfAbsent(docWriteRequest);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断操作类型</span></span><br><span class="line">                    <span class="keyword">switch</span> (docWriteRequest.opType()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> CREATE:</span><br><span class="line">                        <span class="keyword">case</span> INDEX:<span class="comment">//写入操作</span></span><br><span class="line">                            <span class="comment">// 转为IndexReqeust</span></span><br><span class="line">                            IndexRequest indexRequest = (IndexRequest) docWriteRequest;</span><br><span class="line">                            <span class="comment">// 获取索引的元数据</span></span><br><span class="line">                            <span class="keyword">final</span> IndexMetaData indexMetaData = metaData.index(concreteIndex);</span><br><span class="line">                            <span class="comment">// 获取mapping的元数据</span></span><br><span class="line">                            MappingMetaData mappingMd = indexMetaData.mappingOrDefault(indexRequest.type());</span><br><span class="line">                            <span class="comment">// 获取创建版本号</span></span><br><span class="line">                            Version indexCreated = indexMetaData.getCreationVersion();</span><br><span class="line">                            <span class="comment">// 处理路由</span></span><br><span class="line">                            indexRequest.resolveRouting(metaData);</span><br><span class="line">                            <span class="comment">// 检查mapping、id等信息</span></span><br><span class="line">                            indexRequest.process(indexCreated, mappingMd, concreteIndex.getName());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> UPDATE:<span class="comment">//更新操作</span></span><br><span class="line">                            TransportUpdateAction.resolveAndValidateRouting(metaData, concreteIndex.getName(), (UpdateRequest) docWriteRequest);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> DELETE:<span class="comment">//删除操作</span></span><br><span class="line">                            docWriteRequest.routing(metaData.resolveIndexRouting(docWriteRequest.parent(), docWriteRequest.routing(), docWriteRequest.index()));</span><br><span class="line">                            <span class="comment">// check if routing is required, if so, throw error if routing wasn't specified</span></span><br><span class="line">                            <span class="keyword">if</span> (docWriteRequest.routing() == <span class="keyword">null</span> &amp;&amp; metaData.routingRequired(concreteIndex.getName(), docWriteRequest.type())) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> RoutingMissingException(concreteIndex.getName(), docWriteRequest.type(), docWriteRequest.id());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"request type not supported: ["</span> + docWriteRequest.opType() + <span class="string">"]"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ElasticsearchParseException | IllegalArgumentException | RoutingMissingException e) &#123;</span><br><span class="line">                    BulkItemResponse.Failure failure = <span class="keyword">new</span> BulkItemResponse.Failure(concreteIndex.getName(), docWriteRequest.type(), docWriteRequest.id(), e);</span><br><span class="line">                    BulkItemResponse bulkItemResponse = <span class="keyword">new</span> BulkItemResponse(i, docWriteRequest.opType(), failure);</span><br><span class="line">                    responses.set(i, bulkItemResponse);</span><br><span class="line">                    <span class="comment">// make sure the request gets never processed again</span></span><br><span class="line">                    bulkRequest.requests.set(i, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将用户的请求重新封装为基于shard的请求列表</span></span><br><span class="line">            Map&lt;ShardId, List&lt;BulkItemRequest&gt;&gt; requestsByShard = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bulkRequest.requests.size(); i++) &#123;</span><br><span class="line">                DocWriteRequest request = bulkRequest.requests.get(i);</span><br><span class="line">                <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取索引</span></span><br><span class="line">                String concreteIndex = concreteIndices.getConcreteIndex(request.index()).getName();</span><br><span class="line">                <span class="comment">// 根据路由算法计算文档应该存储到哪个分片上，得到分片的ID</span></span><br><span class="line">                ShardId shardId = clusterService.operationRouting().indexShards(clusterState, concreteIndex, request.id(), request.routing()).shardId();</span><br><span class="line">                <span class="comment">// 根据分片id判断是否已经存入到requestsByShard中，如果存在就取出放入shardRequests，如果不存在将当前的分片ID作为Key，创建一个空的ArrayList作为value</span></span><br><span class="line">                List&lt;BulkItemRequest&gt; shardRequests = requestsByShard.computeIfAbsent(shardId, shard -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                <span class="comment">// 当前封装的请求添加到shardRequests中，为了将路由到同一个分片的文档封装到一个shardRequest中</span></span><br><span class="line">                shardRequests.add(<span class="keyword">new</span> BulkItemRequest(i, request));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果requestsByShard为空</span></span><br><span class="line">            <span class="keyword">if</span> (requestsByShard.isEmpty()) &#123;</span><br><span class="line">                listener.onResponse(<span class="keyword">new</span> BulkResponse(responses.toArray(<span class="keyword">new</span> BulkItemResponse[responses.length()]), buildTookInMillis(startTimeNanos)));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger(requestsByShard.size());</span><br><span class="line">            <span class="comment">// 当前节点的id</span></span><br><span class="line">            String nodeId = clusterService.localNode().getId();</span><br><span class="line">            <span class="comment">// 遍历requestsByShard</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;ShardId, List&lt;BulkItemRequest&gt;&gt; entry : requestsByShard.entrySet()) &#123;</span><br><span class="line">                <span class="comment">// 获取分片ID</span></span><br><span class="line">                <span class="keyword">final</span> ShardId shardId = entry.getKey();</span><br><span class="line">                <span class="comment">// 获取该分片ID对应的所有请求</span></span><br><span class="line">                <span class="keyword">final</span> List&lt;BulkItemRequest&gt; requests = entry.getValue();</span><br><span class="line">                <span class="comment">// 将请求封装为BulkShardRequest</span></span><br><span class="line">                BulkShardRequest bulkShardRequest = <span class="keyword">new</span> BulkShardRequest(shardId, bulkRequest.getRefreshPolicy(),</span><br><span class="line">                        requests.toArray(<span class="keyword">new</span> BulkItemRequest[requests.size()]));</span><br><span class="line">                <span class="comment">// 等待有足够活跃的分片数</span></span><br><span class="line">                bulkShardRequest.waitForActiveShards(bulkRequest.waitForActiveShards());</span><br><span class="line">                bulkShardRequest.timeout(bulkRequest.timeout());</span><br><span class="line">                <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bulkShardRequest.setParentTask(nodeId, task.getId());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 向分片执行请求，在listener中等待响应</span></span><br><span class="line">                shardBulkAction.execute(bulkShardRequest, <span class="keyword">new</span> ActionListener&lt;BulkShardResponse&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(BulkShardResponse bulkShardResponse)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (BulkItemResponse bulkItemResponse : bulkShardResponse.getResponses()) &#123;</span><br><span class="line">                            <span class="comment">// we may have no response if item failed</span></span><br><span class="line">                            <span class="keyword">if</span> (bulkItemResponse.getResponse() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                bulkItemResponse.getResponse().setShardInfo(bulkShardResponse.getShardInfo());</span><br><span class="line">                            &#125;</span><br><span class="line">                            responses.set(bulkItemResponse.getItemId(), bulkItemResponse);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (counter.decrementAndGet() == <span class="number">0</span>) &#123;</span><br><span class="line">                            finishHim();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// create failures for all relevant requests</span></span><br><span class="line">                        <span class="keyword">for</span> (BulkItemRequest request : requests) &#123;</span><br><span class="line">                            <span class="keyword">final</span> String indexName = concreteIndices.getConcreteIndex(request.index()).getName();</span><br><span class="line">                            DocWriteRequest docWriteRequest = request.request();</span><br><span class="line">                            responses.set(request.id(), <span class="keyword">new</span> BulkItemResponse(request.id(), docWriteRequest.opType(),</span><br><span class="line">                                    <span class="keyword">new</span> BulkItemResponse.Failure(indexName, docWriteRequest.type(), docWriteRequest.id(), e)));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (counter.decrementAndGet() == <span class="number">0</span>) &#123;</span><br><span class="line">                            finishHim();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishHim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        listener.onResponse(<span class="keyword">new</span> BulkResponse(responses.toArray(<span class="keyword">new</span> BulkItemResponse[responses.length()]), buildTookInMillis(startTimeNanos)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>TransportReplicationAction</strong></p>
<p>TransportReplicationAction的内部类ReroutePhase中的doRun方法向分片转发请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportReplicationAction</span>&lt;</span></span><br><span class="line"><span class="class">            <span class="title">Request</span> <span class="keyword">extends</span> <span class="title">ReplicationRequest</span>&lt;<span class="title">Request</span>&gt;,</span></span><br><span class="line"><span class="class">            <span class="title">ReplicaRequest</span> <span class="keyword">extends</span> <span class="title">ReplicationRequest</span>&lt;<span class="title">ReplicaRequest</span>&gt;,</span></span><br><span class="line"><span class="class">            <span class="title">Response</span> <span class="keyword">extends</span> <span class="title">ReplicationResponse</span></span></span><br><span class="line"><span class="class">        &gt; <span class="keyword">extends</span> <span class="title">TransportAction</span>&lt;<span class="title">Request</span>, <span class="title">Response</span>&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReroutePhase</span> <span class="keyword">extends</span> <span class="title">AbstractRunnable</span> </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            setPhase(task, <span class="string">"routing"</span>);</span><br><span class="line">            <span class="comment">// 获取集群状态</span></span><br><span class="line">            <span class="keyword">final</span> ClusterState state = observer.setAndGetObservedState();</span><br><span class="line">            <span class="keyword">if</span> (handleBlockExceptions(state)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取请求中的索引</span></span><br><span class="line">            <span class="keyword">final</span> String concreteIndex = concreteIndex(state);</span><br><span class="line">            <span class="comment">// 获取索引元数据</span></span><br><span class="line">            <span class="keyword">final</span> IndexMetaData indexMetaData = state.metaData().index(concreteIndex);</span><br><span class="line">            <span class="comment">// 如果元数据为空</span></span><br><span class="line">            <span class="keyword">if</span> (indexMetaData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                retry(<span class="keyword">new</span> IndexNotFoundException(concreteIndex));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (indexMetaData.getState() == IndexMetaData.State.CLOSE) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexClosedException(indexMetaData.getIndex());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待足够活跃的分片数</span></span><br><span class="line">            resolveRequest(indexMetaData, request);</span><br><span class="line">            <span class="keyword">assert</span> request.shardId() != <span class="keyword">null</span> : <span class="string">"request shardId must be set in resolveRequest"</span>;</span><br><span class="line">            <span class="keyword">assert</span> request.waitForActiveShards() != ActiveShardCount.DEFAULT : <span class="string">"request waitForActiveShards must be set in resolveRequest"</span>;</span><br><span class="line">            <span class="comment">// 获取主分片所在节点</span></span><br><span class="line">            <span class="keyword">final</span> ShardRouting primary = primary(state);</span><br><span class="line">            <span class="keyword">if</span> (retryIfUnavailable(state, primary)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> DiscoveryNode node = state.nodes().get(primary.currentNodeId());</span><br><span class="line">            <span class="comment">// 如果主分片在本机节点,在本地执行</span></span><br><span class="line">            <span class="keyword">if</span> (primary.currentNodeId().equals(state.nodes().getLocalNodeId())) &#123;</span><br><span class="line">                performLocalAction(state, primary, node, indexMetaData);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 转发到主分片所在节点</span></span><br><span class="line">                performRemoteAction(state, primary, node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="主分片节点流程"><a href="#主分片节点流程" class="headerlink" title="主分片节点流程"></a>主分片节点流程</h3><p>主分片所在的节点收到协调节点发送的请求后，开始执行写入操作，入口在ReplicationOperation中的execute方法中，写入成功后转发到副本分片，等待响应并回复协调节点。</p>
<ul>
<li>主分片在收到协调节点发送的请求后首先也做校验工作，检验是否是主分片，索引是否处于关闭状态等</li>
<li>判断请求是否需要延迟执行</li>
<li>判断主分片是否已经发生迁移</li>
<li>检测活跃的shard数量是否足够，只要主分片可用就执行写入</li>
<li>具体写入的入口在ReplicationOperation中的execute方法</li>
<li>接下来进入TransportShardBulkAction的performOnPrimary方法（中间省略了一些步骤），继续省略一些调用过程，最后进入到InternalEngine的index方法，在这里将数据写入Lucene</li>
<li>写入Lucene后将写入操作添加到translog，如果Lucene写入失败，需要对translog进行回滚</li>
<li>根据配置的translog flush策略进行刷盘控制</li>
<li>主分片写入完毕后转发给副本分片，副本分片执行写入操作，主分片等待副本分片的响应</li>
<li>收到副本分片的全部响应后，执行finish，向协调节点返回消息，告之成功与失败的操作</li>
<li>副本分片写入失败时，主分片所在节点将发送一个shardFaild请求给Master</li>
</ul>
<p><strong>ReplicationOperation</strong></p>
<p>ReplicationOperation的execute方法是主分片写入操作的入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplicationOperation</span>&lt;</span></span><br><span class="line"><span class="class">            <span class="title">Request</span> <span class="keyword">extends</span> <span class="title">ReplicationRequest</span>&lt;<span class="title">Request</span>&gt;,</span></span><br><span class="line"><span class="class">            <span class="title">ReplicaRequest</span> <span class="keyword">extends</span> <span class="title">ReplicationRequest</span>&lt;<span class="title">ReplicaRequest</span>&gt;,</span></span><br><span class="line"><span class="class">            <span class="title">PrimaryResultT</span> <span class="keyword">extends</span> <span class="title">ReplicationOperation</span>.<span class="title">PrimaryResult</span>&lt;<span class="title">ReplicaRequest</span>&gt;</span></span><br><span class="line"><span class="class">        &gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主分片写入操作入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 检查活跃分片数量</span></span><br><span class="line">        <span class="keyword">final</span> String activeShardCountFailure = checkActiveShardCount();</span><br><span class="line">        <span class="keyword">final</span> ShardRouting primaryRouting = primary.routingEntry();</span><br><span class="line">        <span class="keyword">final</span> ShardId primaryId = primaryRouting.shardId();</span><br><span class="line">        <span class="keyword">if</span> (activeShardCountFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">            finishAsFailed(<span class="keyword">new</span> UnavailableShardsException(primaryId,</span><br><span class="line">                <span class="string">"&#123;&#125; Timeout: [&#123;&#125;], request: [&#123;&#125;]"</span>, activeShardCountFailure, request.timeout(), request));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        totalShards.incrementAndGet();</span><br><span class="line">        pendingActions.incrementAndGet(); <span class="comment">// increase by 1 until we finish all primary coordination</span></span><br><span class="line">        <span class="comment">// 开始执行写入操作</span></span><br><span class="line">        primaryResult = primary.perform(request);</span><br><span class="line">        <span class="comment">// 更新分片的check point</span></span><br><span class="line">        primary.updateLocalCheckpointForShard(primaryRouting.allocationId().getId(), primary.localCheckpoint());</span><br><span class="line">        <span class="comment">// 获取副本请求</span></span><br><span class="line">        <span class="keyword">final</span> ReplicaRequest replicaRequest = primaryResult.replicaRequest();</span><br><span class="line">        <span class="keyword">if</span> (replicaRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"[&#123;&#125;] op [&#123;&#125;] completed on primary for request [&#123;&#125;]"</span>, primaryId, opType, request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 全局check point</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> globalCheckpoint = primary.globalCheckpoint();</span><br><span class="line">            <span class="keyword">final</span> ReplicationGroup replicationGroup = primary.getReplicationGroup();</span><br><span class="line">            markUnavailableShardsAsStale(replicaRequest, replicationGroup.getInSyncAllocationIds(), replicationGroup.getRoutingTable());</span><br><span class="line">            <span class="comment">// 转发请求到副本分片</span></span><br><span class="line">            performOnReplicas(replicaRequest, globalCheckpoint, replicationGroup.getRoutingTable());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        successfulShards.incrementAndGet();  <span class="comment">// mark primary as successful</span></span><br><span class="line">        decPendingAndFinishIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>TransportShardBulkAction</strong></p>
<p>TransportShardBulkAction的performOnPrimary方法中主分片执行写入操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportShardBulkAction</span> <span class="keyword">extends</span> <span class="title">TransportWriteAction</span>&lt;<span class="title">BulkShardRequest</span>, <span class="title">BulkShardRequest</span>, <span class="title">BulkShardResponse</span>&gt; </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WritePrimaryResult&lt;BulkShardRequest, BulkShardResponse&gt; <span class="title">shardOperationOnPrimary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            BulkShardRequest request, IndexShard primary)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> performOnPrimary(request, primary, updateHelper, threadPool::absoluteTimeInMillis, <span class="keyword">new</span> ConcreteMappingUpdatePerformer());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主分片写入操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WritePrimaryResult&lt;BulkShardRequest, BulkShardResponse&gt; <span class="title">performOnPrimary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            BulkShardRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            IndexShard primary,</span></span></span><br><span class="line"><span class="function"><span class="params">            UpdateHelper updateHelper,</span></span></span><br><span class="line"><span class="function"><span class="params">            LongSupplier nowInMillisSupplier,</span></span></span><br><span class="line"><span class="function"><span class="params">            MappingUpdatePerformer mappingUpdater)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取索引元数据</span></span><br><span class="line">        <span class="keyword">final</span> IndexMetaData metaData = primary.indexSettings().getIndexMetaData();</span><br><span class="line">        Translog.Location location = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 遍历请求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> requestIndex = <span class="number">0</span>; requestIndex &lt; request.items().length; requestIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isAborted(request.items()[requestIndex].getPrimaryResponse()) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                <span class="comment">// 执行具体的写入请求</span></span><br><span class="line">                location = executeBulkItemRequest(metaData, primary, request, location, requestIndex,</span><br><span class="line">                    updateHelper, nowInMillisSupplier, mappingUpdater);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建响应</span></span><br><span class="line">        BulkItemResponse[] responses = <span class="keyword">new</span> BulkItemResponse[request.items().length];</span><br><span class="line">        BulkItemRequest[] items = request.items();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            responses[i] = items[i].getPrimaryResponse();</span><br><span class="line">        &#125;</span><br><span class="line">        BulkShardResponse response = <span class="keyword">new</span> BulkShardResponse(request.shardId(), responses);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WritePrimaryResult&lt;&gt;(request, response, location, <span class="keyword">null</span>, primary, logger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于方法调用栈比较深，省略中间方法，直接看InternalEngine的index方法，省略的流程如下：</p>
<p>executeBulkItemRequest（TransportShardBulkAction）—&gt;<br>executeIndexRequest（TransportShardBulkAction）—&gt;<br>executeIndexRequestOnPrimary（TransportShardBulkAction）—&gt;<br>applyIndexOperationOnPrimary（IndexShard）—&gt;<br>applyIndexOperation（IndexShard）—&gt;<br>index（IndexShard）—&gt;<br>index（InternalEngine）</p>
<p><strong>InternalEngine</strong></p>
<p>InternalEngine的index方法将数据写入Luence，之后将写入操作添加到translog:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalEngine</span> <span class="keyword">extends</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IndexResult <span class="title">index</span><span class="params">(Index index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> Objects.equals(index.uid().field(), uidField) : index.uid().field();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> doThrottle = index.origin().isRecovery() == <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> (ReleasableLock releasableLock = readLock.acquire()) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="function"><span class="keyword">assert</span> <span class="title">assertIncomingSequenceNumber</span><span class="params">(index.origin()</span>, index.<span class="title">seqNo</span><span class="params">()</span>)</span>;</span><br><span class="line">            <span class="function"><span class="keyword">assert</span> <span class="title">assertVersionType</span><span class="params">(index)</span></span>;</span><br><span class="line">            <span class="keyword">try</span> (Releasable ignored = acquireLock(index.uid());</span><br><span class="line">            </span><br><span class="line">                ......</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">final</span> IndexResult indexResult;</span><br><span class="line">                <span class="keyword">if</span> (plan.earlyResultOnPreFlightError.isPresent()) &#123;</span><br><span class="line">                    indexResult = plan.earlyResultOnPreFlightError.get();</span><br><span class="line">                    <span class="keyword">assert</span> indexResult.hasFailure();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plan.indexIntoLucene) &#123;</span><br><span class="line">                    <span class="comment">// 调用Lucene的写入接口将文档写入Lucene</span></span><br><span class="line">                    indexResult = indexIntoLucene(index, plan);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    indexResult = <span class="keyword">new</span> IndexResult(</span><br><span class="line">                            plan.versionForIndexing, plan.seqNoForIndexing, plan.currentNotFoundOrDeleted);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (index.origin() != Operation.Origin.LOCAL_TRANSLOG_RECOVERY) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Translog.Location location;</span><br><span class="line">                    <span class="keyword">if</span> (indexResult.hasFailure() == <span class="keyword">false</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将整个写入操作加入到translog</span></span><br><span class="line">                        location = translog.add(<span class="keyword">new</span> Translog.Index(index, indexResult));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (indexResult.getSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO) &#123;</span><br><span class="line">                        location = translog.add(<span class="keyword">new</span> Translog.NoOp(indexResult.getSeqNo(), index.primaryTerm(), indexResult.getFailure().getMessage()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        location = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    indexResult.setTranslogLocation(location);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> indexResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                maybeFailEngine(<span class="string">"index"</span>, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception inner) &#123;</span><br><span class="line">                e.addSuppressed(inner);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GlobalCheckpointSyncAction</strong></p>
<p>GlobalCheckpointSyncAction的maybeSyncTranslog方法进行刷盘控制：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalCheckpointSyncAction</span> <span class="keyword">extends</span> <span class="title">TransportReplicationAction</span>&lt;</span></span><br><span class="line"><span class="class">        <span class="title">GlobalCheckpointSyncAction</span>.<span class="title">Request</span>,</span></span><br><span class="line"><span class="class">        <span class="title">GlobalCheckpointSyncAction</span>.<span class="title">Request</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ReplicationResponse</span>&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeSyncTranslog</span><span class="params">(<span class="keyword">final</span> IndexShard indexShard)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Translog translog = indexShard.getTranslog();</span><br><span class="line">        <span class="keyword">if</span> (indexShard.getTranslogDurability() == Translog.Durability.REQUEST &amp;&amp;</span><br><span class="line">                translog.getLastSyncedGlobalCheckpoint() &lt; indexShard.getGlobalCheckpoint()) &#123;</span><br><span class="line">            indexShard.getTranslog().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="副本分片节点流程"><a href="#副本分片节点流程" class="headerlink" title="副本分片节点流程"></a>副本分片节点流程</h3><p>副本分片的写入流程与主分片基本相同，写入完毕后向主分片发送响应。</p>
<p><strong>参考：</strong></p>
<p>Elasticsearch源码解析与优化实战【张超】</p>
<p><a href="https://cloud.tencent.com/developer/article/1361160" target="_blank" rel="noopener">Elasticsearch源码分析-写入解析</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35285514" target="_blank" rel="noopener">Elasticsearch分布式一致性原理剖析(三)-Data篇</a></p>
<p><strong>Elasticsearch版本:6.1.2</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/【Spring】SpringMVC（三）：HandlerMapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/【Spring】SpringMVC（三）：HandlerMapping/" itemprop="url">SpringMVC（三）：HandlerMapping</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-22T21:31:00+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>继承关系图：<br><img src="/images/handler.png" alt=""> </p>
<p>HandlerMapping的作用是根据请求URL找到对应的Handler也就是Controller。</p>
<p>HandlerMapping是一个接口，在接口中定义了一个getHandler方法，通过这个方法可以获得与HTTP请求对应的HandlerExecutionChain,这个HandlerExecutionChain中封装了具体的Controller对象，还设置了一个拦截器链，通过这个拦截器链中的拦截器可以为Handler对象提供功能的增强。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</span><br><span class="line">    String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".pathWithinHandlerMapping"</span>;</span><br><span class="line">    String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".bestMatchingPattern"</span>;</span><br><span class="line">    String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + <span class="string">".introspectTypeLevelMapping"</span>;</span><br><span class="line">    String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".uriTemplateVariables"</span>;</span><br><span class="line">    String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".matrixVariables"</span>;</span><br><span class="line">    String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".producibleMediaTypes"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest var1)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一、Handler的注册"><a href="#一、Handler的注册" class="headerlink" title="一、Handler的注册"></a>一、Handler的注册</h3><h5 id="1-SimpleUrlHandlerMapping"><a href="#1-SimpleUrlHandlerMapping" class="headerlink" title="1.SimpleUrlHandlerMapping"></a>1.SimpleUrlHandlerMapping</h5><p>以SimpleUrlHandlerMapping为例，看一下Hanlder的注册过程。</p>
<p>（1）持有了一个urlMap字段，保存URL和Hanlder的映射关系。</p>
<p>（2）Hanlder的注册过程是在initApplicationContext方法中调用的。initApplicationContext方法中先调用了父类AbstractUrlHandlerMapping 的initApplicationContext方法，这个方法中主要是对拦截器相关的设置。然后调用了registerHandlers方法注册handler。</p>
<p>（3）在registerHandlers方法中，调用了父类AbstractUrlHandlerMapping的registerHandler方法对handler进行注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractUrlHandlerMapping</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存URL和Hanlder的映射关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; urlMap = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleUrlHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMappings</span><span class="params">(Properties mappings)</span> </span>&#123;</span><br><span class="line">        CollectionUtils.mergePropertiesIntoMap(mappings, <span class="keyword">this</span>.urlMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrlMap</span><span class="params">(Map&lt;String, ?&gt; urlMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.urlMap.putAll(urlMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, ?&gt; getUrlMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.urlMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化ApplicationContext</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用了AbstractHandlerMapping的initApplicationContext方法，这个方法主要初始化拦截器相关的东西</span></span><br><span class="line">        <span class="keyword">super</span>.initApplicationContext();</span><br><span class="line">        <span class="comment">// 注册handler</span></span><br><span class="line">        <span class="keyword">this</span>.registerHandlers(<span class="keyword">this</span>.urlMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册handler,建立URL和controller之间的映射关系</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlers</span><span class="params">(Map&lt;String, Object&gt; urlMap)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(urlMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.warn(<span class="string">"Neither 'urlMap' nor 'mappings' set on SimpleUrlHandlerMapping"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取所有的URL和对应的hanlder</span></span><br><span class="line">            urlMap.forEach((url, handler) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(!url.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">                    url = <span class="string">"/"</span> + url;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    handler = ((String)handler).trim();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 调用父类的registerHandler完成注册</span></span><br><span class="line">                <span class="keyword">this</span>.registerHandler(url, handler);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-AbstractUrlHandlerMapping"><a href="#2-AbstractUrlHandlerMapping" class="headerlink" title="2.AbstractUrlHandlerMapping"></a>2.AbstractUrlHandlerMapping</h5><p>（1）在AbstractUrlHandlerMapping中，同样持有了一个保存URL和Handler映射关系的字段handlerMap。</p>
<p>（2）在registerHandler方法中：</p>
<ul>
<li>首先设置一个变量resolvedHandler，将当前传入的handler赋给它；</li>
<li>接着判断是否根据bean名称进行映射，如果是将会直接从容器中获取Handler赋给resolvedHandler；</li>
<li>创建变量mappedHandler，表示是从handlerMap根据URL获取的Handler；如果mappedHandler不为空，会与从容器中根据bean获取的Handler对比是否一致,如果不一致将会报错。</li>
<li>如果mappedHandler为空，说明Handler还未注册，会判断URL是否是’/‘或者’/*’,并分别设置到ROOT或者DefaultHandler中，如果只是普通的URL，因为还没有注册Handler，就把resolvedHandler注册到handlerMap中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractHandlerMapping</span> <span class="keyword">implements</span> <span class="title">MatchableHandlerMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存URL和Handler的映射关系，key为URL，value为对应的Handler也就是Controller</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; handlerMap = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据url注册handler</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String[] urlPaths, String beanName)</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">        Assert.notNull(urlPaths, <span class="string">"URL path array must not be null"</span>);</span><br><span class="line">        String[] var3 = urlPaths;</span><br><span class="line">        <span class="keyword">int</span> var4 = urlPaths.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            String urlPath = var3[var5];</span><br><span class="line">            <span class="keyword">this</span>.registerHandler((String)urlPath, (Object)beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册handler</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String urlPath, Object handler)</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">        Assert.notNull(urlPath, <span class="string">"URL path must not be null"</span>);</span><br><span class="line">        Assert.notNull(handler, <span class="string">"Handler object must not be null"</span>);</span><br><span class="line">        Object resolvedHandler = handler;</span><br><span class="line">        <span class="comment">// 使用bean名称进行映射</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.lazyInitHandlers &amp;&amp; handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String handlerName = (String)handler;</span><br><span class="line">            ApplicationContext applicationContext = <span class="keyword">this</span>.obtainApplicationContext();</span><br><span class="line">            <span class="keyword">if</span>(applicationContext.isSingleton(handlerName)) &#123;</span><br><span class="line">                <span class="comment">// 直接从容器中获取hanldler的bean，也就是controller</span></span><br><span class="line">                resolvedHandler = applicationContext.getBean(handlerName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据URL获取controller</span></span><br><span class="line">        Object mappedHandler = <span class="keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line">        <span class="keyword">if</span>(mappedHandler != <span class="keyword">null</span>) &#123; <span class="comment">// 如果controller不为空</span></span><br><span class="line">            <span class="keyword">if</span>(mappedHandler != resolvedHandler) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot map "</span> + <span class="keyword">this</span>.getHandlerDescription(handler) + <span class="string">" to URL path ["</span> + urlPath + <span class="string">"]: There is already "</span> + <span class="keyword">this</span>.getHandlerDescription(mappedHandler) + <span class="string">" mapped."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(urlPath.equals(<span class="string">"/"</span>)) &#123;<span class="comment">// 如果url是"/"</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.info(<span class="string">"Root mapping to "</span> + <span class="keyword">this</span>.getHandlerDescription(handler));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将"/"映射的controller设置到rootHandler</span></span><br><span class="line">            <span class="keyword">this</span>.setRootHandler(resolvedHandler);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(urlPath.equals(<span class="string">"/*"</span>)) &#123; <span class="comment">// 如果是"/*"</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.info(<span class="string">"Default mapping to "</span> + <span class="keyword">this</span>.getHandlerDescription(handler));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将"/*"映射的controller设置到defaultHandler</span></span><br><span class="line">            <span class="keyword">this</span>.setDefaultHandler(resolvedHandler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理正常的URL映射，将当前传入设置handler的key和value，分别对应URL和映射的controller</span></span><br><span class="line">            <span class="keyword">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.info(<span class="string">"Mapped URL path ["</span> + urlPath + <span class="string">"] onto "</span> + <span class="keyword">this</span>.getHandlerDescription(handler));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、Handler的查找过程"><a href="#二、Handler的查找过程" class="headerlink" title="二、Handler的查找过程"></a>二、Handler的查找过程</h3><h5 id="1-DispatcherServlet"><a href="#1-DispatcherServlet" class="headerlink" title="1.DispatcherServlet"></a>1.DispatcherServlet</h5><p>回到DispatcherServlet，对HTTP请求的处理是在doService中完成的，那么就从这个方法入手，看一下DispatcherServlet是如何根据请求获取对应的Handler（Controller）处理HTTP请求的。</p>
<p>（1）在doService方法中会调用doDispatch方法，这里是分发请求的入口。</p>
<p>（2）在doDispatch方法中，调用了自己的getHandler根据请求获取对应的HandlerExecutionChain，在getHandler方法中遍历handlerMappings寻找对应的HandlerExecutionChain，具体的查找过程由子类实现，在子类的getHandler方法中完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据请求得到对应的HandlerExecutionChain</span></span><br><span class="line">mappedHandler = <span class="keyword">this</span>.getHandler(processedRequest);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 获取handler的方法</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//遍历handlerMappings</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Iterator var2 = <span class="keyword">this</span>.handlerMappings.iterator();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">               HandlerMapping hm = (HandlerMapping)var2.next();</span><br><span class="line">               <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.logger.trace(<span class="string">"Testing handler map ["</span> + hm + <span class="string">"] in DispatcherServlet with name '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//根据当前请求获取HandlerExecutionChain,这里的getHandler方法由子类实现</span></span><br><span class="line">               HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">               <span class="keyword">if</span>(handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> handler;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>（3）HandlerExecutionChain获取成功后，会调用getHandlerAdapter方法获取HandlerAdapter，最后由HandlerAdapter调用handle方法处理请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取HandlerAdapter</span></span><br><span class="line">HandlerAdapter ha = <span class="keyword">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<p>整体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult()?<span class="string">" resumed"</span>:<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"DispatcherServlet with name '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span> + resumed + <span class="string">" processing "</span> + request.getMethod() + <span class="string">" request for ["</span> + getRequestUri(request) + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">            attributesSnapshot = <span class="keyword">new</span> HashMap();</span><br><span class="line">            Enumeration attrNames = request.getAttributeNames();</span><br><span class="line"></span><br><span class="line">            label112:</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                String attrName;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!attrNames.hasMoreElements()) &#123;</span><br><span class="line">                        <span class="keyword">break</span> label112;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    attrName = (String)attrNames.nextElement();</span><br><span class="line">                &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.cleanupAfterInclude &amp;&amp; !attrName.startsWith(<span class="string">"org.springframework.web.servlet"</span>));</span><br><span class="line"></span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.getWebApplicationContext());</span><br><span class="line">        request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">        request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">        request.setAttribute(THEME_SOURCE_ATTRIBUTE, <span class="keyword">this</span>.getThemeSource());</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.flashMapManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">            <span class="keyword">if</span>(inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">            request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是分发请求的入口</span></span><br><span class="line">            <span class="keyword">this</span>.doDispatch(request, response);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() &amp;&amp; attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpServletRequest processedRequest = request;</span><br><span class="line">        HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 这个ModelAndView持有handler处理请求的结果</span></span><br><span class="line">                ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">                Object dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processedRequest = <span class="keyword">this</span>.checkMultipart(request);</span><br><span class="line">                    multipartRequestParsed = processedRequest != request;</span><br><span class="line">                    <span class="comment">// 根据请求得到对应的HandlerExecutionChain</span></span><br><span class="line">                    mappedHandler = <span class="keyword">this</span>.getHandler(processedRequest);</span><br><span class="line">                    <span class="keyword">if</span>(mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.noHandlerFound(processedRequest, response);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//获取HandlerAdapter</span></span><br><span class="line">                    HandlerAdapter ha = <span class="keyword">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">                    String method = request.getMethod();</span><br><span class="line">                    <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">                    <span class="keyword">if</span>(isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                        <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>((<span class="keyword">new</span> ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理请求</span></span><br><span class="line">                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">                    <span class="keyword">if</span>(asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var20) &#123;</span><br><span class="line">                    dispatchException = var20;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var21) &#123;</span><br><span class="line">                    dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, var21);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">                <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var23) &#123;</span><br><span class="line">                <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, var23));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(multipartRequestParsed) &#123;</span><br><span class="line">                <span class="keyword">this</span>.cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取handler的方法</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//遍历handlerMappings</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var2 = <span class="keyword">this</span>.handlerMappings.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                HandlerMapping hm = (HandlerMapping)var2.next();</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.trace(<span class="string">"Testing handler map ["</span> + hm + <span class="string">"] in DispatcherServlet with name '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据当前请求获取HandlerExecutionChain,这里的getHandler方法由子类实现</span></span><br><span class="line">                HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">                <span class="keyword">if</span>(handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> handler;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取HandlerAdapter</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.handlerAdapters != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var2 = <span class="keyword">this</span>.handlerAdapters.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                HandlerAdapter ha = (HandlerAdapter)var2.next();</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.trace(<span class="string">"Testing handler adapter ["</span> + ha + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ha.supports(handler)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ha;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler + <span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以SimpleControllerHandlerAdapter为例，看一下Adapter处理请求的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleControllerHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> Controller;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 处理HTTP请求</span></span><br><span class="line">        <span class="keyword">return</span> ((Controller)handler).handleRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> LastModified?((LastModified)handler).getLastModified(request):-<span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-AbstractHandlerMapping"><a href="#2-AbstractHandlerMapping" class="headerlink" title="2.AbstractHandlerMapping"></a>2.AbstractHandlerMapping</h5><p>在上一步中，getHandler获取HandlerExecutionChain的过程由子类实现的，同样以SimpleUrlHandlerMapping为例，由继承关系图可知AbstractHandlerMapping是SimpleUrlHandlerMapping的父类，getHandler是在父类中实现的，那么就从AbstractHandlerMapping入手看一下AbstractHandlerMapping中是如何获取HandlerExecutionChain的。</p>
<p>（1）在getHandler方法中，首先调用了getHandlerInternal方法，获取Handler，这个方法是在AbstractUrlHandlerMapping中实现的。</p>
<p>（2）Handler获取之后，将Handler封装到了HandlerExecutionChain中并返回,HandlerExecutionChain中包含了Controller的定义和一个拦截器链。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHandlerMapping</span> <span class="keyword">extends</span> <span class="title">WebApplicationObjectSupport</span> <span class="keyword">implements</span> <span class="title">HandlerMapping</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Handler</span></span><br><span class="line">        Object handler = <span class="keyword">this</span>.getHandlerInternal(request);</span><br><span class="line">        <span class="comment">// 使用默认的Handler</span></span><br><span class="line">        <span class="keyword">if</span>(handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handler = <span class="keyword">this</span>.getDefaultHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="comment">// 根据bean名称从容器中获取handler</span></span><br><span class="line">                String handlerName = (String)handler;</span><br><span class="line">                handler = <span class="keyword">this</span>.obtainApplicationContext().getBean(handlerName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把handler封装到HandlerExecutionChain中</span></span><br><span class="line">            HandlerExecutionChain executionChain = <span class="keyword">this</span>.getHandlerExecutionChain(handler, request);</span><br><span class="line">            <span class="keyword">if</span>(CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">                CorsConfiguration globalConfig = <span class="keyword">this</span>.globalCorsConfigSource.getCorsConfiguration(request);</span><br><span class="line">                CorsConfiguration handlerConfig = <span class="keyword">this</span>.getCorsConfiguration(handler, request);</span><br><span class="line">                CorsConfiguration config = globalConfig != <span class="keyword">null</span>?globalConfig.combine(handlerConfig):handlerConfig;</span><br><span class="line">                executionChain = <span class="keyword">this</span>.getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> executionChain;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取HandlerExecutionChain</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        HandlerExecutionChain chain = handler <span class="keyword">instanceof</span> HandlerExecutionChain?(HandlerExecutionChain)handler:<span class="keyword">new</span> HandlerExecutionChain(handler);</span><br><span class="line">        String lookupPath = <span class="keyword">this</span>.urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">        Iterator var5 = <span class="keyword">this</span>.adaptedInterceptors.iterator();</span><br><span class="line">        <span class="comment">// 添加拦截器</span></span><br><span class="line">        <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = (HandlerInterceptor)var5.next();</span><br><span class="line">            <span class="keyword">if</span>(interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">                MappedInterceptor mappedInterceptor = (MappedInterceptor)interceptor;</span><br><span class="line">                <span class="keyword">if</span>(mappedInterceptor.matches(lookupPath, <span class="keyword">this</span>.pathMatcher)) &#123;</span><br><span class="line">                    chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                chain.addInterceptor(interceptor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HandlerExecutionChain中的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(HandlerExecutionChain.class);</span><br><span class="line">    <span class="comment">// 处理请求的Controller</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-AbstractUrlHandlerMapping"><a href="#3-AbstractUrlHandlerMapping" class="headerlink" title="3.AbstractUrlHandlerMapping"></a>3.AbstractUrlHandlerMapping</h5><p>（1）在AbstractUrlHandlerMapping中的getHandlerInternal方法中调用了lookupHandler方查找当前请求对应的Handler。</p>
<p>（2）查找Handler之后判断是否为空，如果为空,判断当前请求是否是”/“,如果是就使用RootHandler，如果RootHandler也为空，就使用默认的Handler.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractHandlerMapping</span> <span class="keyword">implements</span> <span class="title">MatchableHandlerMapping</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Handler</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 从request中获取URL路径</span></span><br><span class="line">        String lookupPath = <span class="keyword">this</span>.getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">        <span class="comment">// 寻找URL对应的handler,如果没有找到，返回null</span></span><br><span class="line">        Object handler = <span class="keyword">this</span>.lookupHandler(lookupPath, request);</span><br><span class="line">        <span class="keyword">if</span>(handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object rawHandler = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 如果是 "/" </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"/"</span>.equals(lookupPath)) &#123;</span><br><span class="line">                rawHandler = <span class="keyword">this</span>.getRootHandler();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rawHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                rawHandler = <span class="keyword">this</span>.getDefaultHandler();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rawHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(rawHandler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    String handlerName = (String)rawHandler;</span><br><span class="line">                    rawHandler = <span class="keyword">this</span>.obtainApplicationContext().getBean(handlerName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 验证handler</span></span><br><span class="line">                <span class="keyword">this</span>.validateHandler(rawHandler, request);</span><br><span class="line">                handler = <span class="keyword">this</span>.buildPathExposingHandler(rawHandler, lookupPath, lookupPath, (Map)<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(handler != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Mapping ["</span> + lookupPath + <span class="string">"] to "</span> + handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(handler == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">"No handler mapping found for ["</span> + lookupPath + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据URL寻找Handler</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">lookupHandler</span><span class="params">(String urlPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 从map中获取handler</span></span><br><span class="line">        Object handler = <span class="keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line">        <span class="keyword">if</span>(handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果handler是bean名称，从容器中获取</span></span><br><span class="line">            <span class="keyword">if</span>(handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String handlerName = (String)handler;</span><br><span class="line">                handler = <span class="keyword">this</span>.obtainApplicationContext().getBean(handlerName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.validateHandler(handler, request);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.buildPathExposingHandler(handler, urlPath, urlPath, (Map)<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;String&gt; matchingPatterns = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            Iterator var5 = <span class="keyword">this</span>.handlerMap.keySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">                String registeredPattern = (String)var5.next();</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.getPathMatcher().match(registeredPattern, urlPath)) &#123;</span><br><span class="line">                    matchingPatterns.add(registeredPattern);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.useTrailingSlashMatch() &amp;&amp; !registeredPattern.endsWith(<span class="string">"/"</span>) &amp;&amp; <span class="keyword">this</span>.getPathMatcher().match(registeredPattern + <span class="string">"/"</span>, urlPath)) &#123;</span><br><span class="line">                    matchingPatterns.add(registeredPattern + <span class="string">"/"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String bestMatch = <span class="keyword">null</span>;</span><br><span class="line">            Comparator&lt;String&gt; patternComparator = <span class="keyword">this</span>.getPathMatcher().getPatternComparator(urlPath);</span><br><span class="line">            <span class="keyword">if</span>(!matchingPatterns.isEmpty()) &#123;</span><br><span class="line">                matchingPatterns.sort(patternComparator);</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">"Matching patterns for request ["</span> + urlPath + <span class="string">"] are "</span> + matchingPatterns);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bestMatch = (String)matchingPatterns.get(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(bestMatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                handler = <span class="keyword">this</span>.handlerMap.get(bestMatch);</span><br><span class="line">                <span class="keyword">if</span>(handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(bestMatch.endsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">                        handler = <span class="keyword">this</span>.handlerMap.get(bestMatch.substring(<span class="number">0</span>, bestMatch.length() - <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not find handler for best pattern match ["</span> + bestMatch + <span class="string">"]"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String pathWithinMapping;</span><br><span class="line">                <span class="keyword">if</span>(handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    pathWithinMapping = (String)handler;</span><br><span class="line">                    handler = <span class="keyword">this</span>.obtainApplicationContext().getBean(pathWithinMapping);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.validateHandler(handler, request);</span><br><span class="line">                pathWithinMapping = <span class="keyword">this</span>.getPathMatcher().extractPathWithinPattern(bestMatch, urlPath);</span><br><span class="line">                Map&lt;String, String&gt; uriTemplateVariables = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">                Iterator var9 = matchingPatterns.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var9.hasNext()) &#123;</span><br><span class="line">                    String matchingPattern = (String)var9.next();</span><br><span class="line">                    <span class="keyword">if</span>(patternComparator.compare(bestMatch, matchingPattern) == <span class="number">0</span>) &#123;</span><br><span class="line">                        Map&lt;String, String&gt; vars = <span class="keyword">this</span>.getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);</span><br><span class="line">                        Map&lt;String, String&gt; decodedVars = <span class="keyword">this</span>.getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">                        uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">"URI Template variables for request ["</span> + urlPath + <span class="string">"] are "</span> + uriTemplateVariables);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考：</strong></p>
<p>spring技术内幕:深入解析spring架构与设计原理</p>
<p><a href="https://www.jianshu.com/p/1fb717421d53" target="_blank" rel="noopener">SpringMvc的handlerMapping的源码解读</a></p>
<p><a href="https://www.cnblogs.com/tengyunhao/p/7658952.html" target="_blank" rel="noopener">SpringMVC工作原理之二：HandlerMapping和HandlerAdapter</a></p>
<p><strong>Spring版本:5.0.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/【Spring】SpringMVC（二）：DispatcherServlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/【Spring】SpringMVC（二）：DispatcherServlet/" itemprop="url">SpringMVC（二）：DispatcherServlet对SpringMVC的初始化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-21T22:50:00+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在SpringMVC项目中除了spring容器（根上下文），DispatcherServlet也会建立一个自己的IoC容器来持有springmvc的bean对象，在建立这个容器时，会从ServletContext中获取根上下文作为自己的双亲上下文，它可获取双亲上下文中的bean，DispatcherServlet的IoC容器也会存到ServletContext中。</p>
<p>DispatcherServlet是一个servlet，回想servlet的生命周期，servlet在初始化的时候调用的是init方法，那么就从init方法开始看一下DispatcherServlet对SpringMVC的初始化。</p>
<p>继承关系图：</p>
<p><img src="/images/dispatchersevlet.png" alt=""> </p>
<h4 id="1-HttpServletBean"><a href="#1-HttpServletBean" class="headerlink" title="1.HttpServletBean"></a>1.HttpServletBean</h4><p>HttpServletBean是DispatcherServlet的父类，init方法是在HttpServletBean中实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServletBean</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Initializing servlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取servlet初始化参数</span></span><br><span class="line">        PropertyValues pvs = <span class="keyword">new</span> HttpServletBean.ServletConfigPropertyValues(<span class="keyword">this</span>.getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">        <span class="keyword">if</span>(!pvs.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">                ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(<span class="keyword">this</span>.getServletContext());</span><br><span class="line">                bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, <span class="keyword">this</span>.getEnvironment()));</span><br><span class="line">                <span class="keyword">this</span>.initBeanWrapper(bw);</span><br><span class="line">                bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException var4) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isErrorEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span>, var4);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> var4;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化，在FrameworkServlet中实现</span></span><br><span class="line">        <span class="keyword">this</span>.initServletBean();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Servlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HttpServletBean除了获取servlet初始化参数，还调用了initServletBean方法，进行具体的初始化，这个方法是在FrameworkServlet中实现的。</p>
<h4 id="2-FrameworkServlet"><a href="#2-FrameworkServlet" class="headerlink" title="2.FrameworkServlet"></a>2.FrameworkServlet</h4><p>FrameworkServlet同样是DispatcherServlet的父类。</p>
<p><strong>DispatcherServlet的IoC容器的初始化</strong></p>
<p>在initServletBean方法中，调用了initWebApplicationContext方法来初始化IoC容器，在初始化容器的方法中:</p>
<ol>
<li><p>首先从ServletContext中获取了根上下文,然后判断DispatcherServlet的容器wac是否为空,如果不为空就将根上下文设置为双亲上下文，然后调用configureAndRefreshWebApplicationContext方法，完成容器的初始化。</p>
</li>
<li><p>如果容器为空，就调用createWebApplicationContext创建容器，默认使用的是XmlWebApplicationContext,创建容器的时候将根上下文作为参数传入，创建之后同样将根上下文设置为双亲上下文。</p>
</li>
<li><p>DispatcherServlet的容器也会被设置到SerletContext中，使用的属性名是和<br>当前Servlet的名称。</p>
</li>
<li><p>在createWebApplicationContext创建容器的方法中，最后调用了configureAndRefreshWebApplicationContext方法，在该方法中调用了容器的refresh方法，之后就与spring IoC容器的初始化过程一致了。</p>
</li>
</ol>
<p>之后，SpringMVC的上下文就建立起来了，意味着DispatcheServlet拥有自己的Bean定义空间，为使用各个独立的XML文件来配置MVC中的各个bean创建了条件。</p>
<p><strong>SpringMVC的初始化</strong></p>
<p>在initWebApplicationContext方法中，在容器创建完成后，有一步是调用this.onRefresh方法，这个方法是在DispatcherSerlet中实现的，在该方法中完成了SpringMVC的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameworkServlet</span> <span class="keyword">extends</span> <span class="title">HttpServletBean</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"': initialization started"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化容器</span></span><br><span class="line">            <span class="keyword">this</span>.webApplicationContext = <span class="keyword">this</span>.initWebApplicationContext();</span><br><span class="line">            <span class="keyword">this</span>.initFrameworkServlet();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | ServletException var5) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, var5);</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">            <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">            <span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"': initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化容器</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取根上下文</span></span><br><span class="line">        WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(<span class="keyword">this</span>.getServletContext());</span><br><span class="line">        <span class="comment">// DispatchServlet的容器</span></span><br><span class="line">        WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果不为空</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">            <span class="keyword">if</span>(wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">                ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext)wac;</span><br><span class="line">                <span class="keyword">if</span>(!cwac.isActive()) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将根上下文设置为当前容器的双亲</span></span><br><span class="line">                        cwac.setParent(rootContext);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">            wac = <span class="keyword">this</span>.findWebApplicationContext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果dispatchServlet的容器为空，创建容器</span></span><br><span class="line">            wac = <span class="keyword">this</span>.createWebApplicationContext(rootContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">            <span class="comment">// 在DispatcherServlet中实现了该方法，完成springMVC的初始化</span></span><br><span class="line">            <span class="keyword">this</span>.onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">            String attrName = <span class="keyword">this</span>.getServletContextAttributeName();</span><br><span class="line">            <span class="comment">// 将创建好的容器设置到ServletContext</span></span><br><span class="line">            <span class="keyword">this</span>.getServletContext().setAttribute(attrName, wac);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Published WebApplicationContext of servlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"' as ServletContext attribute with name ["</span> + attrName + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wac;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(@Nullable WebApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createWebApplicationContext((ApplicationContext)parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建容器</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取ContextClass</span></span><br><span class="line">        Class&lt;?&gt; contextClass = <span class="keyword">this</span>.getContextClass();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Servlet with name '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"' will try to create custom WebApplicationContext context of class '"</span> + contextClass.getName() + <span class="string">"', using parent context ["</span> + parent + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Fatal initialization error in servlet with name '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"': custom WebApplicationContext class ["</span> + contextClass.getName() + <span class="string">"] is not of type ConfigurableWebApplicationContext"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//创建容器,默认使用的是XmlWebApplicationContext</span></span><br><span class="line">            ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext)BeanUtils.instantiateClass(contextClass);</span><br><span class="line">            wac.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">            <span class="comment">// 这里同样将根上下文作为当前容器的双亲上下文</span></span><br><span class="line">            wac.setParent(parent);</span><br><span class="line">            String configLocation = <span class="keyword">this</span>.getContextConfigLocation();</span><br><span class="line">            <span class="keyword">if</span>(configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wac.setConfigLocation(configLocation);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 配置并刷新容器</span></span><br><span class="line">            <span class="keyword">this</span>.configureAndRefreshWebApplicationContext(wac);</span><br><span class="line">            <span class="keyword">return</span> wac;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置并初始化容器</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.contextId != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wac.setId(<span class="keyword">this</span>.contextId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(<span class="keyword">this</span>.getServletContext().getContextPath()) + <span class="string">'/'</span> + <span class="keyword">this</span>.getServletName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置ServletContext</span></span><br><span class="line">        wac.setServletContext(<span class="keyword">this</span>.getServletContext());</span><br><span class="line">        wac.setServletConfig(<span class="keyword">this</span>.getServletConfig());</span><br><span class="line">        wac.setNamespace(<span class="keyword">this</span>.getNamespace());</span><br><span class="line">        wac.addApplicationListener(<span class="keyword">new</span> SourceFilteringListener(wac, <span class="keyword">new</span> FrameworkServlet.ContextRefreshListener(<span class="keyword">null</span>)));</span><br><span class="line">        ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line">        <span class="keyword">if</span>(env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">            ((ConfigurableWebEnvironment)env).initPropertySources(<span class="keyword">this</span>.getServletContext(), <span class="keyword">this</span>.getServletConfig());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.postProcessWebApplicationContext(wac);</span><br><span class="line">        <span class="keyword">this</span>.applyInitializers(wac);</span><br><span class="line">        <span class="comment">// 调用容器的refresh方法</span></span><br><span class="line">        wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="WebApplicationContextUtils"><a href="#WebApplicationContextUtils" class="headerlink" title="WebApplicationContextUtils"></a>WebApplicationContextUtils</h5><p>取得根上下文的过程是在WebApplicationContextUtils中实现的。在getWebApplicationContext方法中，先调用WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE获取根上下文在ServletContext中的属性名，然后从ServletContext中获取根上下文，转换为WebApplicationContext返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebApplicationContextUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jsfPresent = ClassUtils.isPresent(<span class="string">"javax.faces.context.FacesContext"</span>, RequestContextHolder.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebApplicationContextUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取根上下文</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WebApplicationContext <span class="title">getRequiredWebApplicationContext</span><span class="params">(ServletContext sc)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取根上下文</span></span><br><span class="line">        WebApplicationContext wac = getWebApplicationContext(sc);</span><br><span class="line">        <span class="keyword">if</span>(wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No WebApplicationContext found: no ContextLoaderListener registered?"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> wac;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WebApplicationContext <span class="title">getWebApplicationContext</span><span class="params">(ServletContext sc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从servlet中获取根上下文</span></span><br><span class="line">        <span class="keyword">return</span> getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WebApplicationContext <span class="title">getWebApplicationContext</span><span class="params">(ServletContext sc, String attrName)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(sc, <span class="string">"ServletContext must not be null"</span>);</span><br><span class="line">        <span class="comment">// 从servlet中根据属性名获取根上下文</span></span><br><span class="line">        Object attr = sc.getAttribute(attrName);</span><br><span class="line">        <span class="keyword">if</span>(attr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(attr <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException)attr;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(attr <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error)attr;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(attr <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException((Exception)attr);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!(attr <span class="keyword">instanceof</span> WebApplicationContext)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Context attribute is not of type WebApplicationContext: "</span> + attr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回根上下文</span></span><br><span class="line">            <span class="keyword">return</span> (WebApplicationContext)attr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-DispatcherServlet"><a href="#3-DispatcherServlet" class="headerlink" title="3.DispatcherServlet"></a>3.DispatcherServlet</h4><p>在FrameworkServlet的configureAndRefreshWebApplicationContext方法中，最后一步是调用onRefresh方法，这个方法是在DispatchServlet中实现的。</p>
<p>在onRefresh方法中，调用了initStrategies方法，这个方法中启动了SpringMVC框架的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initStrategies(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initMultipartResolver(context);</span><br><span class="line">        <span class="keyword">this</span>.initLocaleResolver(context);</span><br><span class="line">        <span class="keyword">this</span>.initThemeResolver(context);</span><br><span class="line">        <span class="comment">// 初始化HanlderMappings</span></span><br><span class="line">        <span class="keyword">this</span>.initHandlerMappings(context);</span><br><span class="line">        <span class="keyword">this</span>.initHandlerAdapters(context);</span><br><span class="line">        <span class="keyword">this</span>.initHandlerExceptionResolvers(context);</span><br><span class="line">        <span class="keyword">this</span>.initRequestToViewNameTranslator(context);</span><br><span class="line">        <span class="keyword">this</span>.initViewResolvers(context);</span><br><span class="line">        <span class="keyword">this</span>.initFlashMapManager(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以HandlerMapping为例，HandlerMapping是为HTTP请求寻找对应的Controller控制器，在HandlerMapping初始化过程中，从IoC容器中获取在配置文件中配置好的,以HandlerMapping为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 导入所有的HandlerMapping Bean，默认从所有的容器中获取        </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">        Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(!matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList(matchingBeans.values());</span><br><span class="line">            AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据名称从当前的容器中获取</span></span><br><span class="line">            HandlerMapping hm = (HandlerMapping)context.getBean(<span class="string">"handlerMapping"</span>, HandlerMapping.class);</span><br><span class="line">            <span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException var3) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有找到handlerMapping,设置默认的handlerMapping</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handlerMappings = <span class="keyword">this</span>.getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"No HandlerMappings found in servlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"': using default"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考：</strong></p>
<p>spring技术内幕:深入解析spring架构与设计原理</p>
<p><strong>Spring版本:5.0.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/16/【Spring】SpringMVC（一）：Web环境中的IoC容器启动过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/16/【Spring】SpringMVC（一）：Web环境中的IoC容器启动过程/" itemprop="url">SpringMVC（一）：Web环境中的IoC容器启动过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-16T15:33:00+08:00">
                2018-12-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在springmvc项目中，可以有多个容器，而且容器有上下层关系，此处的容器指的是spring容器，它是springmvc的父容器，springmvc容器将在下一章讲解。</p>
<h4 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a>WebApplicationContext</h4><p>web环境下spring默认使用的是WebApplicationContext，它是一个接口，看一下WebApplicationContext的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于在ServletContext取根上下文</span></span><br><span class="line">    String ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + <span class="string">".ROOT"</span>;</span><br><span class="line">    String SCOPE_REQUEST = <span class="string">"request"</span>;</span><br><span class="line">    String SCOPE_SESSION = <span class="string">"session"</span>;</span><br><span class="line">    String SCOPE_APPLICATION = <span class="string">"application"</span>;</span><br><span class="line">    String SERVLET_CONTEXT_BEAN_NAME = <span class="string">"servletContext"</span>;</span><br><span class="line">    String CONTEXT_PARAMETERS_BEAN_NAME = <span class="string">"contextParameters"</span>;</span><br><span class="line">    String CONTEXT_ATTRIBUTES_BEAN_NAME = <span class="string">"contextAttributes"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取ServletContext</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）WebApplicationContext接口本身中的内容并不多，可以看到它继承了ApplicationContext，有一个ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE成员变量，这个变量用于将IoC容器设置到ServletContext时的key，之后就可以从ServletContext中获取IoC容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servletContext.setAttribute(WebApplicationConservletContexttext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br></pre></td></tr></table></figure>
<p>（2）既然WebApplicationContext只是一个接口，那么一定有一个它的实现类，作为IoC容器的实现，这个类就是XmlWebApplicationContext。</p>
<h4 id="XmlWebApplicationContext"><a href="#XmlWebApplicationContext" class="headerlink" title="XmlWebApplicationContext"></a>XmlWebApplicationContext</h4><p>Spring使用XmlWebApplicationContext作为默认的WebApplicationContext容器实现，从继承关系中可以看到，XmlWebApplicationContext继承了WebApplicationContext,其实从名字上就可以看出，XmlWebApplicationContext也是ApplicationContext容器的实现，在ApplicationContext的基础之上，增加了对Web环境和XML配置定义的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlWebApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractRefreshableWebApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认的配置文件applicationContext.xml,在WEB-INF目录下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONFIG_LOCATION = <span class="string">"/WEB-INF/applicationContext.xml"</span>;</span><br><span class="line">    <span class="comment">// web项目的WEB-INF目录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONFIG_LOCATION_PREFIX = <span class="string">"/WEB-INF/"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONFIG_LOCATION_SUFFIX = <span class="string">".xml"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载BeanDefinition的方法，在容器refresh()时启动</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//  XmlBeanDefinitionReader对象，解析xml文件使用</span></span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">        <span class="comment">// 设置ResourceLoader，XmlWebApplicationContext是DefaultResource的子类，同样使用DefaultResourceLoader对资源文件定位</span></span><br><span class="line">        beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">        beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">this</span>.initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">        <span class="comment">// 载入BeanDefinition</span></span><br><span class="line">        <span class="keyword">this</span>.loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanDefinitionReader</span><span class="params">(XmlBeanDefinitionReader beanDefinitionReader)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取资源文件的地址</span></span><br><span class="line">        String[] configLocations = <span class="keyword">this</span>.getConfigLocations();</span><br><span class="line">        <span class="keyword">if</span>(configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String[] var3 = configLocations;</span><br><span class="line">            <span class="keyword">int</span> var4 = configLocations.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">                String configLocation = var3[var5];</span><br><span class="line">                <span class="comment">// 根据资源文件的地址由XmlBeanDefinitionReader解析文件并载入BeanDefinition</span></span><br><span class="line">                reader.loadBeanDefinitions(configLocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取默认的配置</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getDefaultConfigLocations() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getNamespace() != <span class="keyword">null</span>?<span class="keyword">new</span> String[]&#123;<span class="string">"/WEB-INF/"</span> + <span class="keyword">this</span>.getNamespace() + <span class="string">".xml"</span>&#125;:<span class="keyword">new</span> String[]&#123;<span class="string">"/WEB-INF/applicationContext.xml"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从XmlWebApplicationContext的启动过程来看，与IoC容器的初始化过程基本差不多，只不过在Web环境中，已经定义好了一个默认的配置文件，即WEB-INF/appicationContext.xml，下面看一下如何进入到XmlWebApplicationContext的loadBeanDefinitions方法中的。</p>
<h4 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h4><p>ContextLoaderListener是Web容器中配置的监听器，WebApplicationContext容器的载入就是它负责的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化WebApplicationContext，具体的工作在ContextLoader中完成</span></span><br><span class="line">        <span class="keyword">this</span>.initWebApplicationContext(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 销毁WebApplicationContext</span></span><br><span class="line">        <span class="keyword">this</span>.closeWebApplicationContext(event.getServletContext());</span><br><span class="line">        ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ContextLoaderListener的contextInitialized方法中调用了initWebApplicationContext方法初始化web容器，该方法是在它的父类ContextLoader中实现的。</p>
<h4 id="ContextLoader"><a href="#ContextLoader" class="headerlink" title="ContextLoader"></a>ContextLoader</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Web IoC容器，也称作根上下文</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext context;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断根上下文是否已经存在</span></span><br><span class="line">        <span class="keyword">if</span>(servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot initialize context because there is already a root application context present - check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log logger = LogFactory.getLog(ContextLoader.class);</span><br><span class="line">            servletContext.log(<span class="string">"Initializing Spring root WebApplicationContext"</span>);</span><br><span class="line">            <span class="keyword">if</span>(logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Root WebApplicationContext: initialization started"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建容器WebApplicationContext</span></span><br><span class="line">                    <span class="keyword">this</span>.context = <span class="keyword">this</span>.createWebApplicationContext(servletContext);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果容器是ConfigurableWebApplicationContext的一个实现</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">                    ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext)<span class="keyword">this</span>.context;</span><br><span class="line">                    <span class="keyword">if</span>(!cwac.isActive()) &#123;</span><br><span class="line">                        <span class="comment">// 如果双亲为空</span></span><br><span class="line">                        <span class="keyword">if</span>(cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 加载根上下文的双亲上下文</span></span><br><span class="line">                            ApplicationContext parent = <span class="keyword">this</span>.loadParentContext(servletContext);</span><br><span class="line">                            cwac.setParent(parent);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 配置并refresh根上下文</span></span><br><span class="line">                        <span class="keyword">this</span>.configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前创建的web IoC容器context设置为servletContext的根上下文</span></span><br><span class="line">                servletContext.setAttribute(WebApplicationConservletContexttext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line">                ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">                <span class="keyword">if</span>(ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">                    currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Published root WebApplicationContext as ServletContext attribute with name ["</span> + WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(logger.isInfoEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">                    logger.info(<span class="string">"Root WebApplicationContext: initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException var8) &#123;</span><br><span class="line">                logger.error(<span class="string">"Context initialization failed"</span>, var8);</span><br><span class="line">                servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, var8);</span><br><span class="line">                <span class="keyword">throw</span> var8;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Error var9) &#123;</span><br><span class="line">                logger.error(<span class="string">"Context initialization failed"</span>, var9);</span><br><span class="line">                servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, var9);</span><br><span class="line">                <span class="keyword">throw</span> var9;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建web容器的地方</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(ServletContext sc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断使用什么样的类作为Web环境中的IoC容器</span></span><br><span class="line">        Class&lt;?&gt; contextClass = <span class="keyword">this</span>.determineContextClass(sc);</span><br><span class="line">        <span class="keyword">if</span>(!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Custom context class ["</span> + contextClass.getName() + <span class="string">"] is not of type ["</span> + ConfigurableWebApplicationContext.class.getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据类信息实例化web IoC容器</span></span><br><span class="line">            <span class="keyword">return</span> (ConfigurableWebApplicationContext)BeanUtils.instantiateClass(contextClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断使用哪种web容器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class="line">        <span class="comment">// 读取在ServletContext中对contextClass参数的配置</span></span><br><span class="line">        String contextClassName = servletContext.getInitParameter(<span class="string">"contextClass"</span>);</span><br><span class="line">        <span class="comment">// 如果在ServletContext中对contextClass参数配置不为空</span></span><br><span class="line">        <span class="keyword">if</span>(contextClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 返回类信息</span></span><br><span class="line">                <span class="keyword">return</span> ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var4) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Failed to load custom context class ["</span> + contextClassName + <span class="string">"]"</span>, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果配置信息为空，使用默认的WebApplicationContext</span></span><br><span class="line">            contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Failed to load default context class ["</span> + contextClassName + <span class="string">"]"</span>, var5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置并refresh，这个方法中调用了容器的refresh方法来完成Web环境下IoC容器的初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac, ServletContext sc)</span> </span>&#123;</span><br><span class="line">        String configLocationParam;</span><br><span class="line">        <span class="keyword">if</span>(ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">            configLocationParam = sc.getInitParameter(<span class="string">"contextId"</span>);</span><br><span class="line">            <span class="keyword">if</span>(configLocationParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wac.setId(configLocationParam);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为容器设置ServletContext</span></span><br><span class="line">        wac.setServletContext(sc);</span><br><span class="line">        configLocationParam = sc.getInitParameter(<span class="string">"contextConfigLocation"</span>);</span><br><span class="line">        <span class="keyword">if</span>(configLocationParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wac.setConfigLocation(configLocationParam);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line">        <span class="keyword">if</span>(env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">            ((ConfigurableWebEnvironment)env).initPropertySources(sc, (ServletConfig)<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.customizeContext(sc, wac);</span><br><span class="line">        <span class="comment">// 调用容器的refresh方法，完成容器的初始化</span></span><br><span class="line">        wac.refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>在ContextLoader类中，存在一个WebApplicationContext类型的字段context, 这个变量就是Web环境中的IoC容器，也会配置在ServletContext的根上下文中，ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE为属性名，已经在WebApplication中定义为了一个常量。</p>
</li>
<li><p>initWebApplicationContext方法，是启动IoC容器的入口：</p>
<p> （1）如果容器还没有创建，会调用createWebApplicationContext方法创建IoC容器，在该方法中，会调用determineContextClass方法判断使用哪种IoC容器，如果没有设置contextClass参数，就使用默认的容器即WebApplicationContext。</p>
<p> （2）接着会判断创建的容器是否是ConfigurableWebApplicationContext的实例，如果是，将设置双亲上下文，并调用configureAndRefreshWebApplicationContext方法，将当前的serveltContext设置到Ioc容器中，最后调用容器的<strong>refresh()</strong>方法，完成容器的初始化。</p>
<p> （3）最后会把容器设置到ServletContext的根上下文中，并将容器返回。</p>
</li>
</ol>
<h4 id="AbstractApplicationContext"><a href="#AbstractApplicationContext" class="headerlink" title="AbstractApplicationContext"></a>AbstractApplicationContext</h4><p> 再回顾一下XmlWebApplicationContext的继承关系，它继承了AbstractRefreshableApplicationContext,AbstractRefreshableApplicationContext又继承了AbstractApplicationContext方法，refresh方法就是在AbstractApplicationContext实现的，之后的流程就和IoC容器启动过程一样了。</p>
<p> AbstractApplicationContext中的refresh()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">        Object var1 = <span class="keyword">this</span>.startupShutdownMonitor;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">            <span class="comment">// 调用AbstractRefreshableApplicationContext的prepareBeanFactory方法</span></span><br><span class="line">            <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">                <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">                <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">                <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">                <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">                <span class="keyword">this</span>.onRefresh();</span><br><span class="line">                <span class="keyword">this</span>.registerListeners();</span><br><span class="line">                <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">                <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">                <span class="keyword">this</span>.cancelRefresh(var9);</span><br><span class="line">                <span class="keyword">throw</span> var9;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractRefreshableApplicationContext"><a href="#AbstractRefreshableApplicationContext" class="headerlink" title="AbstractRefreshableApplicationContext"></a>AbstractRefreshableApplicationContext</h4><p> refresh方法中调用了调用AbstractRefreshableApplicationContext的prepareBeanFactory方法，在该方法中对BeanDefinition进行了载入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRefreshableApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.hasBeanFactory()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">            <span class="keyword">this</span>.closeBeanFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DefaultListableBeanFactory beanFactory = <span class="keyword">this</span>.createBeanFactory();</span><br><span class="line">            beanFactory.setSerializationId(<span class="keyword">this</span>.getId());</span><br><span class="line">            <span class="keyword">this</span>.customizeBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// 载入BeanDefinition</span></span><br><span class="line">            <span class="keyword">this</span>.loadBeanDefinitions(beanFactory);</span><br><span class="line">            Object var2 = <span class="keyword">this</span>.beanFactoryMonitor;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + <span class="keyword">this</span>.getDisplayName(), var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，如何进入到XmlWebApplicationContext的loadBeanDefinitions方法中的过程已经很明了了。</p>
<p><strong>参考：</strong></p>
<p>spring技术内幕:深入解析spring架构与设计原理</p>
<p><a href="https://www.cnblogs.com/hafiz/p/5875740.html" target="_blank" rel="noopener">Spring和SpringMVC父子容器关系初窥</a></p>
<p><strong>Spring版本:5.0.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/08/【Spring】AOP原理（二）：AopProxy拦截机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/08/【Spring】AOP原理（二）：AopProxy拦截机制/" itemprop="url">AOP原理（二）：AopProxy拦截机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-08T11:33:59+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以JDK动态代理为例，看一下Aop代理的拦截机制：</p>
<h4 id="JdkDynamicAopProxy的invoke拦截"><a href="#JdkDynamicAopProxy的invoke拦截" class="headerlink" title="JdkDynamicAopProxy的invoke拦截"></a>JdkDynamicAopProxy的invoke拦截</h4><p>使用JDK动态代理生成代理对象时，需要传入三个参数，分别是目标对象的类加载器loader、目标对象的接口interfaces、一个InvocationHandler对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure></p>
<p>InvocationHandler是一个接口，定义了一个invoke方法，对目标对象方法调用的拦截就是在invoke方法中实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="JdkDynamicAopProxy"><a href="#JdkDynamicAopProxy" class="headerlink" title="JdkDynamicAopProxy"></a>JdkDynamicAopProxy</h4><p><strong>1.拦截器链的调用</strong></p>
<p>JdkDynamicAopProxy实现了InvocationHandler接口，因此生成代理对象时，可以将自身作为参数传入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">		&#125;</span><br><span class="line">		Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">		findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">		<span class="comment">//使用JDK动态代理生成代理对象</span></span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * InvocationHandler接口invoke方法的实现</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		MethodInvocation invocation;</span><br><span class="line">		Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">		Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">				<span class="comment">// 如果目标对象没有实现Object的equals方法</span></span><br><span class="line">				<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">				<span class="comment">// 目标对象没有实现hashcode方法</span></span><br><span class="line">				<span class="keyword">return</span> hashCode();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">				<span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line">				<span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">					method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">				<span class="comment">//根据代理对象的配置来调用服务</span></span><br><span class="line">				<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Object retVal;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">				<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">				oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">				setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取目标对象</span></span><br><span class="line">			target = targetSource.getTarget();</span><br><span class="line">			Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取该方法的拦截器链</span></span><br><span class="line">			List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果没有拦截器，直接调用目标对象的方法</span></span><br><span class="line">			<span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">				Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">			    <span class="comment">//创建一个ReflectiveMethodInvocation对象，调用拦截器之后再调用目标对象的方法</span></span><br><span class="line">				invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">				<span class="comment">// 沿着拦截器链继续前进</span></span><br><span class="line">				retVal = invocation.proceed();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 处理方法返回值</span></span><br><span class="line">			Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">			<span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">					returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">					!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">				retVal = proxy;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">						<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> retVal;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">				<span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">				targetSource.releaseTarget(target);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">				<span class="comment">// Restore old proxy.</span></span><br><span class="line">				AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）在invoke方法中，如果没有配置拦截器，将会通过AopUtils的invokeJoinpointUsingReflection方法，使用反射机制对目标对象的方法进行调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AopUtils</span>  </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过反射执行目标对象的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">invokeJoinpointUsingReflection</span><span class="params">(@Nullable Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用反射机制调用目标对象的方法</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ReflectionUtils.makeAccessible(method);</span><br><span class="line">			<span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">			<span class="comment">// Invoked method threw a checked exception.</span></span><br><span class="line">			<span class="comment">// We must rethrow it. The client won't see the interceptor.</span></span><br><span class="line">			<span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"AOP configuration seems to be invalid: tried calling method ["</span> +</span><br><span class="line">					method + <span class="string">"] on target ["</span> + target + <span class="string">"]"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Could not access method ["</span> + method + <span class="string">"]"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）如果配置了拦截器，会获创建一个ReflectiveMethodInvocation对象，通过ReflectiveMethodInvocation对象的proceed方法逐个运行拦截器的拦截方法，从而完成整个拦截器链的调用。当拦截器链执行完毕后，同样使用反射机制执行目标对象中的方法。<br>在运行拦截器的拦截方法之前，会进行动态匹配判断，判断是否和定义的pointcut匹配，如果匹配就会执行这个advice。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveMethodInvocation</span> <span class="keyword">implements</span> <span class="title">ProxyMethodInvocation</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//	如果拦截器链调用完毕</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">		    <span class="comment">//这里依旧使用AopUtils的invokeJoinpointUsingReflection方法使用反射机制完成目标对象方法的调用</span></span><br><span class="line">			<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取定义的拦截器</span></span><br><span class="line">		Object interceptorOrInterceptionAdvice =</span><br><span class="line">				<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">		<span class="comment">//如果是InterceptorAndDynamicMethodMatcher的实例</span></span><br><span class="line">		<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">			</span><br><span class="line">			InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">					(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">			<span class="comment">// 对拦截器进行动态匹配判断，如果和定义的切点匹配，将会执行这个advice</span></span><br><span class="line">			<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">			    <span class="comment">//执行拦截器的方法</span></span><br><span class="line">				<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//如果未匹配，继续拦截器链中的下一个拦截器</span></span><br><span class="line">				<span class="keyword">return</span> proceed();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果是一个拦截器，直接调用该拦截器对应的方法</span></span><br><span class="line">			<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 调用目标对象的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">invokeJoinpoint</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	    <span class="comment">//同样使用反射执行方法</span></span><br><span class="line">		<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.target, <span class="keyword">this</span>.method, <span class="keyword">this</span>.arguments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.配置通知器</strong></p>
<p>回到JdkDynamicAopProxy的ivoke方法中，有一个获取当前方法的拦截器链的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br></pre></td></tr></table></figure>
<p>getInterceptorsAndDynamicInterceptionAdvice方法是在AdvisedSupport类中实现的，在这个方法中，还使用到了缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">extends</span> <span class="title">ProxyConfig</span> <span class="keyword">implements</span> <span class="title">Advised</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从配置中获取拦截器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//使用了缓存</span></span><br><span class="line">		MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</span><br><span class="line">		<span class="comment">//从缓存中获取拦截器</span></span><br><span class="line">		List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</span><br><span class="line">		<span class="comment">//如果缓存中不存在</span></span><br><span class="line">		<span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">		    <span class="comment">// 使用advisorChainFactory获取拦截器链</span></span><br><span class="line">			cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">					<span class="keyword">this</span>, method, targetClass);</span><br><span class="line">			<span class="keyword">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cached;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果缓存中不存在拦截器链，会调用AdvisorChainFactory的getInterceptorsAndDynamicInterceptionAdvice方法获取拦截器链，AdvisorChainFactory是一个生产通知器链的工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvisorChainFactory</span> </span>&#123;</span><br><span class="line">	<span class="function">List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Advised config, Method method, @Nullable Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AdvisorChainFactory是一个接口,它的子类DefaultAdvisorChainFactory实现了该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorChainFactory</span> <span class="keyword">implements</span> <span class="title">AdvisorChainFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Advised config, Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据配置中通知器的个数设置list的长度</span></span><br><span class="line">		List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;&gt;(config.getAdvisors().length);</span><br><span class="line">		Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">		<span class="keyword">boolean</span> hasIntroductions = hasMatchingIntroductions(config, actualClass);</span><br><span class="line">		<span class="comment">//用到了适配器模式，通过适配器加入拦截器链</span></span><br><span class="line">		AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line">		<span class="comment">//遍历通知器集合</span></span><br><span class="line">		<span class="keyword">for</span> (Advisor advisor : config.getAdvisors()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">				<span class="comment">// Add it conditionally.</span></span><br><span class="line">				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">				<span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">				    <span class="comment">//通知器转为对应的拦截器</span></span><br><span class="line">					MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">					<span class="comment">//判断是否匹配</span></span><br><span class="line">					<span class="keyword">if</span> (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line">						<span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line">							<span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">								interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">				<span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">					Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> interceptorList;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看这行代码，从GlobalAdvisorAdapterRegistry类中获取了通知适配器注册实例AdvisorAdapterRegistry：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br></pre></td></tr></table></figure>
<h5 id="GlobalAdvisorAdapterRegistry"><a href="#GlobalAdvisorAdapterRegistry" class="headerlink" title="GlobalAdvisorAdapterRegistry"></a>GlobalAdvisorAdapterRegistry</h5><p>GlobalAdvisorAdapterRegistry是一个抽象类，返回的是一个单例模式的DefaultAdvisorAdapterRegistry对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalAdvisorAdapterRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 单例模式，使用了DefaultAdvisorAdapterRegistry实现</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AdvisorAdapterRegistry instance = <span class="keyword">new</span> DefaultAdvisorAdapterRegistry();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AdvisorAdapterRegistry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		instance = <span class="keyword">new</span> DefaultAdvisorAdapterRegistry();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="DefaultAdvisorAdapterRegistry"><a href="#DefaultAdvisorAdapterRegistry" class="headerlink" title="DefaultAdvisorAdapterRegistry"></a>DefaultAdvisorAdapterRegistry</h5><p>DefaultAdvisorAdapterRegistry在构造方法中注册了一系列的适配器，在getInterceptors方法中通过适配器模式完成了advice向拦截器的转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorAdapterRegistry</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapterRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;AdvisorAdapter&gt; adapters = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造函数，注册适配器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DefaultAdvisorAdapterRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//前置通知</span></span><br><span class="line">		registerAdvisorAdapter(<span class="keyword">new</span> MethodBeforeAdviceAdapter());</span><br><span class="line">		registerAdvisorAdapter(<span class="keyword">new</span> AfterReturningAdviceAdapter());</span><br><span class="line">		registerAdvisorAdapter(<span class="keyword">new</span> ThrowsAdviceAdapter());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Advisor <span class="title">wrap</span><span class="params">(Object adviceObject)</span> <span class="keyword">throws</span> UnknownAdviceTypeException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (adviceObject <span class="keyword">instanceof</span> Advisor) &#123;</span><br><span class="line">			<span class="keyword">return</span> (Advisor) adviceObject;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!(adviceObject <span class="keyword">instanceof</span> Advice)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(adviceObject);</span><br><span class="line">		&#125;</span><br><span class="line">		Advice advice = (Advice) adviceObject;</span><br><span class="line">		<span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line">			<span class="comment">// So well-known it doesn't even need an adapter.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line">			<span class="comment">// Check that it is supported.</span></span><br><span class="line">			<span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advice);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取拦截器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> MethodInterceptor[] getInterceptors(Advisor advisor) <span class="keyword">throws</span> UnknownAdviceTypeException &#123;</span><br><span class="line">	    <span class="comment">//创建一个list，存放的类型是MethodInterceptor</span></span><br><span class="line">		List&lt;MethodInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">		<span class="comment">//从Advisor通知器配置中获取advice通知</span></span><br><span class="line">		Advice advice = advisor.getAdvice();</span><br><span class="line">		<span class="comment">//如果是MethodInterceptor类型的，不需要适配器，直接加入拦截器集合中</span></span><br><span class="line">		<span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line">			interceptors.add((MethodInterceptor) advice);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line">		    <span class="comment">//这里判断取得的advice是什么类型的通知器，从而注册不同的拦截器</span></span><br><span class="line">			<span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">			    <span class="comment">//advice转为拦截器加入到集合</span></span><br><span class="line">				interceptors.add(adapter.getInterceptor(advisor));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (interceptors.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advisor.getAdvice());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> interceptors.toArray(<span class="keyword">new</span> MethodInterceptor[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAdvisorAdapter</span><span class="params">(AdvisorAdapter adapter)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.adapters.add(adapter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getInterceptors方法中，传入的参数是Advisor类型的通知，返回的是方法拦截器集合，每个通知器都有对应的方法拦截器，比如BeforeAdvice通知器的拦截器是MethodBeforeAdviceInterceptor，该方法的作用就是通过适配器模式将通知器转为对应的方法拦截器。所以通知器如果是MethodInterceptor类型的直接加入集合，如果不是，需要通过适配器模式将通知转为拦截器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line">	    <span class="comment">//这里判断取得的advice是什么类型的通知器，从而注册不同的拦截器</span></span><br><span class="line">		<span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">		    <span class="comment">//通过适配器模式advice转为拦截器加入到集合</span></span><br><span class="line">			interceptors.add(adapter.getInterceptor(advisor));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Spring-AOP适配器模式的应用"><a href="#Spring-AOP适配器模式的应用" class="headerlink" title="Spring AOP适配器模式的应用"></a>Spring AOP适配器模式的应用</h4><h5 id="1-AdvisorAdapter"><a href="#1-AdvisorAdapter" class="headerlink" title="1.AdvisorAdapter"></a>1.AdvisorAdapter</h5><p>上面知道通过调用AdvisorAdapter的getInterceptor方法将通知器advisor转为了对应的拦截器MethodInterceptor，AdvisorAdapter是一个接口，定义了两个方法，分别是<br>supportsAdvice和getInterceptor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvisorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断通知器的类型是否支持</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * advisor转为MethodInterceptor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="MethodInterceptor"><a href="#MethodInterceptor" class="headerlink" title="MethodInterceptor"></a>MethodInterceptor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-MethodBeforeAdviceAdapter"><a href="#2-MethodBeforeAdviceAdapter" class="headerlink" title="2.MethodBeforeAdviceAdapter"></a>2.MethodBeforeAdviceAdapter</h5><p>以MethodBeforeAdviceAdapter为例看一下如何转换的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//判断通知器是否是MethodBeforeAdvice的实例</span></span><br><span class="line">		<span class="keyword">return</span> (advice <span class="keyword">instanceof</span> MethodBeforeAdvice);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//通知器转为MethodBeforeAdvice类型</span></span><br><span class="line">		MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();</span><br><span class="line">		<span class="comment">//MethodBeforeAdvice转为MethodBeforeAdviceInterceptor类型</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdviceInterceptor(advice);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="MethodBeforeAdviceInterceptor"><a href="#MethodBeforeAdviceInterceptor" class="headerlink" title="MethodBeforeAdviceInterceptor"></a>MethodBeforeAdviceInterceptor</h5><p>MethodBeforeAdviceInterceptor实现了MethodInterceptor接口，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> MethodBeforeAdvice advice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MethodBeforeAdviceInterceptor</span><span class="params">(MethodBeforeAdvice advice)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(advice, <span class="string">"Advice must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.advice = advice;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器的回调方法，会在代理对象的方法被调用前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );</span><br><span class="line">		<span class="keyword">return</span> mi.proceed();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>参考：</strong></p>
<p>spring技术内幕:深入解析spring架构与设计原理</p>
<p><a href="https://blog.csdn.net/jzq114/article/details/51319212" target="_blank" rel="noopener">jzq114：AOP源码分析之初始化通知器链</a></p>
<p><a href="https://segmentfault.com/a/1190000011856448" target="_blank" rel="noopener">峰峰峰峰峰：一起学设计模式 - 适配器模式</a></p>
<p><strong>Spring版本:5.0.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/01/【Spring】AOP原理（一）：AopProxy代理对象的生成/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/01/【Spring】AOP原理（一）：AopProxy代理对象的生成/" itemprop="url">AOP原理（一）：AopProxy代理对象的生成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-01T21:08:14+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>前提知识：动态代理</strong></p>
<p><a href="https://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="noopener">岑宇:Java的三种代理模式</a></p>
<p><a href="https://www.cnblogs.com/xdp-gacl/p/3971367.html" target="_blank" rel="noopener">孤傲苍狼:Java基础加强总结(三)——代理(Proxy)</a></p>
<h4 id="基于接口的配置方式"><a href="#基于接口的配置方式" class="headerlink" title="基于接口的配置方式"></a>基于接口的配置方式</h4><p>基于接口的配置方式比较古老，但是有利于熟悉源码。</p>
<p>一个简单的例子：</p>
<p>1.StudentService接口，里面包含了一个save方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span>  <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.StudentService接口实现类StduentServiceImpl,它实现了save方法，里面只是简单的打印了一句话:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceImpl</span> <span class="keyword">implements</span> <span class="title">StudentService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行save方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.一个自定义前置通知器MyBeforeAdvide，它实现了方法前置通知器接口MethodBeforeAdvice,重写了before方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备调用方法："</span> + method.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.创建spring-aop.xml配置文件，添加以下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置通知器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAdvice"</span> <span class="attr">class</span>=<span class="string">"com.study.proxybeanfactory.MyBeforeAdvice"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!---配置bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentService"</span> <span class="attr">class</span>=<span class="string">"com.study.proxybeanfactory.StudentServiceImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置代理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentServiceProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--代理的接口--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.study.proxybeanfactory.StudentService<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--代理的具体实现--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"studentService"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置拦截器，配置定义的通知器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>myAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>5.单元测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeforeAdviceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testXMLConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建容器，加载配置文件</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:/spring/spring-aop.xml"</span>);</span><br><span class="line">        <span class="comment">//从容器中获取bean，注意这里，获取的是StduentService的代理，而不是studentServcie</span></span><br><span class="line">        StudentService studentService = (StudentService) applicationContext.getBean(<span class="string">"studentServiceProxy"</span>);</span><br><span class="line">        <span class="comment">//执行save方法，实际上是由代理完成的</span></span><br><span class="line">        studentService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">准备调用方法：save</span><br><span class="line">执行save方法保存数据</span><br></pre></td></tr></table></figure>
<p>可以看到在save方法执行之前，首先执行了自定义通知器中的before方法。</p>
<p><strong>参考：</strong></p>
<p><a href="https://www.javadoop.com/post/spring-aop-intro" target="_blank" rel="noopener">Spring AOP 使用介绍，从前世到今生</a></p>
<hr>
<h3 id="ProxyFactoryBean生成AopProxy代理对象"><a href="#ProxyFactoryBean生成AopProxy代理对象" class="headerlink" title="ProxyFactoryBean生成AopProxy代理对象"></a>ProxyFactoryBean生成AopProxy代理对象</h3><h4 id="1-ProxyFactoryBean"><a href="#1-ProxyFactoryBean" class="headerlink" title="1.ProxyFactoryBean"></a>1.ProxyFactoryBean</h4><p>从上面例子看到，配置代理的时候使用的是ProxyFactoryBean，那么就从ProxyFactoryBean开始，看一下AOP的实现原理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactoryBean</span> <span class="keyword">extends</span> <span class="title">ProxyCreatorSupport</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Object</span>&gt;, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	    <span class="comment">//初始化通知器链</span></span><br><span class="line">		initializeAdvisorChain();</span><br><span class="line">		<span class="comment">//如果是单例模式的bean</span></span><br><span class="line">		<span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line">			<span class="keyword">return</span> getSingletonInstance();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">				logger.warn(<span class="string">"Using non-singleton proxies with singleton targets is often undesirable. "</span> +</span><br><span class="line">						<span class="string">"Enable prototype proxies by setting the 'targetName' property."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> newPrototypeInstance();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化通知器链</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeAdvisorChain</span><span class="params">()</span> <span class="keyword">throws</span> AopConfigException, BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.advisorChainInitialized) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果拦截器不为空</span></span><br><span class="line">		<span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.interceptorNames)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No BeanFactory available anymore (probably due to serialization) "</span> +</span><br><span class="line">						<span class="string">"- cannot resolve interceptor names "</span> + Arrays.asList(<span class="keyword">this</span>.interceptorNames));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Globals can't be last unless we specified a targetSource using the property...</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.interceptorNames[<span class="keyword">this</span>.interceptorNames.length - <span class="number">1</span>].endsWith(GLOBAL_SUFFIX) &amp;&amp;</span><br><span class="line">					<span class="keyword">this</span>.targetName == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSource == EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Target required after globals"</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 遍历拦截器</span></span><br><span class="line">			<span class="keyword">for</span> (String name : <span class="keyword">this</span>.interceptorNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">"Configuring advisor or advice '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//如果是全局的拦截器</span></span><br><span class="line">				<span class="keyword">if</span> (name.endsWith(GLOBAL_SUFFIX)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!(<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ListableBeanFactory)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(</span><br><span class="line">								<span class="string">"Can only use global advisors or interceptors with a ListableBeanFactory"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//添加到全局拦截器</span></span><br><span class="line">					addGlobalAdvisor((ListableBeanFactory) <span class="keyword">this</span>.beanFactory,</span><br><span class="line">							name.substring(<span class="number">0</span>, name.length() - GLOBAL_SUFFIX.length()));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 判断bean是singleton还是prototype</span></span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">this</span>.singleton || <span class="keyword">this</span>.beanFactory.isSingleton(name)) &#123;</span><br><span class="line">						<span class="comment">// 根据bean的名字获取通知器</span></span><br><span class="line">						advice = <span class="keyword">this</span>.beanFactory.getBean(name);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// prototype类型的通知器</span></span><br><span class="line">						advice = <span class="keyword">new</span> PrototypePlaceholderAdvisor(name);</span><br><span class="line">					&#125;</span><br><span class="line">					addAdvisorOnChainCreation(advice, name);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//初始化过之后设为true</span></span><br><span class="line">		<span class="keyword">this</span>.advisorChainInitialized = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)ProxyFactoryBean中的getObject方法，首先对通知器链进行初始化，通知器链封装了一系列的拦截器，这些拦截器从XML配置文件中读取，为代理对象的生成做好准备。<br>配置文件中的拦截器interceptorNames：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置代理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentServiceProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--代理的接口--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.study.proxybeanfactory.StudentService<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--代理的具体实现--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"studentService"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置拦截器，配置定义的通知器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>myAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">(2)advisor通知器的获取是通过IoC容器的getBean(name)方法完成的。</span><br><span class="line">(3)在初始化拦截器链initializeAdvisorChain方法中，需要对bean是prototype还是singleton进行判断，如果是singleton直接根据bean的名字通过容器的getBean方法获取即可，如果是prototype，创建PrototypePlaceholderAdvisor。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">回到getObject方法，看一下生成singleton的代理对象的过程，生成singlton代理对象的方法在getSingletonInstance()方法中完成：</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">	private synchronized Object getSingletonInstance() &#123;</span><br><span class="line">		if (this.singletonInstance == null) &#123;</span><br><span class="line">			this.targetSource = freshTargetSource();</span><br><span class="line">			if (this.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == 0 &amp;&amp; !isProxyTargetClass()) &#123;</span><br><span class="line">				// Rely on AOP infrastructure to tell us what interfaces to proxy.</span><br><span class="line">				Class&lt;?&gt; targetClass = getTargetClass();</span><br><span class="line">				if (targetClass == null) &#123;</span><br><span class="line">					throw new FactoryBeanNotInitializedException("Cannot determine target class for proxy");</span><br><span class="line">				&#125;</span><br><span class="line">				//设置代理对象的接口</span><br><span class="line">				setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));</span><br><span class="line">			&#125;</span><br><span class="line">			super.setFrozen(this.freezeProxy);</span><br><span class="line">			//生成代理</span><br><span class="line">			this.singletonInstance = getProxy(createAopProxy());</span><br><span class="line">		&#125;</span><br><span class="line">		return this.singletonInstance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 创建AOP代理</span><br><span class="line">	 */</span><br><span class="line">	protected final synchronized AopProxy createAopProxy() &#123;</span><br><span class="line">		if (!this.active) &#123;</span><br><span class="line">			activate();</span><br><span class="line">		&#125;</span><br><span class="line">		return getAopProxyFactory().createAopProxy(this);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 通过创建的AopProxy获取代理</span><br><span class="line">	 */</span><br><span class="line">	protected Object getProxy(AopProxy aopProxy) &#123;</span><br><span class="line">		return aopProxy.getProxy(this.proxyClassLoader);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>(1)在createAopProxy()方法创建了AOP代理，方法的返回类型是AopProxy,它是一个接口，它有两个子类CglibAopProxy和JdkDynamicAopProxy，从名字上就可以看出来CglibAopProxy是通过CGLIB来生成代理对象，JdkDynamicAopProxy使用JDK动态代理生成代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CglibAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>(2)createAopProxy()方法是在ProxyCreatorSupport中完成的。</p>
<h4 id="2-ProxyCreatorSupport"><a href="#2-ProxyCreatorSupport" class="headerlink" title="2.ProxyCreatorSupport"></a>2.ProxyCreatorSupport</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCreatorSupport</span> <span class="keyword">extends</span> <span class="title">AdvisedSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AopProxyFactory aopProxyFactory;</span><br><span class="line">    	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyCreatorSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里可以看到代理工厂使用的是DefaultAopProxyFactory</span></span><br><span class="line">		<span class="keyword">this</span>.aopProxyFactory = <span class="keyword">new</span> DefaultAopProxyFactory();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">			activate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//使用DefaultAopProxyFactory实现</span></span><br><span class="line">		<span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取AopProxyFactory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxyFactory <span class="title">getAopProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.aopProxyFactory;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在createAopProxy方法中，通过获取Aop代理工厂AopProxyFactory创建Aop代理对象，AopProxyFactory是一个接口，ProxyCreatorSupport的构造函数中可以看到，工厂使用DefaultAopProxyFactory实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 根据配置信息创建AOP代理</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-Aop代理工厂DefaultAopProxyFactory"><a href="#3-Aop代理工厂DefaultAopProxyFactory" class="headerlink" title="3.Aop代理工厂DefaultAopProxyFactory"></a>3.Aop代理工厂DefaultAopProxyFactory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">	    <span class="comment">//从config中读取信息判断使用哪种方式生成代理</span></span><br><span class="line">	    <span class="comment">//如果使用显示优化或者配置了目标类</span></span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">		    <span class="comment">//获取目标对象</span></span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">						<span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果目标对象是接口</span></span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">			    <span class="comment">//使用JDK动态代理</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//CGLIB生成代理</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">		    <span class="comment">//JDK动态代理</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the supplied &#123;<span class="doctag">@link</span> AdvisedSupport&#125; has only the</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.aop.SpringProxy&#125; interface specified</span></span><br><span class="line"><span class="comment">	 * (or no proxy interfaces specified at all).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">		<span class="keyword">return</span> (ifcs.length == <span class="number">0</span> || (ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>])));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成代理对象的过程中，需要从AdvisedSupport对象中获取配置的目标对象，对目标对象配置的检查完成后，根据配置的情况决定使用什么方式创建AopProxy代理对象。如果目标对象是接口类的实现，使用JDK动态代理，否则使用CGLIB生成。</p>
<h4 id="JDK生成Aop代理对象"><a href="#JDK生成Aop代理对象" class="headerlink" title="JDK生成Aop代理对象"></a>JDK生成Aop代理对象</h4><p>JdkDynamicAopProxy本身实现了InvocationHandler接口，所以使用Proxy.newProxyInstance方法生成对象时可以将自身指派给代理对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">		&#125;</span><br><span class="line">		Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">		findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">		<span class="comment">//使用JDK动态代理生成代理对象</span></span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="CGLIB生成Aop代理对象"><a href="#CGLIB生成Aop代理对象" class="headerlink" title="CGLIB生成Aop代理对象"></a>CGLIB生成Aop代理对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CglibAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getProxy(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Creating CGLIB proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		    <span class="comment">//获取在IoC容器中配置的target对象</span></span><br><span class="line">			Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">			Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">"Target class must be available for creating a CGLIB proxy"</span>);</span><br><span class="line"></span><br><span class="line">			Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">			<span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">				proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">				Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">				<span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">					<span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">			validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 创建并配置CGLIB的Enhancer</span></span><br><span class="line">			Enhancer enhancer = createEnhancer();</span><br><span class="line">			<span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">				enhancer.setClassLoader(classLoader);</span><br><span class="line">				<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">						((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">					enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//设置Enhancer对象，包括设置代理接口、回调方法</span></span><br><span class="line">			enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">			enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">			enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">			Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">			Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">				types[x] = callbacks[x].getClass();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">			enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">					<span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">			enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 生成代理对象</span></span><br><span class="line">			<span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of class ["</span> +</span><br><span class="line">					<span class="keyword">this</span>.advised.getTargetClass() + <span class="string">"]: "</span> +</span><br><span class="line">					<span class="string">"Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">					ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，AopProxy对象已经生成了，通过ProxyFactoryBean的getObject方法获取到的对象就不是一个普通的Java对象了，而是一个AopProxy代理对象，当调用目标对象的方法时，会被AopProxy代理对象拦截，对于JDK动态代理，使用的是InvocationHandler的invoke回调入口；对于Cglib，使用的是设置好的callback回调。</p>
<p>参考：</p>
<p>spring技术内幕:深入解析spring架构与设计原理</p>
<p><a href="https://blog.csdn.net/u013185616/article/details/52452594" target="_blank" rel="noopener">【Spring源码–AOP的实现】（一）AopProxy代理对象的创建</a></p>
<p><strong>Spring版本:5.0.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/10/【Spring】Bean的生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/10/【Spring】Bean的生命周期/" itemprop="url">Bean的生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-10T20:50:50+08:00">
                2018-06-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>回想IoC容器的依赖注入过程，有一步是调用AbstractAutowireCapableBeanFactory的doCreateBean方法来创建bean实例，在调用createBeanInstance创建bean的实例以及            调用populateBean完成依赖注入之后，调用了initializeBean对bean进行初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  创建指定的bean对象 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// BeanWrapper用来持有创建出来的Bean对象 </span></span><br><span class="line">		BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">		    <span class="comment">//如果是单例模式，清除缓存中同名的bean</span></span><br><span class="line">			instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">		    <span class="comment">//调用createBeanInstance方法完成bean的实例化</span></span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">		<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">			mbd.resolvedTargetType = beanType;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">		<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">							<span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断bean是否是单例模式、允许循环引用和给定的bean是否处于创建状态</span></span><br><span class="line">		<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">						<span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将创建的baen放入SingletonFactory</span></span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 初始化bean的实例</span></span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		    <span class="comment">//依赖注入发生的地方</span></span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			<span class="comment">//初始化bean</span></span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">				<span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">						mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">					<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">								<span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">								<span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">								<span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">								<span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">								<span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register bean as disposable.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> exposedObject;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 初始化给定的Bean实例</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">				invokeAwareMethods(beanName, bean);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">		    <span class="comment">//调用一系列的aware接口实现 </span></span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">		    <span class="comment">//在初始化之前调用BeanPostProcessors后置处理器</span></span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		    <span class="comment">//处理bean的init方法</span></span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">					beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">		    <span class="comment">//初始化之后调用BeanPostProcessors后置处理器</span></span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> wrappedBean;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">		   <span class="comment">//bean初始化之后的后置处理器调用</span></span><br><span class="line">			Object current = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">			<span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">			result = current;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">		    <span class="comment">//bean初始化之前的后置处理器调用</span></span><br><span class="line">			Object current = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">			<span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">			result = current;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//把相关的BeanName、BeanClassLoader以及BeanFactory注入到Bean中</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">			    <span class="comment">//设置bean的name</span></span><br><span class="line">				((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">				ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">				<span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">				    <span class="comment">//设置bean的类加载器</span></span><br><span class="line">					((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">			     <span class="comment">//设置baenFactory到bean中</span></span><br><span class="line">				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 检查bean是否实现了InitializingBean的init方法或者有自定义的init方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//如果是InitializingBean的实例</span></span><br><span class="line">		<span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">		<span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">						((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">					<span class="keyword">throw</span> pae.getException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">			    <span class="comment">//启动afterPropertiesSet</span></span><br><span class="line">				((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">		    <span class="comment">//判断Bean是否配置有initMethod</span></span><br><span class="line">			String initMethodName = mbd.getInitMethodName();</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">					!(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">					!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">				invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取Bean定义的init-method,然后通过JDK的反射机制得到Method对象，调用在Bean定义中声明的初始化方法。  </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeCustomInitMethod</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//获取Bean定义的initMethod</span></span><br><span class="line">		String initMethodName = mbd.getInitMethodName();</span><br><span class="line">		Assert.state(initMethodName != <span class="keyword">null</span>, <span class="string">"No init method set"</span>);</span><br><span class="line">		<span class="keyword">final</span> Method initMethod = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">				BeanUtils.findMethod(bean.getClass(), initMethodName) :</span><br><span class="line">				ClassUtils.getMethodIfAvailable(bean.getClass(), initMethodName));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (initMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mbd.isEnforceInitMethod()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">"Couldn't find an init method named '"</span> +</span><br><span class="line">						initMethodName + <span class="string">"' on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"No default init method named '"</span> + initMethodName +</span><br><span class="line">							<span class="string">"' found on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Ignore non-existent default lifecycle methods.</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Invoking init method  '"</span> + initMethodName + <span class="string">"' on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">				ReflectionUtils.makeAccessible(initMethod);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt;</span><br><span class="line">					initMethod.invoke(bean), getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">				InvocationTargetException ex = (InvocationTargetException) pae.getException();</span><br><span class="line">				<span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">		     	<span class="comment">//通过JDK的反射机制调用在Bean定义中声明的初始化方法。  </span></span><br><span class="line">				ReflectionUtils.makeAccessible(initMethod);</span><br><span class="line">				initMethod.invoke(bean);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//容器关闭时销毁bean</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyBean</span><span class="params">(Object existingBean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> DisposableBeanAdapter(existingBean, getBeanPostProcessors(), getAccessControlContext()).destroy();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>从AbstractAutowireCapableBeanFactory的initializeBean方法看一下Bean的生命周期：</strong></p>
<p>（1）因为initializeBean是在创建bean实例和依赖注入完成之后调用的，所以生命周期的第一步是容器完成Bean的实例化。</p>
<p>（2）在initializeBean方法中首先调用了invokeAwareMethods方法，调用一系列的aware接口实现，把相关的BeanName、BeanClassLoader以及BeanFactory注入到了Bean中。</p>
<ul>
<li><p>如果Bean实现了BeanNameAware接口，会调用它的setBeanName方法.</p>
</li>
<li><p>如果Bean实现了BeanFactoryAware接口，会调用它实现的setBeanFactory().</p>
</li>
<li><p>如果这个Bean实现了ApplicationContextAware接口，会调用setApplicationContext方法.</p>
</li>
</ul>
<p>（3）在bean初始化之前调用BeanPostProcessors后置处理器的postProcessBeforeInitialization方法。</p>
<p>（4）调用后置处理器之后，调用了invokeInitMethods方法，这个方法是用来检查<br>在这个方法中，首先会检查Bean是否实现了InitializingBean接口，如果实现了该接口将会调用afterPropertiesSet方法。如果未实现InitializingBean接口，会检查Bean是否配置有init-method，如果有就调用bean的init-method方法。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">init-method</span>=<span class="string">"initMethod"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>（5）invokeInitMethods方法执行完毕后调用BeanPostProcessors后置处理器postProcessAfterInitialization方法。</p>
<p>（6）应用通过IoC容器使用Bean.</p>
<p>（7）当容器关闭时，调用Bean的销毁方法，销毁bean的方法在DisposableBeanAdapter中实现。</p>
<ul>
<li>如果Bean实现了DisposableBean接口，会调用其实现的destroy方法.</li>
<li>如果配置文件中配置了该bean的destroy-method属性，会自动调用其配置的销毁方法.</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"xxx"</span>  <span class="attr">destroy-method</span>=<span class="string">"destroyMethod"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="DisposableBeanAdapter"><a href="#DisposableBeanAdapter" class="headerlink" title="DisposableBeanAdapter"></a>DisposableBeanAdapter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisposableBeanAdapter</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span>, <span class="title">Runnable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.beanPostProcessors)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (DestructionAwareBeanPostProcessor processor : <span class="keyword">this</span>.beanPostProcessors) &#123;</span><br><span class="line">				processor.postProcessBeforeDestruction(<span class="keyword">this</span>.bean, <span class="keyword">this</span>.beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Invoking destroy() on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">					AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">		           	<span class="comment">//如果Bean实现了DisposableBean接口，会调用其实现的destroy方法</span></span><br><span class="line">						((DisposableBean) bean).destroy();</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;, acc);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					((DisposableBean) bean).destroy();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				String msg = <span class="string">"Invocation of destroy method failed on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.warn(msg, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					logger.warn(msg + <span class="string">": "</span> + ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">		    <span class="comment">//调用Spring配置中的destroy-method销毁方法</span></span><br><span class="line">			invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Method methodToCall = determineDestroyMethod(<span class="keyword">this</span>.destroyMethodName);</span><br><span class="line">			<span class="keyword">if</span> (methodToCall != <span class="keyword">null</span>) &#123;</span><br><span class="line">				invokeCustomDestroyMethod(methodToCall);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p>spring技术内幕:深入解析spring架构与设计原理</p>
<p><a href="https://www.cnblogs.com/redcool/p/6397398.html" target="_blank" rel="noopener">低调的小黑：Spring Bean的生命周期</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">shan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shan</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
