<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Redis," />










<meta name="description" content="集群故障转移节点下线在集群定时任务clusterCron中，会遍历集群中的节点，对每个节点进行检查，判断节点是否下线。与节点下线相关的状态有两个，分别为CLUSTER_NODE_PFAIL和CLUSTER_NODE_FAIL。 CLUSTER_NODE_PFAIL：当前节点认为某个节点下线时，会将节点状态改为CLUSTER_NODE_PFAIL，由于可能存在误判，所以需要根据集群中的其他节点共同决">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="【Redis】集群故障转移">
<meta property="og:url" content="http://yoursite.com/2022/05/19/【Redis】集群故障转移/index.html">
<meta property="og:site_name" content="SHAN">
<meta property="og:description" content="集群故障转移节点下线在集群定时任务clusterCron中，会遍历集群中的节点，对每个节点进行检查，判断节点是否下线。与节点下线相关的状态有两个，分别为CLUSTER_NODE_PFAIL和CLUSTER_NODE_FAIL。 CLUSTER_NODE_PFAIL：当前节点认为某个节点下线时，会将节点状态改为CLUSTER_NODE_PFAIL，由于可能存在误判，所以需要根据集群中的其他节点共同决">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/images/下线.jpg">
<meta property="og:image" content="http://yoursite.com/images/故障处理.jpg">
<meta property="og:image" content="http://yoursite.com/images/投票.jpg">
<meta property="og:image" content="http://yoursite.com/images/故障切换.jpg">
<meta property="og:updated_time" content="2022-05-29T12:24:26.089Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【Redis】集群故障转移">
<meta name="twitter:description" content="集群故障转移节点下线在集群定时任务clusterCron中，会遍历集群中的节点，对每个节点进行检查，判断节点是否下线。与节点下线相关的状态有两个，分别为CLUSTER_NODE_PFAIL和CLUSTER_NODE_FAIL。 CLUSTER_NODE_PFAIL：当前节点认为某个节点下线时，会将节点状态改为CLUSTER_NODE_PFAIL，由于可能存在误判，所以需要根据集群中的其他节点共同决">
<meta name="twitter:image" content="http://yoursite.com/images/下线.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2022/05/19/【Redis】集群故障转移/"/>





  <title>【Redis】集群故障转移 | SHAN</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SHAN</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/19/【Redis】集群故障转移/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【Redis】集群故障转移</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-19T23:00:00+08:00">
                2022-05-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="集群故障转移"><a href="#集群故障转移" class="headerlink" title="集群故障转移"></a>集群故障转移</h2><h3 id="节点下线"><a href="#节点下线" class="headerlink" title="节点下线"></a>节点下线</h3><p>在集群定时任务<code>clusterCron</code>中，会遍历集群中的节点，对每个节点进行检查，判断节点是否下线。与节点下线相关的状态有两个，分别为<code>CLUSTER_NODE_PFAIL</code>和<code>CLUSTER_NODE_FAIL</code>。</p>
<p><code>CLUSTER_NODE_PFAIL</code>：当前节点认为某个节点下线时，会将节点状态改为<code>CLUSTER_NODE_PFAIL</code>，由于可能存在误判，所以需要根据集群中的其他节点共同决定是否真的将节点标记为下线状态，<strong><code>CLUSTER_NODE_PFAIL</code>可以理解为疑似下线，类似哨兵集群中的主观下线</strong>。</p>
<p><code>CLUSTER_NODE_FAIL</code>：集群中有过半的节点标认为节点已下线，此时将节点置为<code>CLUSTER_NODE_FAIL</code>标记节点下线，<strong><code>CLUSTER_NODE_FAIL</code>表示节点真正处于下线状态，类似哨兵集群的客观下线</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTER_NODE_PFAIL 4      <span class="comment">/* 疑似下线，需要根据其他节点的判断决定是否下线，类似主观下线 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTER_NODE_FAIL 8       <span class="comment">/* 节点处于下线状态，类似客观下线 */</span></span></span><br></pre></td></tr></table></figure>
<h4 id="疑似下线（PFAIL）"><a href="#疑似下线（PFAIL）" class="headerlink" title="疑似下线（PFAIL）"></a>疑似下线（PFAIL）</h4><p>在集群定时任务遍历集群中的节点进行检查时，遍历到的每个节点记为<code>node</code>，当前节点记为<code>myself</code>，检查的内容主要有以下几个方面：</p>
<p><strong>一、判断孤立主节点的个数</strong></p>
<p>如果当前节点<code>myself</code>是从节点，正在遍历的节点<code>node</code>是主节点，并且<code>node</code>节点不处于下线状态，会判断孤立节点的个数，满足以下三个条件时，认定<code>node</code>是孤立节点，孤立节点个数增1：</p>
<ol>
<li><code>node</code>的从节点中处于非下线状态的节点个数为0</li>
<li><code>node</code>负责的slot数量大于0，</li>
<li><code>node</code>节点处于CLUSTER_NODE_MIGRATE_TO状态</li>
</ol>
<p><strong>二、检查连接</strong></p>
<p>这一步主要检查和节点间的连接是否正常，有可能节点处于正常状态，但是连接有问题，此时需要释放连接，在下次执行定时任务时会进行重连，释放连接需要同时满足以下几个条件：</p>
<ol>
<li>与节点<code>node</code>之间的连接不为空，说明之前进行过连接</li>
<li>当前时间距离连接创建的时间超过了超时时间</li>
<li>距离向<code>node</code>发送PING消息的时间已经超过了超时时间的一半</li>
<li>距离收到<code>node</code>节点发送消息的时间超过了超时时间的一半</li>
</ol>
<p><strong>三、疑似下线判断</strong></p>
<p><code>ping_delay</code>记录了当前时间距离向<code>node</code>节点发送PING消息的时间，<code>data_delayd</code>记录了<code>node</code>节点向当前节点最近一次发送消息的时间，从ping_delay和data_delay中取较大的那个作为延迟时间。</p>
<p><strong>如果延迟时间大于超时时间，判断<code>node</code>是否已经处于<code>CLUSTER_NODE_PFAIL</code>或者<code>CLUSTER_NODE_FAIL</code>状态，如果都不处于，将节点状态置为<code>CLUSTER_NODE_PFAIL</code>，认为节点疑似下线。</strong></p>
<p>也就是说如果在规定的超时时间内，当前节点长时间未向<code>node</code>节点发送PING消息，或者长时间未收到<code>node</code>节点向当前节点发送的消息，当前节点就认为<code>node</code>疑似下线状态。</p>
<p>上述检查完成之后，<strong>会判断当前节点是否是从节点，如果不处于<code>CLUSTER_MODULE_FLAG_NO_FAILOVER</code>状态，调用<code>clusterHandleSlaveFailover</code>处理故障转移，不过需要注意此时只是将节点置为疑似下线，并不满足故障转移条件，需要等待节点被置为FAIL下线状态之后，再次执行集群定时任务进入到<code>clusterHandleSlaveFailover</code>函数中才可以开始处理故障转移。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">    orphaned_masters = <span class="number">0</span>;</span><br><span class="line">    max_slaves = <span class="number">0</span>;</span><br><span class="line">    this_slaves = <span class="number">0</span>;</span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    <span class="comment">// 遍历集群中的节点</span></span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取节点</span></span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line">        now = mstime(); <span class="comment">/* 当前时间 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;flags &amp;</span><br><span class="line">            (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果当前节点myself是从节点，正在遍历的节点node是主节点，并且node节点不处于下线状态 */</span></span><br><span class="line">        <span class="keyword">if</span> (nodeIsSlave(myself) &amp;&amp; nodeIsMaster(node) &amp;&amp; !nodeFailed(node)) &#123;</span><br><span class="line">            <span class="comment">// 获取不处于下线状态的从节点数量</span></span><br><span class="line">            <span class="keyword">int</span> okslaves = clusterCountNonFailingSlaves(node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果处于正常状态的从节点数量为0、node负责的slot数量大于0， 并且节点处于CLUSTER_NODE_MIGRATE_TO状态 */</span></span><br><span class="line">            <span class="keyword">if</span> (okslaves == <span class="number">0</span> &amp;&amp; node-&gt;numslots &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                node-&gt;flags &amp; CLUSTER_NODE_MIGRATE_TO)</span><br><span class="line">            &#123;</span><br><span class="line">                orphaned_masters++; <span class="comment">// 孤立主节点数量加1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大从节点数量</span></span><br><span class="line">            <span class="keyword">if</span> (okslaves &gt; max_slaves) max_slaves = okslaves;</span><br><span class="line">            <span class="comment">// 如果myself是从节点 并且myself是node的从节点</span></span><br><span class="line">            <span class="keyword">if</span> (nodeIsSlave(myself) &amp;&amp; myself-&gt;slaveof == node)</span><br><span class="line">                this_slaves = okslaves; <span class="comment">// 记录处于正常状态的从节点数量</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 这一步主要检查连接是否出现问题 */</span></span><br><span class="line">        <span class="keyword">mstime_t</span> ping_delay = now - node-&gt;ping_sent; <span class="comment">// 当前时间减去发送PING消息时间</span></span><br><span class="line">        <span class="keyword">mstime_t</span> data_delay = now - node-&gt;data_received; <span class="comment">// 当前时间减去收到node向当前节点发送消息的时间</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;link &amp;&amp; <span class="comment">/* 如果连接不为空 */</span></span><br><span class="line">            now - node-&gt;link-&gt;ctime &gt; </span><br><span class="line">            server.cluster_node_timeout &amp;&amp; <span class="comment">/* 距离连接创建的时间超过了设置的超时时间 */</span></span><br><span class="line">            node-&gt;ping_sent &amp;&amp; <span class="comment">/* 发送过PING消息 */</span></span><br><span class="line">            <span class="comment">/* 距离发送PING消息的时间已经超过了超时时间的一半 */</span></span><br><span class="line">            ping_delay &gt; server.cluster_node_timeout/<span class="number">2</span> &amp;&amp;</span><br><span class="line">            <span class="comment">/* 距离收到node节点发送消息的时间超过了超时时间的一半</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            data_delay &gt; server.cluster_node_timeout/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 断开连接，在下次执行定时任务时会重新连接 */</span></span><br><span class="line">            freeClusterLink(node-&gt;link);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果连接不为空、ping_sent为0（收到PONG消息后会将ping_sent置为0），并且当前时间减去收到node的PONG消息的时间大于超时时间的一半 */</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;link &amp;&amp;</span><br><span class="line">            node-&gt;ping_sent == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (now - node-&gt;pong_received) &gt; server.cluster_node_timeout/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 立即发送PING消息，保持连接</span></span><br><span class="line">            clusterSendPing(node-&gt;link, CLUSTERMSG_TYPE_PING);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.cluster-&gt;mf_end &amp;&amp; <span class="comment">// 手动执行故障转移时间限制不为0，表示正在执行手动故障转移</span></span><br><span class="line">            nodeIsMaster(myself) &amp;&amp; <span class="comment">// 如果myself是主节点</span></span><br><span class="line">            server.cluster-&gt;mf_slave == node &amp;&amp;  <span class="comment">// 如果node是myself从节点并且正在执行手动故障转移</span></span><br><span class="line">            node-&gt;link) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 发送PING消息，保持连接</span></span><br><span class="line">            clusterSendPing(node-&gt;link, CLUSTERMSG_TYPE_PING);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果没有活跃的PING消息. */</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;ping_sent == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 校验节点是否主观下线 */</span></span><br><span class="line">        <span class="comment">// ping_delay记录了当前时间距离向node节点发送PING消息的时间</span></span><br><span class="line">        <span class="comment">// data_delay记录了node节点向当前节点最近一次发送消息的时间</span></span><br><span class="line">        <span class="comment">// 从ping_delay和data_delay中取较大的那个作为延迟时间</span></span><br><span class="line">        <span class="keyword">mstime_t</span> node_delay = (ping_delay &lt; data_delay) ? ping_delay :</span><br><span class="line">                                                          data_delay;</span><br><span class="line">        <span class="comment">// 如果节点的延迟时间大于超时时间</span></span><br><span class="line">        <span class="keyword">if</span> (node_delay &gt; server.cluster_node_timeout) &#123;</span><br><span class="line">            <span class="comment">/* 如果不处于CLUSTER_NODE_PFAIL或者CLUSTER_NODE_FAIL状态*/</span></span><br><span class="line">            <span class="keyword">if</span> (!(node-&gt;flags &amp; (CLUSTER_NODE_PFAIL|CLUSTER_NODE_FAIL))) &#123;</span><br><span class="line">                serverLog(LL_DEBUG,<span class="string">"*** NODE %.40s possibly failing"</span>,</span><br><span class="line">                    node-&gt;name);</span><br><span class="line">                <span class="comment">// 将节点标记为故障状态CLUSTER_NODE_PFAIL，标记疑似下线</span></span><br><span class="line">                node-&gt;flags |= CLUSTER_NODE_PFAIL;</span><br><span class="line">                update_state = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是从节点</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsSlave(myself)) &#123;</span><br><span class="line">        clusterHandleManualFailover();</span><br><span class="line">        <span class="comment">// 如果不处于CLUSTER_MODULE_FLAG_NO_FAILOVER状态</span></span><br><span class="line">        <span class="keyword">if</span> (!(server.cluster_module_flags &amp; CLUSTER_MODULE_FLAG_NO_FAILOVER))</span><br><span class="line">            clusterHandleSlaveFailover(); <span class="comment">// 处理故障转移</span></span><br><span class="line">        <span class="keyword">if</span> (orphaned_masters &amp;&amp; max_slaves &gt;= <span class="number">2</span> &amp;&amp; this_slaves == max_slaves &amp;&amp;</span><br><span class="line">        server.cluster_allow_replica_migration)</span><br><span class="line">            clusterHandleSlaveMigration(max_slaves);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下线（FAIL）"><a href="#下线（FAIL）" class="headerlink" title="下线（FAIL）"></a>下线（FAIL）</h4><p>当前节点认为某个node下线时，会将node状态置为<code>CLUSTER_NODE_PFAIL</code>疑似下线状态，在定时向集群中的节点交换信息也就是发送PING消息时，消息体中记录了node的下线状态，其他节点在处理收到的PING消息时，<strong>会将认为node节点下线的那个节点加入到node的下线链表fail_reports中，并调用<code>markNodeAsFailingIfNeeded</code>函数判断是否有必要将节点置为下线FAIL状态</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterProcessGossipSection</span><span class="params">(clusterMsg *hdr, clusterLink *link)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> count = ntohs(hdr-&gt;count);</span><br><span class="line">    <span class="comment">// 获取clusterMsgDataGossip数据</span></span><br><span class="line">    clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr-&gt;data.ping.gossip;</span><br><span class="line">    <span class="comment">// 发送消息的节点</span></span><br><span class="line">    clusterNode *sender = link-&gt;node ? link-&gt;node : clusterLookupNode(hdr-&gt;sender);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(count--) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 根据nodename查找节点，node指向当前收到消息节点中维护的节点*/</span></span><br><span class="line">        node = clusterLookupNode(g-&gt;nodename);</span><br><span class="line">        <span class="comment">// 如果节点已知</span></span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            <span class="comment">/* 如果发送者是主节点 */</span></span><br><span class="line">            <span class="keyword">if</span> (sender &amp;&amp; nodeIsMaster(sender) &amp;&amp; node != myself) &#123;</span><br><span class="line">                <span class="comment">// 如果gossip节点是FAIL或者PFAIL状态</span></span><br><span class="line">                <span class="keyword">if</span> (flags &amp; (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &#123;</span><br><span class="line">                    <span class="comment">// 将sender加入到node节点的下线链表fail_reports中</span></span><br><span class="line">                    <span class="keyword">if</span> (clusterNodeAddFailureReport(node,sender)) &#123;</span><br><span class="line">                        serverLog(LL_VERBOSE,</span><br><span class="line">                            <span class="string">"Node %.40s reported node %.40s as not reachable."</span>,</span><br><span class="line">                            sender-&gt;name, node-&gt;name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 判断是否需要将节点置为下线</span></span><br><span class="line">                    markNodeAsFailingIfNeeded(node);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 校验sender是否在下线节点链表fail_reports中，如果在需要移除恢复在线状态</span></span><br><span class="line">                    <span class="keyword">if</span> (clusterNodeDelFailureReport(node,sender)) &#123;</span><br><span class="line">                        serverLog(LL_VERBOSE,</span><br><span class="line">                            <span class="string">"Node %.40s reported node %.40s is back online."</span>,</span><br><span class="line">                            sender-&gt;name, node-&gt;name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果节点未知</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 遍历下一个节点 */</span></span><br><span class="line">        g++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>markNodeAsFailingIfNeeded</strong></p>
<p>markNodeAsFailingIfNeeded用于判断是否有必要将某个节点标记为FAIL状态：</p>
<ol>
<li>计算quorum，为集群节点个数一半 + 1，记为<code>needed_quorum</code></li>
<li>如果节点已经被置为FAIL状态，直接返回即可</li>
<li>调用<code>clusterNodeFailureReportsCount</code>函数，获取节点下线链表<code>node-&gt;fail_reports</code>中元素的个数，<code>node-&gt;fail_reports</code>链表中记录了认为<code>node</code>下线的节点个数，节点个数记为<code>failures</code></li>
<li>如果当前节点是主节点，<code>failures</code>增1，表示当前节点也认为<code>node</code>需要置为下线状态</li>
<li>判断是否有过半的节点认同节点下线，也就是<code>failures</code>大于等于<code>needed_quorum</code>，如果没有过半的节点认同<code>node</code>需要下线，直接返回即可</li>
<li>如果<strong>有过半的节点认同<code>node</code>需要下线，此时取消节点的疑似下线标记PFAIL状态，将节点置为FAIL状态</strong></li>
<li>在集群中广播节点的下线消息，以便让其他节点知道该节点已经下线</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markNodeAsFailingIfNeeded</span><span class="params">(clusterNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> failures;</span><br><span class="line">    <span class="comment">// 计算quorum，为集群节点个数一半 + 1</span></span><br><span class="line">    <span class="keyword">int</span> needed_quorum = (server.cluster-&gt;size / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nodeTimedOut(node)) <span class="keyword">return</span>; <span class="comment">/* We can reach it. */</span></span><br><span class="line">    <span class="comment">// 如果节点已经处于下线状态</span></span><br><span class="line">    <span class="keyword">if</span> (nodeFailed(node)) <span class="keyword">return</span>; <span class="comment">/* Already FAILing. */</span></span><br><span class="line">    <span class="comment">// 从失败报告中获取认为节点已经下线的节点数量</span></span><br><span class="line">    failures = clusterNodeFailureReportsCount(node);</span><br><span class="line">    <span class="comment">/* 如果当前节点是主节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(myself)) failures++; <span class="comment">// 认定下线的节点个数+1</span></span><br><span class="line">    <span class="comment">// 如果没有过半的节点认同节点下线，返回即可</span></span><br><span class="line">    <span class="keyword">if</span> (failures &lt; needed_quorum) <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">        <span class="string">"Marking node %.40s as failing (quorum reached)."</span>, node-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 标记节点下线 */</span></span><br><span class="line">    <span class="comment">// 取消CLUSTER_NODE_PFAIL状态</span></span><br><span class="line">    node-&gt;flags &amp;= ~CLUSTER_NODE_PFAICLUSTER_NODE_PFAIL;</span><br><span class="line">    <span class="comment">// 设置为下线状态</span></span><br><span class="line">    node-&gt;flags |= CLUSTER_NODE_FAIL;</span><br><span class="line">    node-&gt;fail_time = mstime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 广播下线消息到集群中的节点,以便让其他节点知道该节点已经下线 */</span></span><br><span class="line">    clusterSendFail(node-&gt;name);</span><br><span class="line">    clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回下线报告链表中*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterNodeFailureReportsCount</span><span class="params">(clusterNode *node)</span> </span>&#123;</span><br><span class="line">    clusterNodeCleanupFailureReports(node);</span><br><span class="line">    <span class="comment">// 返回认为node下线的节点个数</span></span><br><span class="line">    <span class="keyword">return</span> listLength(node-&gt;fail_reports);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/下线.jpg" alt=""></p>
<h3 id="故障转移处理"><a href="#故障转移处理" class="headerlink" title="故障转移处理"></a>故障转移处理</h3><p><strong>clusterHandleSlaveFailover</strong></p>
<p>由上面的内容可知，节点客观下线时会被置为<code>CLUSTER_NODE_FAIL</code>状态，下次执行集群定时任务时，在故障转移处理函数<code>clusterHandleSlaveFailover</code>中，就可以根据状态来检查是否需要执行故障转移。</p>
<p>不过在看<code>clusterHandleSlaveFailover</code>函数之前，先看一下<code>clusterState</code>中和选举以及故障切换相关的变量定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mstime_t</span> failover_auth_time; <span class="comment">/* 发起选举的时间 */</span></span><br><span class="line">    <span class="keyword">int</span> failover_auth_count;    <span class="comment">/* 目前为止收到投票的数量 */</span></span><br><span class="line">    <span class="keyword">int</span> failover_auth_sent;     <span class="comment">/* 是否发起了投票，如果已经发起，值大于0 */</span></span><br><span class="line">    <span class="keyword">int</span> failover_auth_rank;     <span class="comment">/* 从节点排名 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> failover_auth_epoch; <span class="comment">/* 当前选举的纪元 */</span></span><br><span class="line">    <span class="keyword">int</span> cant_failover_reason;   <span class="comment">/* 从节点不能执行故障转移的原因 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> mf_end;            <span class="comment">/* 手动执行故障转移时间限制，如果未设置值为0 */</span></span><br><span class="line">    clusterNode *mf_slave;      <span class="comment">/* 执行手动故障切换的从节点 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<p><strong>clusterHandleSlaveFailover函数中的一些变量</strong></p>
<p><code>data_age</code>：<strong>记录从节点最近一次与主节点进行数据同步的时间</strong>。如果与主节点处于连接状态，用当前时间减去最近一次与master节点交互的时间，否则使用当前时间减去与master主从复制中断的时间。</p>
<p><code>auth_age</code>：<strong>当前时间减去发起选举的时间</strong>，也就是距离发起选举过去了多久，用于判断选举超时、是否重新发起选举使用。</p>
<p><code>needed_quorum</code>：<strong>quorum的数量，为集群中节点的数量的一半再加1</strong>。</p>
<p><code>auth_timeout</code>：<strong>等待投票超时时间。</strong></p>
<p><code>auth_retry_time</code>：<strong>等待重新发起选举进行投票的时间，也就是重试时间</strong>。</p>
<h4 id="发起选举"><a href="#发起选举" class="headerlink" title="发起选举"></a>发起选举</h4><p><strong>一、故障转移条件检查</strong></p>
<p>首先进行了一些条件检查，用于判断是否有必要执行故障转移，如果<strong>处于以下几个条件之一，将会跳出函数，结束故障转移处理</strong>：</p>
<ol>
<li><p><strong>当前节点<code>myself</code>是master节点</strong>，因为如果需要进行故障转移一般是master节点被标记为下线，需要从它所属的从节点中选举节点作为新的master节点，这个需要从节点发起选举，所以如果当前节点是主节点，不满足进行故障转移的条件。</p>
</li>
<li><p>当前节点<code>myself</code>所属的主节点为空</p>
</li>
<li><p><strong>当前节点<code>myself</code>所属主节点不处于客观下线状态并且不是手动进行故障转移，可以看到这里使用的是<code>CLUSTER_NODE_FAIL</code>状态来判断的</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nodeFailed(n) ((n)-&gt;flags &amp; CLUSTER_NODE_FAIL)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果开启了不允许从节点执行故障切换并且当前不是手动进行故障转移</p>
</li>
<li><p>当前节点<code>myself</code>所属主节点负责的slot数量为0</p>
</li>
</ol>
<p><strong>二、主从复制进度校验</strong></p>
<p><code>cluster_slave_validity_factor</code>设置了故障切换最大主从复制延迟时间因子，如果不为0需要校验主从复制延迟时间是否符合要求。</p>
<p>如果主从复制延迟时间<code>data_age</code>大于 <code>mater向从节点发送PING消息的周期 + 超时时间 * 故障切换主从复制延迟时间因子</code>并且不是手动执行故障切换，表示主从复制延迟过大，不能进行故障切换终止执行。</p>
<p><strong>三、是否需要重新发起选举</strong></p>
<p>如果距离上次发起选举的时间大于超时重试时间，表示可以重新发起投票。</p>
<ol>
<li><p><strong>设置本轮选举发起时间，并没有直接使用当前时间，而是使用了当前时间 + 500毫秒 + 随机值（0到500毫秒之间）进行了一个延迟，以便让上一次失败的消息尽快传播。</strong></p>
</li>
<li><p>重置获取的投票数量<code>failover_auth_count</code>和是否已经发起选举<code>failover_auth_sent</code>为0，等待下一次执行<code>clusterHandleSlaveFailover</code>函数时重新发起投票。</p>
</li>
<li><p>获取当前节点在所属主节点的所有从节点中的等级排名，再次更新发起选举时间，加上当前节点的rank * 1000，<strong>以便让等级越低（rank值越高）的节点，越晚发起选举，降低选举的优先级。</strong></p>
<blockquote>
<p>注意这里并没有恢复<code>CLUSTER_TODO_HANDLE_FAILOVER</code>状态，因为发起投票的入口是在集群定时任务<code>clusterCron</code>函数中，所以不需要恢复。</p>
</blockquote>
</li>
<li><p>如果是手动进行故障转移，不需要设置延迟时间，直接使用当前时间，rank设置为0，然后将状态置为<code>CLUSTER_TODO_HANDLE_FAILOVER</code>，在下一次执行<code>beforeSleep</code>函数时，重新进行故障转移。</p>
</li>
<li><p>向集群中广播消息并终止执行本次故障切换。</p>
</li>
</ol>
<p><strong>四、延迟发起选举</strong></p>
<ol>
<li>如果还未发起选举投票，节点等级有可能在变化，所以此时需要更新等级以及发起投票的延迟时间。</li>
<li>如果当前时间小于设置的选举发起时间，需要延迟发起选举，直接返回，等待下一次执行。</li>
<li>如果距离发起选举的时间大于超时时间，表示本次选举已超时，直接返回。</li>
</ol>
<p><strong>五、发起投票</strong></p>
<p>如果满足执行故障的条件，接下来需从节点想集群中的其他节点广播消息，发起投票，不过只有主节点才有投票权。<code>failover_auth_sent</code>为0表示还未发起投票，此时开始发起投票：</p>
<ol>
<li>更新节点当前的投票纪元（轮次）<code>currentEpoch</code>，对其进行增1操作</li>
<li>设置本次选举的投票纪元（轮次）<code>failover_auth_epoch</code>，与<code>currentEpoch</code>一致</li>
<li>向集群广播，<strong>发送CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息到其他节点进行投票</strong></li>
<li><code>failover_auth_sent</code>置为1 ，表示已经发起了投票</li>
<li>发起投票后，直接返回，等待其他节点的投票。</li>
</ol>
<p><strong>六、执行故障切换</strong></p>
<p>当某个节点获取到了集群中大多数节点的投票，即可进行故障切换，这里先不关注，在后面的章节会讲。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterHandleSlaveFailover</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主从复制延迟时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> data_age;</span><br><span class="line">    <span class="comment">// 当前时间减去发起选举的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> auth_age = mstime() - server.cluster-&gt;failover_auth_time;</span><br><span class="line">    <span class="comment">// 计算quorum的数量，为集群中节点的数量的一半再加1</span></span><br><span class="line">    <span class="keyword">int</span> needed_quorum = (server.cluster-&gt;size / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 是否手动执行故障转移</span></span><br><span class="line">    <span class="keyword">int</span> manual_failover = server.cluster-&gt;mf_end != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                          server.cluster-&gt;mf_can_start;</span><br><span class="line">    <span class="comment">// 等待投票超时时间，等待重试时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> auth_timeout, auth_retry_time;</span><br><span class="line">    <span class="comment">// 取消CLUSTER_TODO_HANDLE_FAILOVER状态</span></span><br><span class="line">    server.cluster-&gt;todo_before_sleep &amp;= ~CLUSTER_TODO_HANDLE_FAILOVER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待投票超时时间为集群中设置的超时时间的2倍</span></span><br><span class="line">    auth_timeout = server.cluster_node_timeout*<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 如果等待投票超时的时间小于2000毫秒，设置为2000毫秒，也就是超时时间最少为2000毫秒</span></span><br><span class="line">    <span class="keyword">if</span> (auth_timeout &lt; <span class="number">2000</span>) auth_timeout = <span class="number">2000</span>;</span><br><span class="line">    <span class="comment">// 等待重试时间为超时时间的2倍</span></span><br><span class="line">    auth_retry_time = auth_timeout*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 校验故障转移条件，处于以下条件之一不满足故障切换条件，跳出函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(myself) || <span class="comment">// myself是主节点</span></span><br><span class="line">        myself-&gt;slaveof == <span class="literal">NULL</span> || <span class="comment">// myself是从节点但是所属主节点为空</span></span><br><span class="line">        (!nodeFailed(myself-&gt;slaveof) &amp;&amp; !manual_failover) || <span class="comment">// 所属主节点不处于下线状态并且不是手动进行故障转移</span></span><br><span class="line">        (server.cluster_slave_no_failover &amp;&amp; !manual_failover) || <span class="comment">// 如果不允许从节点执行故障切换并且不是手动进行故障转移</span></span><br><span class="line">        myself-&gt;slaveof-&gt;numslots == <span class="number">0</span>) <span class="comment">// 所属主节点负责的slot数量为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 不进行故障切换 */</span></span><br><span class="line">        server.cluster-&gt;cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果主从复制状态为连接状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECTED) &#123;</span><br><span class="line">        <span class="comment">// 设置距离最近一次复制数据的时间，由于和master节点还处于连接状态，使用当前时间减去最近一次与master节点交互的时间</span></span><br><span class="line">        data_age = (<span class="keyword">mstime_t</span>)(server.unixtime - server.master-&gt;lastinteraction)</span><br><span class="line">                   * <span class="number">1000</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他状态时</span></span><br><span class="line">        <span class="comment">// 使用当前时间减去与master主从复制中断的时间</span></span><br><span class="line">        data_age = (<span class="keyword">mstime_t</span>)(server.unixtime - server.repl_down_since) * <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果data_age大于超时时间，减去超时时间 */</span></span><br><span class="line">    <span class="keyword">if</span> (data_age &gt; server.cluster_node_timeout)</span><br><span class="line">        data_age -= server.cluster_node_timeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cluster_slave_validity_factor设置了故障切换最大主从复制延迟时间因子，如果不为0需要校验主从复制延迟时间是否符合要求 */</span></span><br><span class="line">    <span class="comment">/* 如果主从复制延迟时间 大于(master向从节点发送PING消息的周期 + 超时时间 * 故障切换主从复制延迟时间因子) ，表示主从复制延迟过大，不能进行故障切换 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_slave_validity_factor &amp;&amp;</span><br><span class="line">        data_age &gt;</span><br><span class="line">        (((<span class="keyword">mstime_t</span>)server.repl_ping_slave_period * <span class="number">1000</span>) +</span><br><span class="line">         (server.cluster_node_timeout * server.cluster_slave_validity_factor)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果不是手动执行故障切换</span></span><br><span class="line">        <span class="keyword">if</span> (!manual_failover) &#123;</span><br><span class="line">            <span class="comment">// 设置不能执行故障切换的原因，主从复制进度不符合要求</span></span><br><span class="line">            clusterLogCantFailover(CLUSTER_CANT_FAILOVER_DATA_AGE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果距离上次发起选举的时间大于超时重试时间，表示可以重新发起投票 */</span></span><br><span class="line">    <span class="keyword">if</span> (auth_age &gt; auth_retry_time) &#123;</span><br><span class="line">        <span class="comment">// 设置本轮选举发起时间，使用了当前时间 + 500毫秒 + 随机值（0到500毫秒之间），以便让上一次失败的消息尽快传播</span></span><br><span class="line">        server.cluster-&gt;failover_auth_time = mstime() +</span><br><span class="line">            <span class="number">500</span> + </span><br><span class="line">            random() % <span class="number">500</span>; </span><br><span class="line">        <span class="comment">// 初始化获取的投票数量</span></span><br><span class="line">        server.cluster-&gt;failover_auth_count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化failover_auth_sent为0</span></span><br><span class="line">        server.cluster-&gt;failover_auth_sent = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取当前节点的等级</span></span><br><span class="line">        server.cluster-&gt;failover_auth_rank = clusterGetSlaveRank();</span><br><span class="line">        <span class="comment">// 再次更新发起选举时间，加上当前节点的rank * 1000，以便让等级越低的节点，越晚发起选举，降低选举的优先级</span></span><br><span class="line">        server.cluster-&gt;failover_auth_time +=</span><br><span class="line">            server.cluster-&gt;failover_auth_rank * <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">/* 如果是手动进行故障转移，不需要设置延迟 */</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster-&gt;mf_end) &#123;</span><br><span class="line">            <span class="comment">// 设置发起选举时间为当前时间</span></span><br><span class="line">            server.cluster-&gt;failover_auth_time = mstime();</span><br><span class="line">            <span class="comment">// rank设置为0，等级最高</span></span><br><span class="line">            server.cluster-&gt;failover_auth_rank = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 设置CLUSTER_TODO_HANDLE_FAILOVER状态</span></span><br><span class="line">              clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Start of election delayed for %lld milliseconds "</span></span><br><span class="line">            <span class="string">"(rank #%d, offset %lld)."</span>,</span><br><span class="line">            server.cluster-&gt;failover_auth_time - mstime(),</span><br><span class="line">            server.cluster-&gt;failover_auth_rank,</span><br><span class="line">            replicationGetSlaveOffset());</span><br><span class="line">        <span class="comment">/* 广播消息 */</span></span><br><span class="line">        clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;failover_auth_sent == <span class="number">0</span> &amp;&amp; <span class="comment">// 如果还未发起选举</span></span><br><span class="line">        server.cluster-&gt;mf_end == <span class="number">0</span>) <span class="comment">// 如果不是手动执行故障转移</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取节点等级，节点等级有可能在变化，需要更新等级</span></span><br><span class="line">        <span class="keyword">int</span> newrank = clusterGetSlaveRank();</span><br><span class="line">        <span class="comment">// 如果排名大于之前设置的等级</span></span><br><span class="line">        <span class="keyword">if</span> (newrank &gt; server.cluster-&gt;failover_auth_rank) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> added_delay =</span><br><span class="line">                (newrank - server.cluster-&gt;failover_auth_rank) * <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">// 更新发起选举时间</span></span><br><span class="line">            server.cluster-&gt;failover_auth_time += added_delay;</span><br><span class="line">            <span class="comment">// 更新节点等级</span></span><br><span class="line">            server.cluster-&gt;failover_auth_rank = newrank;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Replica rank updated to #%d, added %lld milliseconds of delay."</span>,</span><br><span class="line">                newrank, added_delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前时间小于设置的选举发起时间，需要延迟发起选举 */</span></span><br><span class="line">    <span class="keyword">if</span> (mstime() &lt; server.cluster-&gt;failover_auth_time) &#123;</span><br><span class="line">        <span class="comment">// 记录延迟发起选举日志</span></span><br><span class="line">        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_DELAY);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果距离发起选举的时间大于超时时间，表示已超时 */</span></span><br><span class="line">    <span class="keyword">if</span> (auth_age &gt; auth_timeout) &#123;</span><br><span class="line">        <span class="comment">// 记录选举已过期日志</span></span><br><span class="line">        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_EXPIRED);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果failover_auth_sent为0表示还未发起投票 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;failover_auth_sent == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 纪元加1</span></span><br><span class="line">        server.cluster-&gt;currentEpoch++;</span><br><span class="line">        <span class="comment">// 设置当前选举纪元failover_auth_epoch</span></span><br><span class="line">        server.cluster-&gt;failover_auth_epoch = server.cluster-&gt;currentEpoch;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Starting a failover election for epoch %llu."</span>,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;currentEpoch);</span><br><span class="line">        <span class="comment">// 广播发送CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，发起投票</span></span><br><span class="line">        clusterRequestFailoverAuth();</span><br><span class="line">        <span class="comment">// failover_auth_sent置为1 ，表示已经发起了投票</span></span><br><span class="line">        server.cluster-&gt;failover_auth_sent = <span class="number">1</span>;</span><br><span class="line">        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|</span><br><span class="line">                             CLUSTER_TODO_UPDATE_STATE|</span><br><span class="line">                             CLUSTER_TODO_FSYNC_CONFIG);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* Wait for replies. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 校验是否获取了大多数的投票，执行故障切换 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;failover_auth_count &gt;= needed_quorum) &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送FAILOVER_AUTH_REQUEST消息到每个节点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterRequestFailoverAuth</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    clusterMsg buf[<span class="number">1</span>];</span><br><span class="line">    clusterMsg *hdr = (clusterMsg*) buf;</span><br><span class="line">    <span class="keyword">uint32_t</span> totlen;</span><br><span class="line">    <span class="comment">// 设置消息头，发送CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息</span></span><br><span class="line">    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST);</span><br><span class="line">    <span class="comment">/* 如果是手动转移，设置CLUSTERMSG_FLAG0_FORCEACK标记 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;mf_end) hdr-&gt;mflags[<span class="number">0</span>] |= CLUSTERMSG_FLAG0_FORCEACK;</span><br><span class="line">    totlen = <span class="keyword">sizeof</span>(clusterMsg)-<span class="keyword">sizeof</span>(<span class="keyword">union</span> clusterMsgData);</span><br><span class="line">    hdr-&gt;totlen = htonl(totlen);</span><br><span class="line">    <span class="comment">// 发送广播</span></span><br><span class="line">    clusterBroadcastMessage(buf,totlen);</span><br></pre></td></tr></table></figure>
<p><img src="/images/故障处理.jpg" alt=""></p>
<h4 id="获取节点等级"><a href="#获取节点等级" class="headerlink" title="获取节点等级"></a>获取节点等级</h4><p>clusterGetSlaveRank用于计算当前节点的等级，遍历所属主节点的所有从节点，根据主从复制进度<code>repl_offset</code>计算，<code>repl_offset</code>值越大表示复制主节点的数据越多，所以等级越高，对应的<code>rank</code>值就越低。</p>
<p><strong>从节点在发起选举使用了<code>rank</code>的值作为延迟时间，值越低延迟时间越小，意味着选举优先级也就越高。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterGetSlaveRank</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> myoffset;</span><br><span class="line">    <span class="comment">// rank初始化为0</span></span><br><span class="line">    <span class="keyword">int</span> j, rank = <span class="number">0</span>;</span><br><span class="line">    clusterNode *master;</span><br><span class="line">    serverAssert(nodeIsSlave(myself));</span><br><span class="line">    <span class="comment">// 获取当前节点所属的主节点</span></span><br><span class="line">    master = myself-&gt;slaveof;</span><br><span class="line">    <span class="keyword">if</span> (master == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 返回0 */</span></span><br><span class="line">    <span class="comment">// 获取主从复制进度</span></span><br><span class="line">    myoffset = replicationGetSlaveOffset();</span><br><span class="line">    <span class="comment">// 变量master的所有从节点</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; master-&gt;numslaves; j++)</span><br><span class="line">        <span class="comment">// 如果不是当前节点、节点可以用来执行故障切换并且节点的复制进度大于当前节点的进度</span></span><br><span class="line">        <span class="keyword">if</span> (master-&gt;slaves[j] != myself &amp;&amp;</span><br><span class="line">            !nodeCantFailover(master-&gt;slaves[j]) &amp;&amp; </span><br><span class="line">            master-&gt;slaves[j]-&gt;repl_offset &gt; myoffset) rank++; <span class="comment">// 将当前节点的排名后移，等级越低</span></span><br><span class="line">    <span class="keyword">return</span> rank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主节点进行投票"><a href="#主节点进行投票" class="headerlink" title="主节点进行投票"></a>主节点进行投票</h3><p>当从节点认为主节点故障需要发起投票，重新选举主节点时，在集群中广播了<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code>消息，对应的处理在<code>clusterProcessPacket</code>函数中，里面会调用<code>clusterSendFailoverAuthIfNeeded</code>函数进行投票：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterProcessPacket</span><span class="params">(clusterLink *link)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* PING, PONG, MEET消息处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG ||</span><br><span class="line">        type == CLUSTERMSG_TYPE_MEET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST) &#123;<span class="comment">// 处理CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息</span></span><br><span class="line">        <span class="keyword">if</span> (!sender) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        <span class="comment">// 进行投票,sender为发送消息的节点，hdr为请求体</span></span><br><span class="line">        clusterSendFailoverAuthIfNeeded(sender,hdr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>clusterSendFailoverAuthIfNeeded</strong></p>
<p>clusterSendFailoverAuthIfNeeded函数用于进行投票，处理逻辑如下：</p>
<ol>
<li><strong>由于只有主节点才可以投票，如果当前节点不是主节点或者当前节点中负责slot的个数为0，当前节点没有权限投票，直接返回</strong>。</li>
<li>需要保证发起请求的投票轮次要等于或者大于当前节点中记录的轮次，所以如果请求的纪元（轮次）小于当前节点中记录的纪元（轮次） ，直接返回。</li>
<li>如果当前节点中记录的上次投票的纪元（轮次）等于当前投票纪元（轮次），表示当前节点已经投过票，直接返回。</li>
<li>如果发起请求的节点是主节点或者发起请求的节点所属的主节点为空，或者主节点不处于下线状态并且不是手动执行故障转移，直接返回。</li>
<li>如果当前时间减去节点投票时间<code>node-&gt;slaveof-&gt;voted_time</code>小于超时时间的2倍，直接返回。<strong><code>node-&gt;slaveof-&gt;voted_time</code>记录了当前节点的投票时间，在未超过2倍超时时间之前不进行投票。</strong></li>
<li>处理slot，需要保证当前节点中记录的slot的纪元小于等于请求纪元，如果不满足此条件，终止投票，直接返回。</li>
</ol>
<p>以上条件校验通过，<strong>表示当前节点可以投票给发送请求的节点，此时更新<code>lastVoteEpoch</code>，记录最近一次投票的纪元（轮次），更新投票时间<code>node-&gt;slaveof-&gt;voted_time</code>，然后向发起请求的节点回复<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterSendFailoverAuthIfNeeded</span><span class="params">(clusterNode *node, clusterMsg *request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发起请求的节点所属主节点</span></span><br><span class="line">    clusterNode *master = node-&gt;slaveof;</span><br><span class="line">    <span class="comment">// 从请求中获取投票纪元（轮次）</span></span><br><span class="line">    <span class="keyword">uint64_t</span> requestCurrentEpoch = ntohu64(request-&gt;currentEpoch);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">uint64_t</span> requestConfigEpoch = ntohu64(request-&gt;configEpoch);</span><br><span class="line">    <span class="comment">// 从请求中获取节点负责的slot</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *claimed_slots = request-&gt;myslots;</span><br><span class="line">    <span class="comment">// 是否是手动故障执行故障转移</span></span><br><span class="line">    <span class="keyword">int</span> force_ack = request-&gt;mflags[<span class="number">0</span>] &amp; CLUSTERMSG_FLAG0_FORCEACK;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前节点不是主节点或者当前节点中负责slot的个数为0，当前节点没有权限投票，直接返回*/</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsSlave(myself) || myself-&gt;numslots == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果请求的纪元（轮次）小于当前节点中记录的纪元（轮次） */</span></span><br><span class="line">    <span class="keyword">if</span> (requestCurrentEpoch &lt; server.cluster-&gt;currentEpoch) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Failover auth denied to %.40s: reqEpoch (%llu) &lt; curEpoch(%llu)"</span>,</span><br><span class="line">            node-&gt;name,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) requestCurrentEpoch,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;currentEpoch);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前节点中记录的上次投票的纪元等于当前纪元，表示当前节点已经投过票，直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;lastVoteEpoch == server.cluster-&gt;currentEpoch) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failover auth denied to %.40s: already voted for epoch %llu"</span>,</span><br><span class="line">                node-&gt;name,</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;currentEpoch);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果发起请求的节点是主节点或者发起请求的节点所属的主节点为空，或者主节点不处于下线状态并且不是手动执行故障转移，直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(node) || master == <span class="literal">NULL</span> ||</span><br><span class="line">        (!nodeFailed(master) &amp;&amp; !force_ack))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeIsMaster(node)) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"Failover auth denied to %.40s: it is a master node"</span>,</span><br><span class="line">                    node-&gt;name);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (master == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"Failover auth denied to %.40s: I don't know its master"</span>,</span><br><span class="line">                    node-&gt;name);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!nodeFailed(master)) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"Failover auth denied to %.40s: its master is up"</span>,</span><br><span class="line">                    node-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前时间减去投票时间小于超时时间的2倍，直接返回 */</span></span><br><span class="line">    <span class="comment">/* node-&gt;slaveof-&gt;voted_time记录了当前节点的投票时间，在未过2倍超时时间之前，不进行投票 */</span></span><br><span class="line">    <span class="keyword">if</span> (mstime() - node-&gt;slaveof-&gt;voted_time &lt; server.cluster_node_timeout * <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failover auth denied to %.40s: "</span></span><br><span class="line">                <span class="string">"can't vote about this master before %lld milliseconds"</span>,</span><br><span class="line">                node-&gt;name,</span><br><span class="line">                (<span class="keyword">long</span> <span class="keyword">long</span>) ((server.cluster_node_timeout*<span class="number">2</span>)-</span><br><span class="line">                             (mstime() - node-&gt;slaveof-&gt;voted_time)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 处理slot，需要保证当前节点中记录的slot的纪元小于等于请求纪元 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CLUSTER_SLOTS; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的slot不在发起请求节点负责的slot中，继续下一个</span></span><br><span class="line">        <span class="keyword">if</span> (bitmapTestBit(claimed_slots, j) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果当前节点不负责此slot或者slot中记录的纪元小于等于请求纪元，继续下一个</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster-&gt;slots[j] == <span class="literal">NULL</span> ||</span><br><span class="line">            server.cluster-&gt;slots[j]-&gt;configEpoch &lt;= requestConfigEpoch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failover auth denied to %.40s: "</span></span><br><span class="line">                <span class="string">"slot %d epoch (%llu) &gt; reqEpoch (%llu)"</span>,</span><br><span class="line">                node-&gt;name, j,</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;slots[j]-&gt;configEpoch,</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) requestConfigEpoch);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 走到这里表示可以投票给从节点 */</span></span><br><span class="line">    <span class="comment">/* 将当前节点的lastVoteEpoch设置为currentEpoch */</span></span><br><span class="line">    server.cluster-&gt;lastVoteEpoch = server.cluster-&gt;currentEpoch;</span><br><span class="line">    <span class="comment">/* 更新投票时间 */</span></span><br><span class="line">    node-&gt;slaveof-&gt;voted_time = mstime();</span><br><span class="line">    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_FSYNC_CONFIG);</span><br><span class="line">    <span class="comment">/* 发送CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息 */</span></span><br><span class="line">    clusterSendFailoverAuth(node);</span><br><span class="line">    serverLog(LL_WARNING, <span class="string">"Failover auth granted to %.40s for epoch %llu"</span>,</span><br><span class="line">        node-&gt;name, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;currentEpoch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息到指定节点. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterSendFailoverAuth</span><span class="params">(clusterNode *node)</span> </span>&#123;</span><br><span class="line">    clusterMsg buf[<span class="number">1</span>];</span><br><span class="line">    clusterMsg *hdr = (clusterMsg*) buf;</span><br><span class="line">    <span class="keyword">uint32_t</span> totlen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;link) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 设置请求体，发送CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息</span></span><br><span class="line">    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK);</span><br><span class="line">    totlen = <span class="keyword">sizeof</span>(clusterMsg)-<span class="keyword">sizeof</span>(<span class="keyword">union</span> clusterMsgData);</span><br><span class="line">    hdr-&gt;totlen = htonl(totlen);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    clusterSendMessage(node-&gt;link,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,totlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="投票回复消息处理"><a href="#投票回复消息处理" class="headerlink" title="投票回复消息处理"></a>投票回复消息处理</h3><p>主节点对发起投票请求节点的回复消息<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>同样在消息处理函数<code>clusterProcessPacket</code>中，会对发送回复消息的节点进行验证：</p>
<ol>
<li>发送者是主节点</li>
<li>发送者负责的slot数量大于0</li>
<li>发送者记录的投票纪元（轮次）大于或等于当前节点发起故障转移投票的轮次</li>
</ol>
<p>同时满足以上三个条件时，<strong>表示发送者对当前节点进行了投票，更新当前节点记录的收到投票的个数，<code>failover_auth_count</code>加1，此时有可能获取了大多数节点的投票，先调用<code>clusterDoBeforeSleep</code>设置一个<code>CLUSTER_TODO_HANDLE_FAILOVER</code>标记，在周期执行的时间事件中会调用对状态进行判断决定是否执行故障转移。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterProcessPacket</span><span class="params">(clusterLink *link)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* PING, PONG, MEET: process config information. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG ||</span><br><span class="line">        type == CLUSTERMSG_TYPE_MEET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 省略其他else if </span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST) &#123; <span class="comment">// 处理CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息</span></span><br><span class="line">        <span class="keyword">if</span> (!sender) <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        clusterSendFailoverAuthIfNeeded(sender,hdr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK) &#123; <span class="comment">// 处理CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息</span></span><br><span class="line">        <span class="keyword">if</span> (!sender) <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        <span class="comment">/* 如果发送者是主节点并且负责的slot数量大于0，并且CurrentEpoch大于或等于当前节点的failover_auth_epoch*/</span></span><br><span class="line">        <span class="keyword">if</span> (nodeIsMaster(sender) &amp;&amp; sender-&gt;numslots &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            senderCurrentEpoch &gt;= server.cluster-&gt;failover_auth_epoch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 当前节点的failover_auth_count加1 */</span></span><br><span class="line">            server.cluster-&gt;failover_auth_count++;</span><br><span class="line">            <span class="comment">/* 有可能获取了大多数节点的投票，先设置一个CLUSTER_TODO_HANDLE_FAILOVER标记 */</span></span><br><span class="line">            clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 省略其他else if </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterDoBeforeSleep</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line">    server.cluster-&gt;todo_before_sleep |= flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/投票.jpg" alt=""></p>
<h3 id="等待处理故障转移"><a href="#等待处理故障转移" class="headerlink" title="等待处理故障转移"></a>等待处理故障转移</h3><p>从节点收到投票后，会添加<code>CLUSTER_TODO_HANDLE_FAILOVER</code>标记，接下来看下对<code>CLUSTER_TODO_HANDLE_FAILOVER</code>状态的处理。</p>
<p>在<code>beforeSleep</code>函数（server.c文件中），如果开启了集群，会调用<code>clusterBeforeSleep</code>函数，里面就包含了对<code>CLUSTER_TODO_HANDLE_FAILOVER</code>状态的处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">     <span class="comment">/* 如果开启了集群，调用clusterBeforeSleep函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) clusterBeforeSleep();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>beforeSleep</code>函数是在Redis事件循环<code>aeMain</code>方法中被调用的，详细内容可参考<a href="https://www.cnblogs.com/shanml/p/16188250.html" target="_blank" rel="noopener">事件驱动框架源码分析 </a>文章。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        <span class="comment">// 调用了aeProcessEvents处理事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>clusterBeforeSleep</strong></p>
<p>在clusterBeforeSleep函数中，如果节点带有<code>CLUSTER_TODO_HANDLE_FAILOVER</code>标记，会调用<code>clusterHandleSlaveFailover</code>函数进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterBeforeSleep</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CLUSTER_TODO_HANDLE_MANUALFAILOVER) &#123; <span class="comment">// 处理CLUSTER_TODO_HANDLE_FAILOVER</span></span><br><span class="line">        <span class="comment">// 手动执行故障转移</span></span><br><span class="line">        <span class="keyword">if</span>(nodeIsSlave(myself)) &#123;</span><br><span class="line">            clusterHandleManualFailover();</span><br><span class="line">            <span class="keyword">if</span> (!(server.cluster_module_flags &amp; CLUSTER_MODULE_FLAG_NO_FAILOVER))</span><br><span class="line">                clusterHandleSlaveFailover(); <span class="comment">// 故障转移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; CLUSTER_TODO_HANDLE_FAILOVER) &#123; <span class="comment">// 如果是CLUSTER_TODO_HANDLE_FAILOVER状态</span></span><br><span class="line">        <span class="comment">/* 处理故障转移 */</span></span><br><span class="line">        clusterHandleSlaveFailover();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="故障转移处理-1"><a href="#故障转移处理-1" class="headerlink" title="故障转移处理"></a>故障转移处理</h4><p><code>clusterHandleSlaveFailover</code>函数在上面我们已经见到过，这次我们来关注集群的故障转移处理。</p>
<p>如果当前节点获取了大多数的投票，也就是<code>failover_auth_count</code>（得到的投票数量）大于等于<code>needed_quorum</code>，<code>needed_quorum</code>数量为集群中节点个数的一半+1，即可执行故障转移，接下来会调用<code>clusterFailoverReplaceYourMaster</code>函数完成故障转移。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterHandleSlaveFailover</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主从复制延迟时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> data_age;</span><br><span class="line">    <span class="comment">// 当前时间减去发起选举的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> auth_age = mstime() - server.cluster-&gt;failover_auth_time;</span><br><span class="line">    <span class="comment">// 计算quorum的数量，为集群中节点的数量的一半再加1</span></span><br><span class="line">    <span class="keyword">int</span> needed_quorum = (server.cluster-&gt;size / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 校验是否获取了大多数的投票，failover_auth_count大于等于needed_quorum，needed_quorum数量为集群中节点个数的一半+1 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;failover_auth_count &gt;= needed_quorum) &#123;</span><br><span class="line">        <span class="comment">/* 如果取得了大多数投票，从节点被选举为主节点*/</span></span><br><span class="line"></span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Failover election won: I'm the new master."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 更新configEpoch为选举纪元failover_auth_epoch */</span></span><br><span class="line">        <span class="keyword">if</span> (myself-&gt;configEpoch &lt; server.cluster-&gt;failover_auth_epoch) &#123;</span><br><span class="line">            myself-&gt;configEpoch = server.cluster-&gt;failover_auth_epoch;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"configEpoch set to %llu after successful failover"</span>,</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) myself-&gt;configEpoch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 负责master的slot */</span></span><br><span class="line">        clusterFailoverReplaceYourMaster();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行故障转移"><a href="#执行故障转移" class="headerlink" title="执行故障转移"></a>执行故障转移</h4><p><strong>clusterFailoverReplaceYourMaster</strong></p>
<p>如果从节点收到了集群中过半的投票，就可以成为新的master节点，并接手下线的master节点的slot，具体的处理在clusterFailoverReplaceYourMaster函数中，主要处理逻辑如下：</p>
<ol>
<li>将当前节点设为主节点</li>
<li>将下线的master节点负责的所有slots设置到新的主节点中</li>
<li>更新相关状态并保存设置</li>
<li>广播PONG消息到其他节点，通知其他节点当前节点成为了主节点</li>
<li>如果是手动进行故障转移，清除手动执行故障状态 </li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterFailoverReplaceYourMaster</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// 旧的主节点</span></span><br><span class="line">    clusterNode *oldmaster = myself-&gt;slaveof;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(myself) || oldmaster == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将当前节点设为主节点 */</span></span><br><span class="line">    clusterSetNodeAsMaster(myself);</span><br><span class="line">    replicationUnsetMaster();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将下线的master节点负责的所有slots设置到新的主节点中 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CLUSTER_SLOTS; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (clusterNodeGetSlotBit(oldmaster,j)) &#123;</span><br><span class="line">            clusterDelSlot(j);</span><br><span class="line">            clusterAddSlot(myself,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新状态并保存设置*/</span></span><br><span class="line">    clusterUpdateState();</span><br><span class="line">    clusterSaveConfigOrDie(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 广播PONG消息到其他节点，通知其他节点当前节点成为了主节点 */</span></span><br><span class="line">    clusterBroadcastPong(CLUSTER_BROADCAST_ALL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是手动进行故障转移，清除状态 */</span></span><br><span class="line">    resetManualFailover();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/故障切换.jpg" alt=""></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/05/15/【Redis】Redis Cluster初始化及PING消息的发送/" rel="next" title="【Redis】Redis Cluster初始化及PING消息的发送">
                <i class="fa fa-chevron-left"></i> 【Redis】Redis Cluster初始化及PING消息的发送
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/05/26/【Redis】集群数据迁移/" rel="prev" title="【Redis】集群数据迁移">
                【Redis】集群数据迁移 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">shan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#集群故障转移"><span class="nav-number">1.</span> <span class="nav-text">集群故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#节点下线"><span class="nav-number">1.1.</span> <span class="nav-text">节点下线</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#疑似下线（PFAIL）"><span class="nav-number">1.1.1.</span> <span class="nav-text">疑似下线（PFAIL）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#下线（FAIL）"><span class="nav-number">1.1.2.</span> <span class="nav-text">下线（FAIL）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障转移处理"><span class="nav-number">1.2.</span> <span class="nav-text">故障转移处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发起选举"><span class="nav-number">1.2.1.</span> <span class="nav-text">发起选举</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取节点等级"><span class="nav-number">1.2.2.</span> <span class="nav-text">获取节点等级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主节点进行投票"><span class="nav-number">1.3.</span> <span class="nav-text">主节点进行投票</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#投票回复消息处理"><span class="nav-number">1.4.</span> <span class="nav-text">投票回复消息处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待处理故障转移"><span class="nav-number">1.5.</span> <span class="nav-text">等待处理故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#故障转移处理-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">故障转移处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行故障转移"><span class="nav-number">1.5.2.</span> <span class="nav-text">执行故障转移</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shan</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
