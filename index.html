<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="SHAN">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SHAN">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SHAN">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>SHAN</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SHAN</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/02/【Srping】事务的执行原理（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/02/【Srping】事务的执行原理（一）/" itemprop="url">【Spring】事务的执行原理（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-02T21:30:00+08:00">
                2022-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用事务的时候需要添加@EnableTransactionManagement注解来开启事务，那么就从@EnableTransactionManagement入手查看一下事务的执行原理。</p>
<p><strong>@EnableTransactionManagement</strong></p>
<ol>
<li><strong>Spring事务底层是通过AOP来完成的，而Spring AOP基于动态代理实现</strong>，可以看到mode方法默认返回了PROXY代理模式，我们只需关注代理模式下的执行流程即可</li>
<li>使用@Import导入了TransactionManagementConfigurationSelector</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(TransactionManagementConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否代理目标类</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认使用代理模式</span></span><br><span class="line">	<span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TransactionManagementConfigurationSelector</strong></p>
<p>在selectImports方法中可以看到对模式进行了判断：</p>
<ol>
<li>如果是基于代理模式，返回AutoProxyRegistrar和ProxyTransactionManagementConfiguration类</li>
<li>如果是基于ASPECTJ，调用determineTransactionAspectClass方法</li>
</ol>
<p>Spring默认使用的是代理模式，所以接下来看下AutoProxyRegistrar和ProxyTransactionManagementConfiguration里面都有什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManagementConfigurationSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableTransactionManagement</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">			<span class="keyword">case</span> PROXY:</span><br><span class="line">                <span class="comment">// 如果基于代理模式</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">						ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">			<span class="keyword">case</span> ASPECTJ:</span><br><span class="line">                <span class="comment">// 如果基于ASPECTJ</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">determineTransactionAspectClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (ClassUtils.isPresent(<span class="string">"javax.transaction.Transactional"</span>, getClass().getClassLoader()) ?</span><br><span class="line">				TransactionManagementConfigUtils.JTA_TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME :</span><br><span class="line">				TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AutoProxyRegistrar"><a href="#AutoProxyRegistrar" class="headerlink" title="AutoProxyRegistrar"></a>AutoProxyRegistrar</h2><p>AutoProxyRegistrar实现了ImportBeanDefinitionRegistrar接口，ImportBeanDefinitionRegistrar可以向容器中注册Bean，跟着registerBeanDefinitions方法看下它会向容器中注册什么样的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> candidateFound = <span class="keyword">false</span>;</span><br><span class="line">		Set&lt;String&gt; annTypes = importingClassMetadata.getAnnotationTypes();</span><br><span class="line">		<span class="keyword">for</span> (String annType : annTypes) &#123;</span><br><span class="line">			AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);</span><br><span class="line">			<span class="keyword">if</span> (candidate == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Object mode = candidate.get(<span class="string">"mode"</span>);</span><br><span class="line">			Object proxyTargetClass = candidate.get(<span class="string">"proxyTargetClass"</span>);</span><br><span class="line">			<span class="keyword">if</span> (mode != <span class="keyword">null</span> &amp;&amp; proxyTargetClass != <span class="keyword">null</span> &amp;&amp; AdviceMode.class == mode.getClass() &amp;&amp;</span><br><span class="line">					Boolean.class == proxyTargetClass.getClass()) &#123;</span><br><span class="line">				candidateFound = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (mode == AdviceMode.PROXY) &#123;</span><br><span class="line">                    <span class="comment">// 调用AopConfigUtils的registerAutoProxyCreatorIfNecessary向容器中注册bean</span></span><br><span class="line">					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">					<span class="keyword">if</span> ((Boolean) proxyTargetClass) &#123;</span><br><span class="line">						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!candidateFound &amp;&amp; logger.isInfoEnabled()) &#123;</span><br><span class="line">			String name = getClass().getSimpleName();</span><br><span class="line">			logger.info(String.format(<span class="string">"%s was imported but no annotations were found "</span> +</span><br><span class="line">					<span class="string">"having both 'mode' and 'proxyTargetClass' attributes of type "</span> +</span><br><span class="line">					<span class="string">"AdviceMode and boolean respectively. This means that auto proxy "</span> +</span><br><span class="line">					<span class="string">"creator registration and configuration may not have occurred as "</span> +</span><br><span class="line">					<span class="string">"intended, and components may not be proxied as expected. Check to "</span> +</span><br><span class="line">					<span class="string">"ensure that %s has been @Import'ed on the same class where these "</span> +</span><br><span class="line">					<span class="string">"annotations are declared; otherwise remove the import of %s "</span> +</span><br><span class="line">					<span class="string">"altogether."</span>, name, name, name));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AopConfigUtils"><a href="#AopConfigUtils" class="headerlink" title="AopConfigUtils"></a>AopConfigUtils</h3><p>在AopConfigUtils中一共有三种自动代理创建器：</p>
<ol>
<li>InfrastructureAdvisorAutoProxyCreator</li>
<li>AspectJAwareAdvisorAutoProxyCreator</li>
<li>AnnotationAwareAspectJAutoProxyCreator</li>
</ol>
<p>在registerAutoProxyCreatorIfNecessary方法中，可以看到事务使用的是InfrastructureAdvisorAutoProxyCreator类型的创建器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AopConfigUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 自动代理创建器BeanName</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTO_PROXY_CREATOR_BEAN_NAME =</span><br><span class="line">			<span class="string">"org.springframework.aop.config.internalAutoProxyCreator"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 所有的自动代理创建器集合</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="comment">// 初始化</span></span><br><span class="line">		APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">		APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class); <span class="comment">// AspectJ</span></span><br><span class="line">		APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class); <span class="comment">// 注解</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AutoProxyRegistrar中调用的registerAutoProxyCreatorIfNecessary方法</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">// 会调用下面那个registerAutoProxyCreatorIfNecessary方法</span></span><br><span class="line">		<span class="keyword">return</span> registerAutoProxyCreatorIfNecessary(registry, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用registerOrEscalateApcAsRequired进行注册，这里传入的是InfrastructureAdvisorAutoProxyCreator类型的</span></span><br><span class="line">		<span class="keyword">return</span> registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">        <span class="comment">// 判断容器中是否已经包含代理创建器</span></span><br><span class="line">		<span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">            <span class="comment">// 从容器中获取</span></span><br><span class="line">			BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">			<span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">                <span class="comment">// 判断容器中已经存在的创建器的优先级</span></span><br><span class="line">				<span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">                <span class="comment">// 需要的创建器的优先级</span></span><br><span class="line">				<span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">                <span class="comment">// 如果容器中已经存在的创建器的优先级小于需要创建的</span></span><br><span class="line">				<span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                    <span class="comment">// 使用优先级高的</span></span><br><span class="line">					apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 创建RootBeanDefinition</span></span><br><span class="line">		RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">        <span class="comment">// 设置source</span></span><br><span class="line">		beanDefinition.setSource(source);</span><br><span class="line">		beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        <span class="comment">// 注册代理创建器</span></span><br><span class="line">		registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">		<span class="keyword">return</span> beanDefinition;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>AutoProxyRegistrar实现ImportBeanDefinitionRegistrar是为了向容器中注册代理创建器，事务默认使用的是InfrastructureAdvisorAutoProxyCreator类型的。</strong></p>
<h2 id="ProxyTransactionManagementConfiguration"><a href="#ProxyTransactionManagementConfiguration" class="headerlink" title="ProxyTransactionManagementConfiguration"></a>ProxyTransactionManagementConfiguration</h2><p><strong>1. AOP概念</strong></p>
<p><strong>Advice通知：</strong>定义在切点上需要执行什么样的操作</p>
<p><strong>PointCut切点</strong>：定义在哪些方法上使用通知</p>
<p><strong>Advisor：</strong>Advice和Pointcut加起来组成了Advisor</p>
<p><strong>2. 事务中的Advisor</strong></p>
<p>我们已经知道事务是基于AOP实现的，在transactionAdvisor方法中可以看到创建了Advisor，然后设置了事务属性TransactionAttributeSource和事务拦截器TransactionInterceptor：</p>
<ul>
<li><strong>TransactionAttributeSource，从名字上可以看出是和事务的属性设置相关的</strong></li>
<li><strong>TransactionInterceptor事务拦截器相当于Advice通知</strong></li>
<li><strong>BeanFactoryTransactionAttributeSourceAdvisor是Advisor</strong></li>
</ul>
<p>Advisor由Advice和PointCut组成，现在Advice已经有了，接下来看下Pointcut在哪里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTransactionManagementConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionManagementConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span>(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span><br><span class="line">	<span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title">transactionAdvisor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Advisor</span></span><br><span class="line">		BeanFactoryTransactionAttributeSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryTransactionAttributeSourceAdvisor();</span><br><span class="line">        <span class="comment">// 设置TransactionAttributeSource，类型为AnnotationTransactionAttributeSource</span></span><br><span class="line">		advisor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">        <span class="comment">// 设置事务拦截器，相当于Advice</span></span><br><span class="line">		advisor.setAdvice(transactionInterceptor);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.enableTx != <span class="keyword">null</span>) &#123;</span><br><span class="line">			advisor.setOrder(<span class="keyword">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="string">"order"</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> advisor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TransactionAttributeSource <span class="title">transactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建AnnotationTransactionAttributeSource</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AnnotationTransactionAttributeSource();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TransactionInterceptor <span class="title">transactionInterceptor</span><span class="params">(TransactionAttributeSource transactionAttributeSource)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建事务拦截器</span></span><br><span class="line">		TransactionInterceptor interceptor = <span class="keyword">new</span> TransactionInterceptor();</span><br><span class="line">		interceptor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.txManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">			interceptor.setTransactionManager(<span class="keyword">this</span>.txManager);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> interceptor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BeanFactoryTransactionAttributeSourceAdvisor"><a href="#BeanFactoryTransactionAttributeSourceAdvisor" class="headerlink" title="BeanFactoryTransactionAttributeSourceAdvisor"></a>BeanFactoryTransactionAttributeSourceAdvisor</h2><p>BeanFactoryTransactionAttributeSourceAdvisor继承关系如下：</p>
<p><img src="/images/BeanFactoryTransactionAttributeSourceAdvisor.png" alt=""></p>
<p>除了继承父类的属性和方法，它自己还有两个成员变量：</p>
<ol>
<li>transactionAttributeSource，实际传入的是AnnotationTransactionAttributeSource类型的对象</li>
<li><strong>TransactionAttributeSourcePointcut类型的切点pointcut</strong><ul>
<li>切点在实例化时实现了getTransactionAttributeSource方法，返回了transactionAttributeSource，后面的方法中需要调用此方法获取transactionAttributeSource</li>
</ul>
</li>
</ol>
<p>由上面的分析可知，在创建BeanFactoryTransactionAttributeSourceAdvisor的时候，<strong>设置了TransactionInterceptor和TransactionAttributeSource，TransactionInterceptor相当于Advice，而这里我们看到了它还有一个TransactionAttributeSourcePointcut切点:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactoryPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> TransactionAttributeSource transactionAttributeSource; <span class="comment">// 实际传入的是AnnotationTransactionAttributeSource类型的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建切点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> TransactionAttributeSourcePointcut pointcut = <span class="keyword">new</span> TransactionAttributeSourcePointcut() &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 实现了getTransactionAttributeSource方法，返回的是AnnotationTransactionAttributeSource</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> TransactionAttributeSource <span class="title">getTransactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> transactionAttributeSource;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionAttributeSource</span><span class="params">(TransactionAttributeSource transactionAttributeSource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置TransactionAttributeSource</span></span><br><span class="line">		<span class="keyword">this</span>.transactionAttributeSource = transactionAttributeSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.pointcut;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TransactionAttributeSourcePointcut"><a href="#TransactionAttributeSourcePointcut" class="headerlink" title="TransactionAttributeSourcePointcut"></a>TransactionAttributeSourcePointcut</h3><p>TransactionAttributeSourcePointcut是一个切点，它的继承关系如下：</p>
<p><img src="/images/TransactionAttributeSourcePointcut.png" alt=""></p>
<p><strong>Pointcut</strong>和<strong>MethodMatcher</strong></p>
<p>Pointcut接口中定义了两个方法：</p>
<ol>
<li>获取ClassFilter，ClassFilter是一个接口，里面定义了matches方法，检查切点是否与类匹配</li>
<li>获取MethodMatcher，它也是一个接口，并且定义了matches方法，检查切点是否与方法匹配</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回类过滤器ClassFilter</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回MethodMatcher</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 检查方法是否匹配pointcut</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 检查方法是否匹配pointcut</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 检查类是否与pointcut匹配</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransactionAttributeSourcePointcut是Pointcut和MethodMatcher的子类：</p>
<ol>
<li>在构造函数中设置了ClassFilter，类型为TransactionAttributeSourceClassFilter，它是TransactionAttributeSourcePointcut的一个内部类，实现了ClassFilter接口中定义的matches方法，检查pointcut与类是否匹配：<ul>
<li><strong>如果是TransactionalProxy、PlatformTransactionManager或者PersistenceExceptionTranslator的子类，则不匹配</strong></li>
<li><strong>获取TransactionAttributeSource，调用它的isCandidateClass方法判断是否匹配</strong></li>
</ul>
</li>
<li>实现了MethodMatcher接口中定义的matches方法，检查pointcut是否匹配当前的方法<ul>
<li><strong>获取TransactionAttributeSource判断是否为空，如果不为空则调用getTransactionAttribute获取事务属性，TransactionAttributeSource为空，或者从TransactionAttributeSource获取到的事务属性不为空都会返回true</strong></li>
</ul>
</li>
</ol>
<p><strong>所以一个方法执行时开启事务，需要满足两个条件，当前的方法和类都需要与事务的pointcut匹配，对应的方法分别是MethodMatcher的matches和ClassFilter的matches方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAttributeSourcePointcut</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcut</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">TransactionAttributeSourcePointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置ClassFilter</span></span><br><span class="line">		setClassFilter(<span class="keyword">new</span> TransactionAttributeSourceClassFilter());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法是否与切点匹配</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取TransactionAttributeSource，由上面的步骤可知返回的是AnnotationTransactionAttributeSource</span></span><br><span class="line">		TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">        <span class="comment">// 如果TransactionAttributeSource为空，或者从TransactionAttributeSource获取到的事务属性不为空都会返回true</span></span><br><span class="line">		<span class="keyword">return</span> (tas == <span class="keyword">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ClassFilter过滤器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAttributeSourceClassFilter</span> <span class="keyword">implements</span> <span class="title">ClassFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切点是否与类匹配</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果TransactionalProxy、PlatformTransactionManager或者PersistenceExceptionTranslator的子类，则不匹配</span></span><br><span class="line">			<span class="keyword">if</span> (TransactionalProxy.class.isAssignableFrom(clazz) ||</span><br><span class="line">					PlatformTransactionManager.class.isAssignableFrom(clazz) ||</span><br><span class="line">					PersistenceExceptionTranslator.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 获取TransactionAttributeSource，由上文可知是AnnotationTransactionAttributeSource类型的</span></span><br><span class="line">			TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">            <span class="comment">// 调用isCandidateClass方法判断是否是匹配</span></span><br><span class="line">			<span class="keyword">return</span> (tas == <span class="keyword">null</span> || tas.isCandidateClass(clazz));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AnnotationTransactionAttributeSource</strong></p>
<h4 id="条件一：检查类是否匹配事务切点"><a href="#条件一：检查类是否匹配事务切点" class="headerlink" title="条件一：检查类是否匹配事务切点"></a>条件一：检查类是否匹配事务切点</h4><p>上面分析可知，检查类是否与切点匹配时获取了TransactionAttributeSource，调用它的isCandidateClass方法进行判断，TransactionAttributeSource的具体实现是AnnotationTransactionAttributeSource：</p>
<ol>
<li>在构造方法中，添加了注解解析器：<ul>
<li><strong>Spring事务注解解析器的实现类为SpringTransactionAnnotationParser，也是默认的注解解析器</strong>。</li>
<li>如果开启了JTA或者EJB，将会分别添加对应的解析器。</li>
</ul>
</li>
<li>实现了isCandidateClass方法，实际又是调用注解解析器的isCandidateClass判断是否是候选类的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTransactionAttributeSource</span> <span class="keyword">extends</span> <span class="title">AbstractFallbackTransactionAttributeSource</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jta12Present;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ejb3Present;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		ClassLoader classLoader = AnnotationTransactionAttributeSource.class.getClassLoader();</span><br><span class="line">		jta12Present = ClassUtils.isPresent(<span class="string">"javax.transaction.Transactional"</span>, classLoader);</span><br><span class="line">		ejb3Present = ClassUtils.isPresent(<span class="string">"javax.ejb.TransactionAttribute"</span>, classLoader);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> publicMethodsOnly;</span><br><span class="line">    <span class="comment">// 注解解析器集合</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;TransactionAnnotationParser&gt; annotationParsers;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AnnotationTransactionAttributeSource</span><span class="params">(<span class="keyword">boolean</span> publicMethodsOnly)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.publicMethodsOnly = publicMethodsOnly;</span><br><span class="line">        <span class="comment">// 添加注解解析器</span></span><br><span class="line">		<span class="keyword">if</span> (jta12Present || ejb3Present) &#123;</span><br><span class="line">			<span class="keyword">this</span>.annotationParsers = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">            <span class="comment">// 添加Spring事务注解解析器</span></span><br><span class="line">			<span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> SpringTransactionAnnotationParser());</span><br><span class="line">			<span class="keyword">if</span> (jta12Present) &#123;</span><br><span class="line">                <span class="comment">// JTA事务注解解析器</span></span><br><span class="line">				<span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> JtaTransactionAnnotationParser());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ejb3Present) &#123;</span><br><span class="line">                <span class="comment">// EJB3事务注解解析器</span></span><br><span class="line">				<span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> Ejb3TransactionAnnotationParser());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 添加Spring事务注解解析器</span></span><br><span class="line">			<span class="keyword">this</span>.annotationParsers = Collections.singleton(<span class="keyword">new</span> SpringTransactionAnnotationParser());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是候选类</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCandidateClass</span><span class="params">(Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (TransactionAnnotationParser parser : <span class="keyword">this</span>.annotationParsers) &#123;</span><br><span class="line">            <span class="comment">// 调用解析器的isCandidateClass方法判断是否是候选类</span></span><br><span class="line">			<span class="keyword">if</span> (parser.isCandidateClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SpringTransactionAnnotationParser</strong></p>
<ol>
<li><p>SpringTransactionAnnotationParser实现了isCandidateClass方法，<strong>它又调用了AnnotationUtils的isCandidateClass判断目标类是否是Transactional注解的候选类，AnnotationUtils中isCandidateClass的具体判断逻辑如下：</strong></p>
<ul>
<li><p>如果注解类路径以java.开头，返回true，这里Transactional注解不是java.开头，它是Spring的注解类，所以这个条件不会成立</p>
</li>
<li><p>如果目标类的类路径以java.开头，或者是Ordered类型，isCandidateClass返回false，说明目标类不是某个注解的候选类</p>
</li>
<li><p>除去以上两种情况之外，isCandidateClass都返回true</p>
<p><strong>总结： 如果目标类的类路径不以java.开头（也就是说它不是java的相关类），也不是Ordered类型，说明目标类是Transactional注解的候选类。</strong></p>
</li>
</ul>
</li>
<li><p>SpringTransactionAnnotationParser实现了parseTransactionAnnotation方法，里面包含对事物属性的解析。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTransactionAnnotationParser</span> <span class="keyword">implements</span> <span class="title">TransactionAnnotationParser</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCandidateClass</span><span class="params">(Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否是Transactional注解的候选类</span></span><br><span class="line">		<span class="keyword">return</span> AnnotationUtils.isCandidateClass(targetClass, Transactional.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析注解属性</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line">		AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(</span><br><span class="line">				element, Transactional.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析注解属性</span></span><br><span class="line">			<span class="keyword">return</span> parseTransactionAnnotation(attributes);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析事务注解</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(Transactional ann)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> parseTransactionAnnotation(AnnotationUtils.getAnnotationAttributes(ann, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析事务注解</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">		RuleBasedTransactionAttribute rbta = <span class="keyword">new</span> RuleBasedTransactionAttribute();</span><br><span class="line">        <span class="comment">// 事务的传播行为</span></span><br><span class="line">		Propagation propagation = attributes.getEnum(<span class="string">"propagation"</span>);</span><br><span class="line">		rbta.setPropagationBehavior(propagation.value());</span><br><span class="line">		Isolation isolation = attributes.getEnum(<span class="string">"isolation"</span>);</span><br><span class="line">		rbta.setIsolationLevel(isolation.value());</span><br><span class="line">		rbta.setTimeout(attributes.getNumber(<span class="string">"timeout"</span>).intValue());</span><br><span class="line">		rbta.setReadOnly(attributes.getBoolean(<span class="string">"readOnly"</span>));</span><br><span class="line">		rbta.setQualifier(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line"></span><br><span class="line">		List&lt;RollbackRuleAttribute&gt; rollbackRules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">"rollbackFor"</span>)) &#123;</span><br><span class="line">			rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">"rollbackForClassName"</span>)) &#123;</span><br><span class="line">			rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">"noRollbackFor"</span>)) &#123;</span><br><span class="line">			rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">"noRollbackForClassName"</span>)) &#123;</span><br><span class="line">			rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</span><br><span class="line">		&#125;</span><br><span class="line">		rbta.setRollbackRules(rollbackRules);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> rbta;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnnotationUtils</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationUtils</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 检查目标类clazz是否是注解的候选类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCandidateClass</span><span class="params">(Class&lt;?&gt; clazz, Collection&lt;Class&lt;? extends Annotation&gt;&gt; annotationTypes)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; annotationType : annotationTypes) &#123;</span><br><span class="line">             <span class="comment">// 传入目标类和注解，SpringTransactionAnnotationParser传入的注解是Transactional</span></span><br><span class="line">			<span class="keyword">if</span> (isCandidateClass(clazz, annotationType)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 检查目标类clazz是否是注解的候选类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCandidateClass</span><span class="params">(Class&lt;?&gt; clazz, Class&lt;? extends Annotation&gt; annotationType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入目标类和注解类路径</span></span><br><span class="line">		<span class="keyword">return</span> isCandidateClass(clazz, annotationType.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 检查目标类clazz是否是注解的候选类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCandidateClass</span><span class="params">(Class&lt;?&gt; clazz, String annotationName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注解类路径是否是java.开头</span></span><br><span class="line">		<span class="keyword">if</span> (annotationName.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 调用AnnotationsScanner的hasPlainJavaAnnotationsOnly方法判断</span></span><br><span class="line">        <span class="comment">// hasPlainJavaAnnotationsOnly方法的判断逻辑是：如果目标类的类路径以java.开头或者是Ordered类会返回true</span></span><br><span class="line">        <span class="comment">// 所以如果目标类的类路径以java.开头或者是Ordered类，isCandidateClass会返回false，说明目标类不是注解的候选类</span></span><br><span class="line">		<span class="keyword">if</span> (AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 如果注解类路径不是java.开头，并且目标类的类路径不以java.开头，也不是Ordered类型，返回true，说明目标类是某个注解的候选类</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnnotationsScanner</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationsScanner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPlainJavaAnnotationsOnly</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果目标类的类路径以java.开头或者是Ordered类</span></span><br><span class="line">		<span class="keyword">return</span> (type.getName().startsWith(<span class="string">"java."</span>) || type == Ordered.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="条件二：检查方法是否匹配事务切点"><a href="#条件二：检查方法是否匹配事务切点" class="headerlink" title="条件二：检查方法是否匹配事务切点"></a>条件二：检查方法是否匹配事务切点</h4><h5 id="AbstractFallbackTransactionAttributeSource"><a href="#AbstractFallbackTransactionAttributeSource" class="headerlink" title="AbstractFallbackTransactionAttributeSource"></a>AbstractFallbackTransactionAttributeSource</h5><p>如果从TransactionAttributeSource获取到的事务属性不为空将会满足切点的匹配条件，获取事务属性的方法实现在AbstractFallbackTransactionAttributeSource类中：</p>
<ol>
<li>如果当前方法是Object中的方法，返回空</li>
<li>根据当前的方法和类的信息构建缓存key，从缓存中获取<ul>
<li>如果获取不为空，判断是否为空的事务属性NULL_TRANSACTION_ATTRIBUTE，如果是则返回null，否则返回从缓存中获取到的事务属性</li>
<li>如果获取为空，调用解析事务属性的方法进行解析，然后放入缓存中并返回</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFallbackTransactionAttributeSource</span> <span class="keyword">implements</span> <span class="title">TransactionAttributeSource</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 空的TransactionAttribute</span></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TransactionAttribute NULL_TRANSACTION_ATTRIBUTE = <span class="keyword">new</span> DefaultTransactionAttribute() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="comment">// 缓存</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, TransactionAttribute&gt; attributeCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取事务属性</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前方法所在的类是Object</span></span><br><span class="line">		<span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 构建cacheKey</span></span><br><span class="line">		Object cacheKey = getCacheKey(method, targetClass);</span><br><span class="line">        <span class="comment">// 首先根据cacheKey从缓存中获取</span></span><br><span class="line">		TransactionAttribute cached = <span class="keyword">this</span>.attributeCache.get(cacheKey);</span><br><span class="line">		<span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 判断是否为空的TRANSACTION_ATTRIBUTE</span></span><br><span class="line">			<span class="keyword">if</span> (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</span><br><span class="line">                <span class="comment">// 返回空</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 返回事务属性TransactionAttribute</span></span><br><span class="line">				<span class="keyword">return</span> cached;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 解析TransactionAttribute</span></span><br><span class="line">			TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);</span><br><span class="line">			<span class="comment">// 如果为空，也加入缓存，但是value是NULL_TRANSACTION_ATTRIBUTE</span></span><br><span class="line">			<span class="keyword">if</span> (txAttr == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);</span><br><span class="line">                <span class="comment">// 如果是DefaultTransactionAttribute类型的</span></span><br><span class="line">				<span class="keyword">if</span> (txAttr <span class="keyword">instanceof</span> DefaultTransactionAttribute) &#123;</span><br><span class="line">					((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">"Adding transactional method '"</span> + methodIdentification + <span class="string">"' with attribute: "</span> + txAttr);</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// 加入缓存</span></span><br><span class="line">				<span class="keyword">this</span>.attributeCache.put(cacheKey, txAttr);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> txAttr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取缓存KEY</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">getCacheKey</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MethodClassKey(method, targetClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解析TransactionAttribute</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断方法是否是public的</span></span><br><span class="line">		<span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取目标方法</span></span><br><span class="line">		Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在方法上查找事务属性的设置，findTransactionAttribute方法在AnnotationTransactionAttributeSource中实现</span></span><br><span class="line">		TransactionAttribute txAttr = findTransactionAttribute方法(specificMethod);</span><br><span class="line">		<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> txAttr;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在目标类上面查找事务属性的设置</span></span><br><span class="line">		txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</span><br><span class="line">		<span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">			<span class="keyword">return</span> txAttr;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line">			<span class="comment">// 使用方法上配置的事务属性</span></span><br><span class="line">			txAttr = findTransactionAttribute(method);</span><br><span class="line">			<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> txAttr;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 使用类上面配置的事务属性</span></span><br><span class="line">			txAttr = findTransactionAttribute(method.getDeclaringClass());</span><br><span class="line">			<span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">				<span class="keyword">return</span> txAttr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>事务是基于AOP实现的，事务的Advisor是BeanFactoryTransactionAttributeSourceAdvisor，Advisor判断方法是否匹配时，是通过Pointcut的matches方法判断的，事务的Pointcut是TransactionAttributeSourcePointcut，里面实现了方法是否与事务切点匹配的判断：</strong></p>
<ol>
<li><p>对类的匹配是通过判断目标类是否是Transactional注解的候选类实现的，我们创建的类一般不会以java.开头，所以说可以与Transactional注解匹配成功。</p>
</li>
<li><p>对方法的匹配是通过解析方法上面配置的事务属性判断的，如果解析到了事务属性，则满足匹配条件。</p>
</li>
</ol>
<h3 id="TransactionInterceptor"><a href="#TransactionInterceptor" class="headerlink" title="TransactionInterceptor"></a>TransactionInterceptor</h3><p>TransactionInterceptor是事务Advisor的Advice，执行目标方法时，方法会被拦截，进入到TransactionInterceptor中，在TransactionInterceptor的invoke方法中实际是调用invokeWithinTransaction执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionInterceptor</span> <span class="keyword">extends</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通过事务执行目标方法，实现在TransactionAspectSupport方法中</span></span><br><span class="line">		<span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TransactionAspectSupport</strong></p>
<p>TransactionAspectSupport中实现了invokeWithinTransaction方法：</p>
<ol>
<li>获取事务属性TransactionAttribute和TransactionManager事务管理器</li>
<li>对响应式事务、声明式事务和编程式事务分别进行判断，以声明式事务为例步骤如下：<ul>
<li>创建事务</li>
<li>执行方法</li>
<li>捕捉异常，如果抛出异常进行回滚</li>
<li>清除事务信息</li>
<li>提交事务</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取TransactionAttributeSource</span></span><br><span class="line">		TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">		<span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 获取事务管理器TransactionManager</span></span><br><span class="line">		<span class="keyword">final</span> TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">        <span class="comment">// 响应式事务处理</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.reactiveAdapterRegistry != <span class="keyword">null</span> &amp;&amp; tm <span class="keyword">instanceof</span> ReactiveTransactionManager) &#123;</span><br><span class="line">			ReactiveTransactionSupport txSupport = <span class="keyword">this</span>.transactionSupportCache.computeIfAbsent(method, key -&gt; &#123;</span><br><span class="line">				<span class="keyword">if</span> (KotlinDetector.isKotlinType(method.getDeclaringClass()) &amp;&amp; KotlinDelegate.isSuspend(method)) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> TransactionUsageException(</span><br><span class="line">							<span class="string">"Unsupported annotated transaction on suspending function detected: "</span> + method +</span><br><span class="line">							<span class="string">". Use TransactionalOperator.transactional extensions instead."</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				ReactiveAdapter adapter = <span class="keyword">this</span>.reactiveAdapterRegistry.getAdapter(method.getReturnType());</span><br><span class="line">				<span class="keyword">if</span> (adapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot apply reactive transaction to non-reactive return type: "</span> +</span><br><span class="line">							method.getReturnType());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> ReactiveTransactionSupport(adapter);</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">return</span> txSupport.invokeWithinTransaction(</span><br><span class="line">					method, targetClass, invocation, txAttr, (ReactiveTransactionManager) tm);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line">		<span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line">        <span class="comment">// 声明式事务的处理</span></span><br><span class="line">		<span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">			<span class="comment">// 创建事务</span></span><br><span class="line">			TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">			Object retVal;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">                <span class="comment">// 这是一个环绕通知，将会在拦截链中执行下一个拦截</span></span><br><span class="line">				retVal = invocation.proceedWithInvocation();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="comment">// 捕捉异常，进行回滚</span></span><br><span class="line">				completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 清除事务</span></span><br><span class="line">				cleanupTransactionInfo(txInfo);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">				<span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">				TransactionStatus status = txInfo.getTransactionStatus();</span><br><span class="line">				<span class="keyword">if</span> (status != <span class="keyword">null</span> &amp;&amp; txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">					retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">			commitTransactionAfterReturning(txInfo);</span><br><span class="line">			<span class="keyword">return</span> retVal;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 编程式事务的处理</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">final</span> ThrowableHolder throwableHolder = <span class="keyword">new</span> ThrowableHolder();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Object result = ((CallbackPreferringPlatformTransactionManager) ptm).execute(txAttr, status -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 获取事务信息</span></span><br><span class="line">					TransactionInfo txInfo = prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 执行方法</span></span><br><span class="line">						Object retVal = invocation.proceedWithInvocation();</span><br><span class="line">						<span class="keyword">if</span> (vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">							<span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">							retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> retVal;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="keyword">if</span> (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line">							<span class="comment">// A RuntimeException: will lead to a rollback.</span></span><br><span class="line">							<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">								<span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> &#123;</span><br><span class="line">								<span class="keyword">throw</span> <span class="keyword">new</span> ThrowableHolderException(ex);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="comment">// A normal return value: will lead to a commit.</span></span><br><span class="line">							throwableHolder.throwable = ex;</span><br><span class="line">							<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 清除事务信息</span></span><br><span class="line">						cleanupTransactionInfo(txInfo);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check result state: It might indicate a Throwable to rethrow.</span></span><br><span class="line">				<span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> throwableHolder.throwable;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (ThrowableHolderException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> ex.getCause();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">				<span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">					logger.error(<span class="string">"Application exception overridden by commit exception"</span>, throwableHolder.throwable);</span><br><span class="line">					ex2.initApplicationException(throwableHolder.throwable);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">				<span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">					logger.error(<span class="string">"Application exception overridden by commit exception"</span>, throwableHolder.throwable);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> ex2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p><img src="/images/事务原理一总结.png" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://blog.csdn.net/qq_36882793/article/details/106440723" target="_blank" rel="noopener">【猫吻鱼】Spring源码分析：全集整理</a></p>
<p><strong>Spring版本：5.2.5.RELEASE</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/07/【JAVA】IO访问方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/07/【JAVA】IO访问方式/" itemprop="url">【JAVA】IO访问方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-07T21:00:00+08:00">
                2021-11-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>物理内存</strong></p>
<p>计算机物理内存条的容量，比如我们买电脑会关注内存大小有多少G，这个容量就是计算机的物理内存。</p>
<p><strong>虚拟内存</strong></p>
<p>操作系统为每个进程分配了独立的虚拟地址空间，也就是虚拟内存，虚拟地址空间又分为用户空间和内核空间，操作系统的位数不同，虚拟地址空间的大小也不同，32位操作系统虚拟地址内核空间为1G，用户空间大小为3G，64位操作系统用户空间和内核空间大小各为128T：<br><img src="/images/虚拟地址.jpg" alt=""></p>
<p>既然每个进程都拥有一块独立的虚拟地址空间，那么所有进程的虚拟地址空间大小加起来必定大于物理内存的大小，所以虚拟地址空间只是一个虚拟的概念，只有需要分配内存的时候才会为虚拟内存分配物理内存，并通过内存映射来管理虚拟地址和物理内存地址之间的映射关系。</p>
<p><strong>用户空间 / 内核空间</strong></p>
<p><strong>用户空间：</strong>是运行用户程序代码的地方，为了保证系统内核的安全，它不能直接访问内存等硬件设备，必须通过系统调用进入到内核空间来访问那些受限的资源。</p>
<p><strong>内核空间：</strong>是运行内核代码的地方，可以执行任意的指令访问系统资源，既可以访问内核空间也可以访问用户空间。</p>
<p><strong>用户态：</strong>进程运行在用户空间时处于用户态。</p>
<p><strong>内核态：</strong>程运行在内核空间时处于内核态。</p>
<h3 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h3><p>比如我们启动了一个java程序，此时运行在用户空间（用户态），接着准备做一个读取磁盘文件的操作，由于用户空间是无法直接从磁盘读取文件的，所以需要调用内核提供的接口来完成文件的读取，调用内核的接口的过程中由用户空间进入到了内核空间（内核态），通过DMA从磁盘读取文件到内核的缓冲区，之后再将数据从内核的缓冲区拷贝到用户空间完成文件的读取操作。</p>
<p><img src="/images/文件io.jpg" alt=""></p>
<ol>
<li>应用程序发起系统调用</li>
<li>从用户空间切换到内核空间，内核通过DMA从磁盘拷贝数据到内核缓冲区</li>
<li>将内核缓冲区的数据拷贝到用户空间的缓冲区</li>
</ol>
<p><strong>可以发现，整个读取过程发生了两次数据拷贝，一次是DMA将磁盘上的文件数据拷贝到内核缓冲区，一次是将内核缓冲区的数据拷贝到用户缓冲区。</strong>写操作与读取操作类似，只不过是将用户缓冲区的数据拷贝到内核缓冲区，再将内核缓冲区的数据拷贝到文件。</p>
<h3 id="网络I-O"><a href="#网络I-O" class="headerlink" title="网络I/O"></a>网络I/O</h3><p>网络I/O与文件I/O的底层原理一致，只不过文件I/O是从磁盘读取文件，网络I/O是从网卡中读取数据，客户端与服务端建立连接，当有数据到达时，从网卡中读取数据到内核缓冲区，再将内核缓冲区的数据复制到用户空间的缓冲区。</p>
<p><img src="/images/网络io.jpg" alt=""></p>
<h3 id="缓存I-O"><a href="#缓存I-O" class="headerlink" title="缓存I/O"></a>缓存I/O</h3><p>也称标准I/O，上面提到的文件I/O和网络I/O读取数据的方式都是使用的缓存I/O，需要将数据先拷贝到内核缓冲区，再将内核缓冲区的数据拷贝到用户缓冲区，数据经过两次拷贝，内核缓冲区和用户缓冲区分别指向不同的物理内存，其中内核缓存区是在Page Cache层：</p>
<p><img src="/images/缓存io.jpg" alt=""></p>
<p>标准I/O读取文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/Users/sml/test.txt"</span>);</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> FileInputStream(file))&#123;</span><br><span class="line">            <span class="comment">// 建立用户空间缓冲区</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么需要缓存IO？</strong></p>
<p>因为磁盘I/O是比较耗时的操作，如果每次都从磁盘上读取文件，性能将会大大下降，为了提升读取性能，增加了一层Page Cache，用于缓存读取的文件数据，Page Cache占用的是内存，从内存读取的速度远远大于从磁盘读取，内核缓冲区就是在Page Cache中开辟的一块内存，用户空间进行系统调用读取文件内容时，首先会判断Page Cache中是否缓存了文件的内容，如果缓存了直接读取即可，否则再从磁盘读取，所以缓存I/O可以减少磁盘I/O的次数提升性能。</p>
<p>文件的写操作同样如此，进行写操作时，将数据先写到Page Cache的缓冲区中，后续由操作系统将数据刷回到磁盘中。</p>
<p><strong>缓存I/O的优缺点</strong></p>
<p>优点：减少磁盘I/O次数，提升读写性能。</p>
<p>缺点：数据需要在内核空间和用户空间来回拷贝。</p>
<h3 id="直接I-O"><a href="#直接I-O" class="headerlink" title="直接I/O"></a>直接I/O</h3><p>缓存I/O经过了Page Cache，读取过程中需要将数据从Page Cache的缓冲区中拷贝到用户空间的缓存区，那么有没有一种方式可以省去这个拷贝的过程？</p>
<p>答案是有的，那就是直接I/O，应用程序直接访问磁盘数据，绕过了Page Cache，省去了从内核缓冲区拷贝到用户缓冲区的过程。</p>
<p><img src="/images/直接io.jpg" alt=""></p>
<p>目前JAVA并没有原生的直接/O操作方式，不过公众号博主<strong>Kirito</strong>提供了在JAVA中进行直接I/O操作的方法，具体参见【Kirito的技术分享】<a href="https://mp.weixin.qq.com/s/KtJUOTz4Pwyeo5hfRoumdg" target="_blank" rel="noopener">Java 文件 IO 操作之 DirectIO</a>。</p>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>内存映射就是将虚拟空间地址映射到物理空间地址，每个进程维护了一张页表，记录虚拟地址和物理地址之间的映射关系，当进程访问的虚拟地址在页表中无法查到映射关系时，系统产生缺页异常，进入内核空间为虚拟地址分配物理内存，并更新页表，记录映射关系。</p>
<p><strong>文件映射</strong></p>
<p>内存映射除了映射虚拟空间地址和物理空间地址，还包括将磁盘的文件内容映射到虚拟地址空间，称为文件映射，此时可以通过访问内存来访问文件里面的数据 。</p>
<p>mmap系统调用可以将文件映射到虚拟内存空间。文件映射的流程如下：</p>
<ol>
<li>进行mmap系统调用，将文件和虚拟地址空间建立映射，注意此时还没有分配物理内存空间，只是在逻辑上建立了虚拟地址和文件之间的映射关系，物理内存只有真正使用的时候才会分配。</li>
<li>应用程序访问用户空间虚拟内存中的某个地址，发现无法在页表中查到数据，产生缺页异常，此时进入内核空间</li>
<li><strong>因为不能直接使用物理地址，所以需要使用内核的虚拟地址临时建立与物理内存的映射关系，将文件内容读取到物理内存中，待数据读取完毕之后取消临时映射即可。</strong></li>
<li>缺页异常处理完毕，物理内存中已经加载了文件的数据，此时用户空间就可以通过虚拟地址直接访问物理内存中映射的文件数据。</li>
</ol>
<p><img src="/images/文件映射.jpg" alt=""></p>
<p><strong>从文件映射的流程中可以看出它与缓存I/O相比，少了从内核缓冲区将数据拷贝到用户缓冲区的步骤，减少了一次拷贝。</strong></p>
<p>Java NIO中提供了<strong>MappedByteBuffer</strong>来处理文件映射，下面是一个读取文件的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> (RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"/Users/sml/test.txt"</span>), <span class="string">"r"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 获取FileChannel</span></span><br><span class="line">            FileChannel fileChannel = file.getChannel();</span><br><span class="line">            <span class="keyword">long</span> size = fileChannel.size();</span><br><span class="line">            <span class="comment">// 调用map方法进行文件映射，返回MappedByteBuffer</span></span><br><span class="line">            MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, size);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)size];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">// 读取数据</span></span><br><span class="line">                bytes[i] = mappedByteBuffer.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>首先看一下使用传统缓存I/O从磁盘文件读取数据并发送到网络上的过程：</p>
<p><img src="/images/传统拷贝.jpg" alt=""></p>
<ol>
<li><p>用户发起系统调用，DMA从磁盘上读取数据到内核缓冲区</p>
</li>
<li><p>CPU将内核缓冲区的数据拷贝到用户缓冲区</p>
</li>
<li>CPU将用户缓冲区的数据拷贝到socket缓冲区</li>
<li>DMA将socket缓冲区的数据拷贝到网卡</li>
</ol>
<p>使用缓存I/O数据经过了四次拷贝，需要多次在内核空间和用户空间来回切换，影响系统性能。从数据拷贝的过程可以看到有些步骤其实是多余的，比如第二步，如果可以直接将内核缓存区的数据拷贝到socket缓冲区，或者直接将内核缓冲区的数据拷贝到网卡，岂不是减少了数据拷贝的次数？零拷贝就是这样一种致力于减少数据拷贝的技术。</p>
<p>Linux中的sendfile()函数可以实现将数据从一个文件描述符传输到另外一个文件描述符。Java NIO中的FileChannel也可以实现将数据从FileChannel直接传输到另一个Channel。</p>
<p><strong>FileChannel</strong></p>
<p>Java NIO中的FileChannel的transferTo方法将数据从FileChannel传输到另一个Channel：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"/Users/shanmenglu/test.txt"</span>), <span class="string">"r"</span>);</span><br><span class="line"><span class="comment">// 获取FileChannel</span></span><br><span class="line">FileChannel fileChannel = file.getChannel();</span><br><span class="line"><span class="keyword">long</span> size = fileChannel.size();</span><br><span class="line">SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">fileChannel.transferTo(<span class="number">0</span>,size,socketChannel);</span><br></pre></td></tr></table></figure>
<p>使用FileChanel后的数据拷贝：</p>
<p><img src="/images/filechannel.jpg" alt=""></p>
<p>Linux2.4版本之后通过对Socket Buffer添加一些Descriptor信息可以进一步减少数据的拷贝：</p>
<p><img src="/images/零拷贝.jpg" alt=""></p>
<p><strong>可以看到零拷贝并不是指的数据一次拷贝都没有发生，而是指没有通过CPU进行数据拷贝。</strong>Java中的堆外内存DirectByteBuffer和上面提到的mmap内存映射也是零拷贝中的一种，Netty中也提供了零拷贝相关的技术。</p>
<p><strong>堆外内存</strong></p>
<p>传统的缓存I/O，内核缓冲区和用户缓冲区分别占用不同的物理内存，其中用户缓冲区占用的是JVM堆内的内存：</p>
<p><img src="/images/缓存io内存占用.jpg" alt=""></p>
<p><strong>DirectByteBuffer</strong></p>
<p>Java NIO中提供了DirectByteBuffer，可以使用堆外内存，通过ByteBuffer的allocateDirect方法可以分配堆外内存，并返回内存的地址，之后就可以直接操作这块内存，不用将数据在内核缓冲区与用户缓冲区之间拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/堆外内存.jpg" alt=""></p>
<p><strong>堆外内存和直接I/O的区别</strong></p>
<p>直接I/O偏重的是绕过操作系统的Page Cache层，堆外内存偏重的是使用的JVM内存之外的内存，他们的侧重点不同，不过都可以减少数据的拷贝。</p>
<p>关于堆外内存是否在Page Cache中，这个待研究。</p>
<p><strong>参考</strong></p>
<p><a href="https://time.geekbang.org/column/intro/100020901?tab=catalog" target="_blank" rel="noopener">【极客时间-倪朋飞】Linux性能优化实战</a></p>
<p><a href="https://time.geekbang.org/column/intro/100024701?tab=catalog" target="_blank" rel="noopener">【极客时间-刘超】趣谈Linux操作系统</a></p>
<p><a href="https://edu.lagou.com/" target="_blank" rel="noopener">【拉勾教育-若地】Netty 核心原理剖析与 RPC 实践</a></p>
<p><a href="https://mp.weixin.qq.com/s/101wu0rg4mZWCxD9EuUYeA" target="_blank" rel="noopener">【 Kirito的技术分享】文件IO操作的最佳实践</a></p>
<p><a href="https://blog.csdn.net/zhangcongyi420/article/details/103099441" target="_blank" rel="noopener">【小码农叔叔】java使用nio读写文件</a></p>
<p><a href="https://www.jianshu.com/p/f90866dcbffc" target="_blank" rel="noopener">【占小狼】深入浅出MappedByteBuffer</a></p>
<p><a href="https://juejin.cn/post/6844903949359644680#heading-8" target="_blank" rel="noopener">【零壹技术栈】深入剖析Linux IO原理和几种零拷贝机制的实现</a></p>
<p><a href="https://www.jianshu.com/p/007052ee3773" target="_blank" rel="noopener">【tomas家的小拨浪鼓】堆外内存 之 DirectByteBuffer 详解</a></p>
<p><a href="https://www.cnblogs.com/sunsky303/p/8962628.html" target="_blank" rel="noopener">网络IO和磁盘IO详解</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/20/【Redis】quicklist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/20/【Redis】quicklist/" itemprop="url">【Redis】quicklist</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-09-20T17:00:00+08:00">
                2021-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis-List"><a href="#Redis-List" class="headerlink" title="Redis List"></a>Redis List</h2><p>在Redis3.2版之前，Redis使用压缩列表和双向链表作为List的底层实现。当元素个数比较少并且元素长度比较小时，Redis使用压缩列表实现，否则Redis使用双向链表实现。</p>
<p><strong>ziplist存在问题</strong></p>
<ol>
<li><p>不能保存过多的元素，否则查找复杂度高，性能降低。</p>
</li>
<li><p>由于每个节点保存了前一个节点的长度，不同长度使用的字节数不一样，所以在更新节点的时候有可能引起长度的变化导致连锁更新问题。</p>
</li>
</ol>
<p>为了解决上面两个问题，在Redis3.2版之后，引入了quicklist。</p>
<h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><p>quicklist可以理解为是ziplist和链表的结合体，一个quicklist是一个双向链表，链表中的每一个节点是一个ziplist。</p>
<p><img src="/images/quicklist.jpg" alt=""></p>
<h4 id="quicklist结构定义"><a href="#quicklist结构定义" class="headerlink" title="quicklist结构定义"></a>quicklist结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头指针</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* 列表中的元素总个数，也就是所有ziplist中包含的元素数量之和 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* 链表中节点的个数 */</span></span><br><span class="line">    <span class="keyword">int</span> fill : QL_FILL_BITS;              <span class="comment">/* 表示ziplist的大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : QL_COMP_BITS; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bookmark_count: QL_BM_BITS;</span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>head：指向头结点的指针</p>
</li>
<li><p>tail：指向尾节点的指针</p>
</li>
<li><p>count：列表中的元素总个数，等于所有节点的ziplist中包含的元素数量之和</p>
</li>
<li><p>len：quicklist中quicklistNode节点的个数</p>
</li>
<li><p>fill：用来限制quicklistNode中ziplist的大小，为正数时代表ziplist中最多能包含的元素个数，为负数时有以下几种情况：</p>
<p>| 数值 | 含义                            |<br>| —- | ——————————- |<br>| -1   | 表示ziplist的字节数不能超过4KB  |<br>| -2   | 表示ziplist的字节数不能超过8KB  |<br>| -3   | 表示ziplist的字节数不能超过16KB |<br>| -4   | 表示ziplist的字节数不能超过32KB |<br>| -5   | 表示ziplist的字节数不能超过64KB |</p>
</li>
</ul>
<p>​除此之外，也可以通过<strong>list-max-ziplist-size</strong>参数配置最大的字节数。</p>
<h4 id="quicklistNode结构定义"><a href="#quicklistNode结构定义" class="headerlink" title="quicklistNode结构定义"></a>quicklistNode结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 指向ziplist压缩列表的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist压缩列表的字节数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* ziplist压缩列表的元素个数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* 编码格式：RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* 是否被压缩 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* 是否可以被压缩 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* 预留bit位*/</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>
<p><img src="/images/quicklist1.jpg" alt=""></p>
<h4 id="quicklist创建"><a href="#quicklist创建" class="headerlink" title="quicklist创建"></a>quicklist创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">quicklist *<span class="title">quicklistCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> *<span class="title">quicklist</span>;</span></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    quicklist = zmalloc(<span class="keyword">sizeof</span>(*quicklist));</span><br><span class="line">    <span class="comment">// 初始化头尾节点</span></span><br><span class="line">    quicklist-&gt;head = quicklist-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    quicklist-&gt;len = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;count = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;compress = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认为-2，表示ziplist的字节数最大不能超过8KB</span></span><br><span class="line">    quicklist-&gt;fill = <span class="number">-2</span>;</span><br><span class="line">    quicklist-&gt;bookmark_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> quicklist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>添加元素的时候可以在链表的头部或者尾部进行添加，以头部添加为例：</p>
<ol>
<li>首先调用_quicklistNodeAllowInsert方法判断是否允许添加元素到ziplist，如果允许，调用ziplistPush方法进行添加</li>
<li>如果_quicklistNodeAllowInsert不允许添加元素，则需要新创建一个quicklistNode，然后将元素添加到新创建的quicklistNode的压缩列表中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从头部添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="comment">// 判断是否允许添加</span></span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        <span class="comment">// 将元素添加到ziplit</span></span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新创建quicklistNode节点</span></span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新数量</span></span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>_quicklistNodeAllowInsert</strong></p>
<p><strong>_quicklistNodeAllowInsert</strong>方法用于判断是否允许在某个quicklistNode指向的压缩列表中添加元素。</p>
<p>在quicklist的结构体定义中，fill指定了ziplist中能包含的最大元素个数或者ziplist最大的字节数，_quicklistNodeAllowInsert方法就是判断ziplist中的元素个数或者ziplist的字节数是否超过了限制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node：当前的quicklistNode节点</span></span><br><span class="line"><span class="comment">// fill：ziplist中能包含的最大元素个数或者ziplist最大的字节数</span></span><br><span class="line"><span class="comment">// sz：要添加元素的大小</span></span><br><span class="line">REDIS_STATIC <span class="keyword">int</span> _quicklistNodeAllowInsert(<span class="keyword">const</span> quicklistNode *node,</span><br><span class="line">                                           <span class="keyword">const</span> <span class="keyword">int</span> fill, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!node))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ziplist_overhead;</span><br><span class="line">    <span class="comment">/* 判断要添加元素的大小是否小于254 */</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">254</span>)</span><br><span class="line">        ziplist_overhead = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断要添加元素的大小是否小于64 */</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">64</span>)</span><br><span class="line">        ziplist_overhead += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (likely(sz &lt; <span class="number">16384</span>))</span><br><span class="line">        ziplist_overhead += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算添加元素后的当前的quicklistNode的大小 + 新加入元素的大小 + 插入元素后ziplit的prevlen占用大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> new_sz = node-&gt;sz + sz + ziplist_overhead;</span><br><span class="line">    <span class="comment">// 判断添加元素后的ziplist的字节数是否超过了fill中设置的大小</span></span><br><span class="line">    <span class="keyword">if</span> (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sizeMeetsSafetyLimit(new_sz))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)node-&gt;count &lt; fill) <span class="comment">// 判断ziplist的元素个数是否超过了fill设置的大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li><p>在Redis3.2版之前，Redis使用压缩列表和双向链表作为List的底层实现。当元素个数比较少并且元素长度比较小时，Redis使用压缩列表实现，否则Redis使用双向链表实现。</p>
</li>
<li><p>为了解决压缩列表在节点多的时候查找效率低的问题以及连锁更新问题，在Redis3.2版之后引入了quicklist，quicklist是一个双向链表，链表中的每一个节点是一个ziplist。</p>
</li>
<li><p>quicklist中限定了ziplist的大小，如果超过了限制的大小，新加入元素的时候会生成一个新的quicklistNode节点。</p>
</li>
<li><p>quicklist通过限定ziplist的大小来保证一个ziplist中的元素个数不会太多，如果需要连锁更新，也只在某个quicklistNode节点指向的ziplist中更新，不会引发整个链表的更新，以此来解决压缩列表存在的问题。</p>
</li>
</ol>
<p><strong>参考</strong></p>
<p>陈雷《Redis5设计与源码分析》</p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/16/【Redis】skiplist跳跃表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/16/【Redis】skiplist跳跃表/" itemprop="url">【Redis】skiplist跳跃表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-09-16T22:00:00+08:00">
                2021-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="有序集合Sorted-Set"><a href="#有序集合Sorted-Set" class="headerlink" title="有序集合Sorted Set"></a>有序集合Sorted Set</h2><p><strong>zadd</strong></p>
<p>zadd用于向集合中添加元素，添加三门编程语言，分值分别为1、2、3：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd language 1 java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd language 2 c++</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd language 3 python</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p><strong>zrange</strong></p>
<p>zrange根据分值区间返回符合条件的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange language 1 3 withscores</span><br><span class="line">1) "c++"</span><br><span class="line">2) "2"</span><br><span class="line">3) "python"</span><br><span class="line">4) "3"</span><br></pre></td></tr></table></figure>
<p><strong>zscore</strong></p>
<p>zscore根据key和元素值返回元素的分值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscore language python</span><br><span class="line">"3"</span><br></pre></td></tr></table></figure>
<p>Sorted Set是Redis中的一种数据结构，它可以用来存储带有分值的元素，并且根据分值进行排序，是一个有序的集合。</p>
<p>Sorted Set的结构定义如下，它包含了一个哈希表dict和一个跳跃表zskiplist，其中哈希表可以在O(1)的时间复杂度内进行元素查找，而跳跃表可以支持高效的范围查询：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>如果一个有序集合中包含的元素数量比较多或者有序集合中的元素是比较长的字符串时，Redis就会使用跳跃表作为有序集合的底层实现。</p>
<p>跳跃表是一种多层的有序链表，在一个普通的有序链表中如果想要查找某个元素，必须遍历链表，时间复杂度为O(n)，那么如何提高查找效率呢，可以使用跳跃表，从列表中抽出一些元素进行分层，比如每隔一个节点就抽出一层：</p>
<p><img src="/images/sortlist.jpg" alt=""></p>
<p>此时如果需要查找元素为9的节点：</p>
<ol>
<li>从第三层开始查找，元素的值为8，因为9大于8并且8之后没有其他的节点所以接下来进入第二层</li>
<li>进入第二层，8的下一个节点为15，9小于15，所以进入第一层</li>
<li>进入第一层，获取8的下一个节点，等于要查找的值9，查找结束</li>
</ol>
<h3 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h3><p><strong>跳跃表的结构定义</strong></p>
<ul>
<li>header：指向跳跃表中节点的头指针，跳跃表中的节点定义为zskiplistNode，跳跃表实际上也是一个链表，所以会有一个头结点</li>
<li>tail：指向跳跃表中节点的尾指针</li>
<li>length：跳跃表中节点的数量</li>
<li>level：跳跃表的层级</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳跃表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 指向跳跃表的头尾指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 层级</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>
<p><strong>节点的结构定义</strong></p>
<ul>
<li>ele：一个sds类型的变量，存储实际的数据</li>
<li>score：存储数据的分值，跳跃表就是按照这个分值进行排序的</li>
<li>backward：一个指向前一个节点的指针，为了便于从后往前查找</li>
<li>zskiplistLevel：一个层级数组，因为跳跃表可以有多层，每一层中都有一个指向当前层级中的下一个节点的指针forward和span跨度，跨度代表了当前层级里面，当前节点与下一个节点直接跨越了几个节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳跃表中的节点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 存储的元素</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 后向指针，指向当前节点的前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层级数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 指向当前层级中的下一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>
<p><img src="/images/zskiplist.jpg" alt=""></p>
<h3 id="跳跃表的创建"><a href="#跳跃表的创建" class="headerlink" title="跳跃表的创建"></a>跳跃表的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建跳跃表节点*/</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    zskiplistNode *zn =</span><br><span class="line">        zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;ele = ele;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建跳跃表 */</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    <span class="comment">// 跳跃表分配内存</span></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    <span class="comment">// 层级初始化为1</span></span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 长度为0</span></span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建头结点</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 初始化每一层的头结点</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头结点的下一个节点指向NULL</span></span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 尾节点</span></span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="跳跃表层数的设置"><a href="#跳跃表层数的设置" class="headerlink" title="跳跃表层数的设置"></a>跳跃表层数的设置</h3><p>跳跃表根据什么规则来进行层数划分呢，有以下几种方案：</p>
<p><strong>方案一</strong></p>
<p>每隔一个节点，就取出一个节点作为新的一层的节点，这样每一层上节点的数量大约是下一层节点数的一半，此时类似于二分查找，查找复杂度为O(logn)</p>
<p><strong>优点：查找的时间复杂度降低了</strong></p>
<p><strong>缺点：由于需要维护每个层级的节点数，在节点进行插入或者删除的时候，要调整层级节点，带来额外的开销</strong></p>
<p><strong>方案二</strong></p>
<p>新增加节点的时候，调用<strong>随机生成层数</strong>方法，随机生成一个当前跳跃表所需要的层数，如果生成的层数等于当前层数，新节点只需要加入跳跃表中即可，不需要额外的维护每一个层级的节点数，Redis中就是使用的随机生成层数的方式维护跳跃表的层级。</p>
<p>随机生成层数方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32  <span class="comment">// 最大层级不超过32</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成层数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果生成的随机数的值小于ZSKIPLIST_P，层数就+1</span></span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 是否超过了最大层数，超过就使用最大层数</span></span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0xFFFF = 65535</p>
<p>random()&amp;0xFFFF运算之后会生成一个0和65535之间的数，ZSKIPLIST_P <em> 0xFFFF = 0.25 </em> 65535，所以random()&amp;0xFFFF 小于 0.25 * 65535的概率为25%，也就是层数会增加1的概率不超过25%。</p>
<h3 id="跳跃表增加节点"><a href="#跳跃表增加节点" class="headerlink" title="跳跃表增加节点"></a>跳跃表增加节点</h3><ol>
<li>因为跳跃表有多层，所以需要遍历每一层，寻找每层要插入的位置，update[i]就记录了每一层要插入的位置</li>
<li>随机生成跳跃表的层数，如果层数有变化，则需要调整跳跃表的层高</li>
<li>创建节点，并将节点插入到跳跃表中</li>
<li>设置backward，新插入节点的前一个节点是update[0],如果update[0]为头结点，当前节点的前一个节点设为null,否则backward设置为update[0]</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    <span class="comment">//获取头结点</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">/* 寻找每层要插入的位置，从高层开始向下遍历 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// rank[i]记录了当前层从header节点到update[i]节点所经历的步长</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 如果当前层级下一个节点不为空 并且 下一个节点的score小于要插入节点的分值 或者 下一个节点的score等于要插入节点的score并且对比两个节点存储的元素值之后小于0（字符串比较）</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 更新rank[i]的值</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            <span class="comment">// 获取下一个节点</span></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录每层需要插入的位置</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机生成跳跃表的层数</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="comment">// 如果大于当前的层数</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="comment">// 调整层数</span></span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新层数</span></span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建节点</span></span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="comment">// 循环每一层，添加节点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新跨度 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置当前节点的前一个节点，如果update[0]为头结点，当前节点的前一个节点设为null,否则backward设置为update[0]</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    <span class="comment">// 增加长度</span></span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li>Sorted Set支持在添加元素的时候为元素添加一个分值，并根据分值排序，是一个有序的集合。</li>
<li>Sorted Set在数据比较少的时候采用ziplist存储，超过阈值后使用哈希表和跳跃表来提高查找效率，其中哈希表用于单值查询，跳跃表用于范围查询。</li>
<li>跳跃表是一个多层的有序链表，它采用了空间换时间的方式将查找的时间复杂度降到了O(logN)。</li>
</ol>
<p><strong>参考</strong></p>
<p>黄健宏《Redis设计与实现》</p>
<p>陈雷《Redis5设计与源码分析》</p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a></p>
<p><a href="https://blog.csdn.net/unix21/article/details/10197115/" target="_blank" rel="noopener">【unix21】redis源码分析–zslRandomLevel位运算解析</a></p>
<p><a href="https://www.cnblogs.com/riches/p/13515730.html" target="_blank" rel="noopener">【有梦想的肥宅】Redis5设计与源码分析读后感（三）跳跃表</a></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/12/【Redis】ziplist压缩列表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/12/【Redis】ziplist压缩列表/" itemprop="url">【Redis】ziplist压缩列表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-09-12T13:30:00+08:00">
                2021-09-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表是列表和哈希表的底层实现之一：</p>
<ul>
<li><p>如果一个列表只有少量数据，并且数据类型是整数或者比较短的字符串，redis底层就会使用压缩列表实现。</p>
</li>
<li><p>如果一个哈希表只有少量键值对，并且每个键值对的键和值数据类型是整数或者比较短的字符串，redis底层就会使用压缩列表实现。</p>
</li>
</ul>
<p>Redis压缩列表是由连续的内存块组成的列表，主要包含以下内容：</p>
<ul>
<li><p>zlbytes：记录压缩列表占用的总的字节数，占用4个字节（32bits）</p>
</li>
<li><p>zltail：记录压缩列表的起始位置到最后一个节点的字节数，假如知道压缩列表的起始地址，只需要假设zltail记录的偏移量即可定位到压缩列表中最后一个节点的位置，占用4个字节（32bits）</p>
</li>
<li><p>zllen：记录了压缩列表中节点的数量，占用2个字节（16bits）</p>
</li>
<li><p>entry：存储数据的节点，可以有多个</p>
</li>
<li><p>zlend：标记压缩列表的结尾，值为255，占用1个字节（8bits）</p>
</li>
</ul>
<p><img src="/images/ziplist.jpg" alt=""></p>
<h3 id="压缩列表的创建"><a href="#压缩列表的创建" class="headerlink" title="压缩列表的创建"></a>压缩列表的创建</h3><p>列表在初始化的时候会计算需要分配的内存空间大小，然后进行内存分配，之后将内存空间的最后一个字节标记为列表结尾，内存空间的大小计算方式如下：</p>
<ol>
<li><p>压缩列表头大小，包括zlbytes、zltail和zllen所占用的大小：32 bits * 2 + 16 bits</p>
</li>
<li><p>压缩列表结尾大小：8bits</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩列表头大小，包括zlbytes、zltail和zllen所占用的大小：32 bits * 2 + 16 bits</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line"><span class="comment">// 压缩列表结尾大小：8bits</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_END_SIZE        (sizeof(uint8_t))</span></span><br><span class="line"><span class="comment">// 列表结尾标记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_END 255</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算需要分配的内存大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;</span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将内存空间的最后一个字节标记为列表结尾</span></span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以在创建之后，内存布局如下，此时压缩列表中还没有节点：<br><img src="/images/ziplist创建.jpg" alt=""></p>
<p>之后如果如果需要添加节点，会进行移动，为新节点的插入腾出空间，所以还是占用的连续的空间：<br><img src="/images/ziplist添加节点.jpg" alt=""></p>
<h3 id="压缩列表节点"><a href="#压缩列表节点" class="headerlink" title="压缩列表节点"></a>压缩列表节点</h3><p><img src="/images/ziplist节点.jpg" alt=""></p>
<p>压缩列表的节点可以存储字符串或者整数类型的值，为了节省内存，它采用了变长的编码方式，压缩列表的节点的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize; <span class="comment">/* 前一个节点长度编码所需要的字节数*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlen;     <span class="comment">/* 前一个节点的长度（占用的字节数）*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize;        <span class="comment">/* 当前节点长度编码所需要的字节数*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;            <span class="comment">/* 当前节点的长度（占用的字节数）*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize;     <span class="comment">/* header的大小，headersize = prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;      <span class="comment">/* 记录了数据的类型和数据长度 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;            <span class="comment">/* 指向数据的指针 */</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>
<p><strong>prevrawlen</strong>：存储前一个节点的长度（占用的字节数），这样如果从后向前遍历，只需要当前节点的起始地址减去长度的偏移量prevrawlen就可以定位到上一个节点的位置，prevrawlen的长度可以是1字节或者5字节：</p>
<ul>
<li>如果前一项节点的长度小于254字节，那么prevrawlen的长度是1字节。</li>
<li>如果前一项节点的长度大于254字节，那么prevrawlen的长度是5字节，其中第一个字节会被设置为0xFE（十进制254），之后的四个字节用于保存前一个节点的长度。</li>
</ul>
<blockquote>
<p>为什么没有255字节？</p>
<p>因为255用来标记为压缩列表的结尾。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 节点编码所需要的字节数 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipStorePrevEntryLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (len &lt; ZIP_BIG_PREVLEN) ? <span class="number">1</span> : <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断长度是否小于254</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIP_BIG_PREVLEN) &#123;</span><br><span class="line">            p[<span class="number">0</span>] = len;</span><br><span class="line">            <span class="comment">// 使用1个字节</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> zipStorePrevEntryLengthLarge(p,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点编码所需要的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zipStorePrevEntryLengthLarge</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 将prevrawlen的第1个字节设置为254</span></span><br><span class="line">        p[<span class="number">0</span>] = ZIP_BIG_PREVLEN;</span><br><span class="line">        u32 = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;u32,<span class="keyword">sizeof</span>(u32));</span><br><span class="line">        memrev32ifbe(p+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用5个字节</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>encoding</strong>：记录了节点的数据类型和内容的长度，因为压缩列表可以存储字符串或者整型，所以有以下两种情况：</p>
<ol>
<li><p><strong>存储内容为字符串</strong></p>
<p>C语言存储字符串底层使用的是字节数组，当内容为字符串时分为三种情况，encoding分别占用1字节、2字节、5字节，encoding占用字节大小的不同，代表存储不同长度的字节数组。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>00xxxxxx</td>
<td>占用1个字节，也就是8bits</td>
<td>长度小于等于63(2^6 - 1)字节的字节数组</td>
</tr>
<tr>
<td>01xxxxxx xxxxxxxx</td>
<td>占用2个字节，也就是16bits</td>
<td>长度小于等于16383(2^14 - 1)字节的字节数组</td>
</tr>
<tr>
<td>10xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</td>
<td>占用5个字节，40bits</td>
<td>长度小于等于4294967295(2^32 - 1)字节的字节数组</td>
</tr>
</tbody>
</table>
<ol start="2">
<li><strong>存储内容为整数</strong></li>
</ol>
<p>存储内容为整数时，encoding占用1个字节，最高位是11开头，后六位代表整数值的长度，其中当编码为1111xxxx时情况比较特殊，</p>
<p>后四位的值在0001和1101之间，<strong>此时直接代表数据的内容，是0到12之间的一个数字</strong>，并不是数据长度，因为它代表了数据内容，所以也不需要额外的空间存储数据内容。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>11000000</td>
<td>1个字节</td>
<td>int16_t类型的整数</td>
</tr>
<tr>
<td>11010000</td>
<td>1个字节</td>
<td>uint32_t类型的整数</td>
</tr>
<tr>
<td>11100000</td>
<td>1个字节</td>
<td>uint64_t类型的整数</td>
</tr>
<tr>
<td>11110000</td>
<td>1个字节</td>
<td>24位有符号整数</td>
</tr>
<tr>
<td>11111110</td>
<td>1个字节</td>
<td>8位有符号整数</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1个字节</td>
<td>特殊情况，后四位的值在0001和1101之间，<strong>此时代表的是数据内容</strong>，并不是数据长度</td>
</tr>
</tbody>
</table>
<p><strong>zipStoreEntryEncoding</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点编码所需字节数判断</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipStoreEntryEncoding</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding, <span class="keyword">unsigned</span> <span class="keyword">int</span> rawlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> len = <span class="number">1</span>, buf[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// 如果是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="comment">/* 根据字符串的长度判断使用几个字节数 */</span></span><br><span class="line">        <span class="keyword">if</span> (rawlen &lt;= <span class="number">0x3f</span>) &#123; <span class="comment">// 小于等于63字节</span></span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_06B | rawlen;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawlen &lt;= <span class="number">0x3fff</span>) &#123; <span class="comment">// 小于等于16383字节</span></span><br><span class="line">            len += <span class="number">1</span>; <span class="comment">// 使用2个字节</span></span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_14B | ((rawlen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x3f</span>);</span><br><span class="line">            buf[<span class="number">1</span>] = rawlen &amp; <span class="number">0xff</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 字符串长度大于16383字节</span></span><br><span class="line">            len += <span class="number">4</span>; <span class="comment">// 使用5个字节</span></span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_32B;</span><br><span class="line">            buf[<span class="number">1</span>] = (rawlen &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">2</span>] = (rawlen &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">3</span>] = (rawlen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">4</span>] = rawlen &amp; <span class="number">0xff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是整数，使用1个字节</span></span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">        buf[<span class="number">0</span>] = encoding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保存长度 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,buf,len);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="节点的插入"><a href="#节点的插入" class="headerlink" title="节点的插入"></a>节点的插入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加节点</span></span><br><span class="line"><span class="comment">// zl:指向压缩列表的指针</span></span><br><span class="line"><span class="comment">// s:数据内容</span></span><br><span class="line"><span class="comment">// slen：数据的长度</span></span><br><span class="line"><span class="comment">// where:在哪个位置添加</span></span><br><span class="line"><span class="comment">// 调用例子：zl = ziplistPush(zl, (unsigned char*)"foo", 3, ZIPLIST_TAIL);</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="comment">// 判断是在头部或者尾部进行添加</span></span><br><span class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="comment">// zl:指向压缩列表的指针</span></span><br><span class="line"><span class="comment">// p:添加的位置</span></span><br><span class="line"><span class="comment">// s：数据内容</span></span><br><span class="line"><span class="comment">// slen：数据的长度</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen, newlen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; </span><br><span class="line">    zlentry tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断要添加的位置是否是结尾处</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;<span class="comment">// 如果不是尾部</span></span><br><span class="line">        <span class="comment">// 计算前一个节点的长度prevlen</span></span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是在尾部</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            <span class="comment">// 计算前一个节点的长度</span></span><br><span class="line">            prevlen = zipRawEntryLengthSafe(zl, curlen, ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断节点是否可以被Encoding</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">// 计算将字符串转换为整数后的长度</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接使用原始长度</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// reqlen用来保存当前节点所占用的长度</span></span><br><span class="line">    <span class="comment">// 加上前一个节点编码所需要的字节数</span></span><br><span class="line">    reqlen += zipStorePrevEntryLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    <span class="comment">// 加上当前节点编码所需要的字节数</span></span><br><span class="line">    reqlen += zipStoreEntryEncoding(<span class="literal">NULL</span>,encoding,slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里用于判断节点加入的时候，后面的节点prevrawlen的字节数是否可以满足要插入节点的长度*/</span></span><br><span class="line">    <span class="keyword">int</span> forcelarge = <span class="number">0</span>;</span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextdiff == <span class="number">-4</span> &amp;&amp; reqlen &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        nextdiff = <span class="number">0</span>;</span><br><span class="line">        forcelarge = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    offset = p-zl;</span><br><span class="line">    newlen = curlen+reqlen+nextdiff;</span><br><span class="line">    <span class="comment">// 调整压缩列表的长度</span></span><br><span class="line">    zl = ziplistResize(zl,newlen);</span><br><span class="line">    p = zl+offset;</span><br><span class="line">    <span class="comment">// 如果p不指向链表结尾，说明新加入的节点不是最后一个</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">/* 将p指向的节点和它之后的节点向后移动，为新节点腾出空间*/</span></span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 当前节点的长度编码后存储到后一个节点的prevrawlen*/</span></span><br><span class="line">        <span class="keyword">if</span> (forcelarge)</span><br><span class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 更新结尾的OFFSET */</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line">        assert(zipEntrySafe(zl, newlen, p+reqlen, &amp;tail, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 新加入的节点是列表的最后一个节点时 */</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里判断是否需要连锁更新 */</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入节点*/</span></span><br><span class="line">    p += zipStorePrevEntryLength(p,prevlen);</span><br><span class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改压缩列表节点的数量</span></span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>因为压缩列表中每个节点记录了前一个节点的长度：</p>
<ul>
<li>如果前一项节点的长度小于254字节，那么prevrawlen的长度是1字节。</li>
<li>如果前一项节点的长度大于254字节，那么prevrawlen的长度是5字节，其中第一个字节会被设置为0xFE（十进制154），之后的四个字节用于保存前一个节点的长度。</li>
</ul>
<p>假设有一种情况，一个压缩列表中，存储了多个长度是253字节的节点，因为节点的长度都在254字节以内，所以每个节点的prevrawlen只需要1个字节去存储长度的值：</p>
<p><img src="/images/ziplist连锁更新1.jpg" alt=""></p>
<p>此时在列表的头部需要新增加一个节点，并且节点的长度大于254，这个时候原先的头结点entry1 prevrawlen使用1字节已经不能满足当前的情况了，必须要使用5字节存储，因此entry1的prevrawlen变成了5字节，entry1的长度也会跟着增加4个字节，已经超过了254字节，因为大于254就需要使用5个字节存储，所以entry2的prevrawlen也需要改变为5字节，后面的以此类推，引发了连锁更新，这种情况称之为连锁更新：</p>
<p><img src="/images/ziplist连锁更新2.jpg" alt=""></p>
<p>总结</p>
<p>（1）Redis压缩列表使用了一块连续的内存，来节约内存空间。</p>
<p>（2）压缩列表的节点可以存储字符串或者整数类型的值，它采用了变长的编码方式，根据数据类型的不同以及数据长度的不同，选择不同的编码方式，每种编码占用的字节大小不同，以此来节约内存。</p>
<p>（3）压缩列表的每个节点中存储了前一个节点的字节长度，如果知道某个节点的地址，可以使用地址减去字节长度定位到上一个节点，不过新增节点的时候，由于前一个节点的长度大于254使用5个字节，小于254使用1个字节存储，在一些极端的情况下由于长度的变化会引起连锁更新。</p>
<p><strong>参考</strong></p>
<p>黄健宏《Redis设计与实现》</p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a></p>
<p><a href="http://zhangtielei.com/posts/blog-redis-ziplist.html" target="_blank" rel="noopener">【张铁蕾】Redis内部数据结构详解(4)——ziplist</a></p>
<p><a href="https://blog.csdn.net/u013139008/article/details/103131605" target="_blank" rel="noopener">【_HelloBug】Redis-压缩表-__ziplistInsert详解</a></p>
<p><a href="https://www.bbsmax.com/A/Ae5RR7NM5Q/" target="_blank" rel="noopener">图解Redis之数据结构篇——压缩列表</a></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/07/【JAVA】动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/07/【JAVA】动态代理/" itemprop="url">【JAVA】动态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-09-07T21:10:00+08:00">
                2021-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>代理模式包含三个角色：</p>
<ol>
<li><strong>Subject</strong>主题对象：一般是一个接口，定义一些方法。</li>
<li><strong>RealSubject </strong>具体的主题实现对象：实现Subject中定义的方法。</li>
<li><strong>Proxy </strong>代理对象：Proxy中包含一个RealSubject的引用，由代理对象实现RealSubject方法的调用。</li>
</ol>
<p><strong>Subject</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RealSubject</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"realsubject方法执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代理对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理的目标对象，也就是RealSubject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyInvocationHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始执行方法："</span> + method.getName());</span><br><span class="line">        <span class="comment">// 执行RealSubject中的方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"结束执行方法："</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread()</span><br><span class="line">                        .getContextClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">        <span class="comment">// 创建实际的对象</span></span><br><span class="line">        Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        <span class="comment">// 创建InvocationHandler</span></span><br><span class="line">        ProxyInvocationHandler invocationHandler = <span class="keyword">new</span> ProxyInvocationHandler(subject);</span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        Subject proxy = (Subject) invocationHandler.getProxy();</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        proxy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始执行方法：execute</span><br><span class="line">realsubject方法执行</span><br><span class="line">结束执行方法：execute</span><br></pre></td></tr></table></figure>
<h3 id="动态代理实现原理"><a href="#动态代理实现原理" class="headerlink" title="动态代理实现原理"></a>动态代理实现原理</h3><p>在ProxyInvocationHandler中可以看到通过Proxy创建了一个代理对象，那么接下来就进入到Proxy中，看一下是如何创建代理对象的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread()</span><br><span class="line">                .getContextClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>在Proxy中newProxyInstance方法创建代理对象的时候，传入了类加载器、需要代理的Subject对象以及InvocationHandler：</p>
<ol>
<li>根据类加载器和需要代理的Subject对象生成代理类的class</li>
<li>根据生成的代理类的class信息，通过构造器创建代理对象，并将InvocationHandler传入</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取代理类的class</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取构造器</span></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="comment">// InvocationHandler</span></span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过构造器创建代理对象，并将InvocationHandler传入</span></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="生成代理类的class"><a href="#生成代理类的class" class="headerlink" title="生成代理类的class"></a>生成代理类的class</h5><p>getProxyClass0中首先会进行边界检查，然后根据加载器和需要代理的Subject信息从proxyClassCache缓存中获取生成的代理类的calss</p>
<p>，具体的实现在WeakCache的get方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 代理类的缓存</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">     proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 生成代理类的class</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                        Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">     <span class="comment">// 边界检查</span></span><br><span class="line">     <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 从proxyClassCache中获取class</span></span><br><span class="line">     <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="WeakCache"><a href="#WeakCache" class="headerlink" title="WeakCache"></a>WeakCache</h5><p>WeakCache的get方法中如果根据缓存key获取对象为空，会创建一个Factory对象赋值给Supplier，Factory是WeakCache的一个内部类，它实现了Supplier接口，然后调用Supplier的get方法来生成代理类的class，接下来进入到Factory的get方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakCache</span>&lt;<span class="title">K</span>, <span class="title">P</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 获取class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(parameter);</span><br><span class="line">        expungeStaleEntries();</span><br><span class="line">        <span class="comment">// 获取缓存key</span></span><br><span class="line">        Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line">        <span class="comment">// 根据key获取对象</span></span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">        <span class="comment">// 如果为空</span></span><br><span class="line">        <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建一个ConcurrentMap</span></span><br><span class="line">            ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">                = map.putIfAbsent(cacheKey,</span><br><span class="line">                                  valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">            <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                valuesMap = oldValuesMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建subKey</span></span><br><span class="line">        Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">        Factory factory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用get方法获取class</span></span><br><span class="line">                V value = supplier.get();</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果为空，创建Factory</span></span><br><span class="line">            <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">                factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果supplier为null</span></span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">                <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将factory赋值给supplier</span></span><br><span class="line">                    supplier = factory;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                    supplier = factory;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// retry with current supplier</span></span><br><span class="line">                    supplier = valuesMap.get(subKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h5><p>Factory是WeakCache的一个内部类，它实现了Supplier接口，在get方法中，又调用了valueFactory的apply方法创建class，valueFactory是WeakCache的一个成员变量，在WeakCache的构造函数中可以看到传入了valueFactory对象进行初始化，那么接下来就需要回到Proxy类中，看一下如何实例化WeakCache的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakCache</span>&lt;<span class="title">K</span>, <span class="title">P</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;K, P, V&gt; valueFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakCache</span><span class="params">(BiFunction&lt;K, P, ?&gt; subKeyFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     BiFunction&lt;K, P, V&gt; valueFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subKeyFactory = Objects.requireNonNull(subKeyFactory);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">this</span>.valueFactory = Objects.requireNonNull(valueFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Factory</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> P parameter;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object subKey;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap;</span><br><span class="line"></span><br><span class="line">        Factory(K key, P parameter, Object subKey,</span><br><span class="line">                ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.parameter = parameter;</span><br><span class="line">            <span class="keyword">this</span>.subKey = subKey;</span><br><span class="line">            <span class="keyword">this</span>.valuesMap = valuesMap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">            <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            V value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用valueFactory的apply方法创建class</span></span><br><span class="line">                value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// remove us on failure</span></span><br><span class="line">                    valuesMap.remove(subKey, <span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ......</span><br><span class="line">              </span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ProxyClassFactory"><a href="#ProxyClassFactory" class="headerlink" title="ProxyClassFactory"></a>ProxyClassFactory</h5><p>Proxy中WeakCache初始化的时候使用的是ProxyClassFactory类型的factory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * WeakCache初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以调用valueFactory的apply方法的时候会进入到ProxyClassFactory的apply方法，在apply方法中会通过ProxyGenerator动态生成代理类并加载类，然后将实例化的代理类返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">       implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 前缀</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// next number to use for generation of unique proxy class names</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">           Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">           ......</span><br><span class="line"></span><br><span class="line">           <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">           String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 生成代理类</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">               proxyName, interfaces, accessFlags);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 加载代理，并返回对象</span></span><br><span class="line">               <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                   proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="ProxyGenerator"><a href="#ProxyGenerator" class="headerlink" title="ProxyGenerator"></a>ProxyGenerator</h5><p>ProxyGenerator是Proxy的一个内部类，用于动态生成class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">        ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">        <span class="comment">// 生成class</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line">        <span class="comment">// 是否保存到文件,如果开启了之后，运行程序之后会在包下面生成class文件</span></span><br><span class="line">        <span class="keyword">if</span>(saveGeneratedFiles) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                        Path var2;</span><br><span class="line">                        <span class="keyword">if</span>(var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            Path var3 = Paths.get(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">'.'</span>, File.separatorChar), <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">                            Files.createDirectories(var3, <span class="keyword">new</span> FileAttribute[<span class="number">0</span>]);</span><br><span class="line">                            var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">".class"</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            var2 = Paths.get(var0 + <span class="string">".class"</span>, <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var4x) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var4x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="代理类的生成"><a href="#代理类的生成" class="headerlink" title="代理类的生成"></a>代理类的生成</h5><p>由于设置了sun.misc.ProxyGenerator.saveGeneratedFiles为true，所以可以在包下面看到生成的代理类$Proxy0：</p>
<p><img src="/images/proxy.jpg" alt=""> </p>
<ol>
<li>它继承了Proxy并实现了Subject，并且在构造函数中需要传入InvocationHandler对象</li>
<li><strong>当执行$Proxy0中的execute方法时，实际上调用的是InvocationHandler的invoke方法</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.bean.Subject;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态生成了一个$Proxy0类，它继承了Proxy并实现了Subject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="comment">// 传入InvocationHandler对象</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Subject的execute方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用了InvocationHandler的invoke方法</span></span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>)).intValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.Object"</span>)&#125;);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.example.demo.bean.Subject"</span>).getMethod(<span class="string">"execute"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>JDK的动态代理实现原理是在运行中动态生成代理类，这个代理类实现了Subject接口，在对代理类进行实例化的时候，需要传入InvocationHandler，当调用代理类的方法时，会执行InvocationHandler的invoke方法，从而完成代理功能。</p>
<p><strong>参考</strong></p>
<p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=393#/detail/pc?id=4274" target="_blank" rel="noopener">【拉勾教育】Dubbo源码解读与实战-代理模式与常见实现</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/02/【Dubbo】Dubbo SPI机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/02/【Dubbo】Dubbo SPI机制/" itemprop="url">【Dubbo】Dubbo SPI机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-09-02T21:10:00+08:00">
                2021-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h3><p>在Dubbo的源码中，可以看到很多地方使用了ExtensionLoader来获取具体的扩展类，以Protocol为例，Protocol是一个接口，它可以有多种协议，那么具体选择哪一种协议呢，就是通过ExtensionLoader的getExtensionLoader方法获取Protocol对应的ExtensionLoader对象，然后调用其getAdaptiveExtension方法获取具体的实现类的，它可以根据配置选择不同的协议：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol PROTOCOL = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>
<p>可以看到Protocol使用到了@SPI注解，默认使用dubbo协议：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> List&lt;ProtocolServer&gt; <span class="title">getServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在META-INF/dubbo下面可以看到dubbo对应的类为org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br></pre></td></tr></table></figure>
<p>因为META-INF下dubbo对应的扩展类为DubboProtocol，所以通过ExtensionLoader获取Protocol具体的实现类时，如果没有指定协议，将默认使用DubboProtocol。</p>
<p>Dubbo还使用了自适应扩展机制，也就是@Adaptive，它可以加载类上，也可以加在某个方法上，加在某个方法中时，会动态生成字节码创建自适应对象Protocol$Adaptive，Protocol$Adaptive中会根据url中的协议选择不同的实现类。接下来就进入ExtensionLoader中看一下SPI机制的实现原理。</p>
<h3 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a>ExtensionLoader</h3><h4 id="getExtensionLoader方法"><a href="#getExtensionLoader方法" class="headerlink" title="getExtensionLoader方法"></a>getExtensionLoader方法</h4><p>EXTENSION_LOADERS：缓存每个class对象对应的ExtensionLoader，dubbo会为每个class都创建一个ExtensionLoader对象。</p>
<p>getExtensionLoader方法用来根据class对象获取对应的ExtensionLoader，就是从EXTENSION_LOADERS获取的，如果为空，会创建一个ExtensionLoader对象并放入EXTENSION_LOADERS中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtensionLoader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个map，key为class类型，value为对应的ExtensionLoader对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据class类型获取ExtensionLoader</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type ("</span> + type + <span class="string">") is not an interface!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type ("</span> + type +</span><br><span class="line">                    <span class="string">") is not an extension, because it is NOT annotated with @"</span> + SPI.class.getSimpleName() + <span class="string">"!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建一个ExtensionLoader对象并放入EXTENSION_LOADERS中</span></span><br><span class="line">            EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">            loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回ExtensionLoader对象</span></span><br><span class="line">        <span class="keyword">return</span> loader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ExtensionLoader中还有一个getExtension方法，它可以根据名称来获取对应的实现类，比如自定义了一个Protocol的实现类MyDubboProtocol:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDubboProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在META-INF/dubbo下面配置一个自定义的协议，key为mydubbo，value为MyDubboProtocol全限定类名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydubbo=org.apache.dubbo.rpc.protocol.dubbo.MyDubboProtocol</span><br></pre></td></tr></table></figure>
<p>接下来通过ExtensionLoader的getExtension方法中传入mydubbo就可以获取到MyDubboProtocol：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时获取的Protocol类型就是MyDubboProtocol</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol PROTOCOL = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(<span class="string">"mydubbo"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="getExtension方法"><a href="#getExtension方法" class="headerlink" title="getExtension方法"></a>getExtension方法</h4><p>getExtension方法，会根据传入的名称获取对应的实例化对象，如果对象为空，会调用createExtension方法创建扩展对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据名称获取对象</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"true"</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);</span><br><span class="line">    <span class="comment">// 获取实例对象</span></span><br><span class="line">    Object instance = holder.get();</span><br><span class="line">    <span class="comment">// 如果对象为空</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            <span class="comment">// 再次获取判断是否为空</span></span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建createExtension对象</span></span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                <span class="comment">// 放入holder</span></span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>createExtension</strong></p>
<p>createExtension方法用于创建扩展对象：</p>
<ol>
<li>它会调用getExtensionClasses获取所有的class</li>
<li>根据传入的名称name获取class对象</li>
<li>根据第2步获取的class对象，从EXTENSION_INSTANCES（缓存了每个class对应的实例化对象）中获取class对应的实例化对象，如果为空，通过newInstance实例化一个对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存每个class对象对应的实例化对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用getExtensionClasses，根据名称获取对应的class</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据class获取对应的实例</span></span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为空，创建一个对象</span></span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注入</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        initExtension(instance);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension instance (name: "</span> + name + <span class="string">", class: "</span> +</span><br><span class="line">                type + <span class="string">") couldn't be instantiated: "</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getExtensionClasses</strong></p>
<p>getExtensionClasses用于获取所有的扩展类的class信息，如果为空调用loadExtensionClasses方法加载所有的class信息，并放入一个map中，将map封装为一个Holer对象，也就是cachedClasse：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有的class</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用loadExtensionClasses加载所有的class</span></span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如dubbo协议，key为dubbo，value为org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol，在getExtensionClasses方法中就会将这些信息放入到cachedClasses中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br></pre></td></tr></table></figure>
<p><strong>loadExtensionClasses</strong></p>
<p>loadExtensionClasses加载所有的扩展类的class信息，它会遍历所有的加载策略，从对应的目录下加载class信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载class</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    cacheDefaultExtensionName();</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历所有的加载策略</span></span><br><span class="line">    <span class="keyword">for</span> (LoadingStrategy strategy : strategies) &#123;</span><br><span class="line">        <span class="comment">// 从目录下加载class信息</span></span><br><span class="line">        loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">        loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="LoadingStrategy"><a href="#LoadingStrategy" class="headerlink" title="LoadingStrategy"></a>LoadingStrategy</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loadLoadingStrategies获取所有的加载策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LoadingStrategy[] strategies = loadLoadingStrategies();</span><br><span class="line"><span class="comment">// 获取所有的加载策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LoadingStrategy[] loadLoadingStrategies() &#123;</span><br><span class="line">    <span class="keyword">return</span> stream(load(LoadingStrategy.class).spliterator(), <span class="keyword">false</span>)</span><br><span class="line">            .sorted()</span><br><span class="line">            .toArray(LoadingStrategy[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LoadingStrategy是一个接口，它有四个实现类：<br><img src="/images/LoadingStrategy.jpeg" alt=""> </p>
<p>以DubboLoadingStrategy为例，可以看到directory的值为”META-INF/dubbo/“，所以loadExtensionClasses中会加载META-INF/dubbo/下的所有配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboLoadingStrategy</span> <span class="keyword">implements</span> <span class="title">LoadingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">directory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"META-INF/dubbo/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">overridden</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NORMAL_PRIORITY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Adaptive自适应扩展"><a href="#Adaptive自适应扩展" class="headerlink" title="Adaptive自适应扩展"></a>Adaptive自适应扩展</h4><p>在最开始，获取Protocol的时候调用的是getAdaptiveExtension方法，并且Protocol的export和refer上添加了@Adaptive注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol PROTOCOL = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> List&lt;ProtocolServer&gt; <span class="title">getServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getAdaptiveExtension</strong></p>
<p>getAdaptiveExtension方法用来获取自适应扩展对象，如果为空，将会调用createAdaptiveExtension创建扩展对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Object&gt; cachedAdaptiveInstance = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取</span></span><br><span class="line">    Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="comment">// 如果为空</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to create adaptive instance: "</span> +</span><br><span class="line">                    createAdaptiveInstanceError.toString(),</span><br><span class="line">                    createAdaptiveInstanceError);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">            instance = cachedAdaptiveInstance.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 创建自适应Extension对象</span></span><br><span class="line">                    instance = createAdaptiveExtension();</span><br><span class="line">                    cachedAdaptiveInstance.set(instance);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    createAdaptiveInstanceError = t;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to create adaptive instance: "</span> + t.toString(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>createAdaptiveExtension</strong></p>
<p>createAdaptiveExtension用于创建自适应扩展对象，它会通过AdaptiveClassCodeGenerator动态生成字节码，创建代理对象XXX$Adaptive：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 创建自适应Extension对象</span></span><br><span class="line">         <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can't create adaptive extension "</span> + type + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 获取自适应Extension class</span></span><br><span class="line"> <span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">     getExtensionClasses();</span><br><span class="line">     <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 创建自适应Extension Class</span></span><br><span class="line">     <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">     <span class="comment">// 创建AdaptiveClassCodeGenerator自适应代码生成对象，动态生成字节码</span></span><br><span class="line">     String code = <span class="keyword">new</span> AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();</span><br><span class="line">     ClassLoader classLoader = findClassLoader();</span><br><span class="line">     org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">     <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>以Protocol为例，会动态生成Protocol$Adaptive类，在Protocol$Adaptive中实现了Protocol接口中的方法，以export为例，它根据url中的协议获取扩展名，再根据名称调用上面提到的getExtension方法获取具体的实现类，所以在这里才会生成DubboProtocol，之后调用DubboProtocol的export方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">dubbo</span>.<span class="title">rpc</span>.<span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Exporter <span class="title">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument == null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"org.apache.dubbo.rpc.Invoker argument getUrl() == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        <span class="comment">// 根据url中的协议获取扩展名</span></span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        <span class="comment">// 根据扩展名获取扩展类</span></span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"The method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"The method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.<span class="function">Invoker <span class="title">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg1;</span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">"dubbo"</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.rpc.Protocol) name from url ("</span> + url.toString() + <span class="string">") use keys([protocol])"</span>);</span><br><span class="line">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.<span class="function">List <span class="title">getServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"The method public default java.util.List org.apache.dubbo.rpc.Protocol.getServers() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考</strong></p>
<p><a href="https://blog.csdn.net/yangbaggio/article/details/97617750" target="_blank" rel="noopener">Dubbo - Dubbo的SPI机制</a></p>
<p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=393#/detail/pc?id=4274" target="_blank" rel="noopener">【拉勾教育】Dubbo源码解读与实战</a></p>
<p><strong>dubbo版本：2.7.7</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/28/【Dubbo】Dubbo服务引用流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/28/【Dubbo】Dubbo服务引用流程/" itemprop="url">【Dubbo】Dubbo服务引用流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-28T21:00:00+08:00">
                2021-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当Provider将服务暴露之后，Consumer就可以通过注册中心进行引用，配置方式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以使用注解@Reference：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"demoServiceComponent"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceComponent</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Reference</span> <span class="comment">// 2.7.0之后推荐使用@DubboReference</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReferenceBean"><a href="#ReferenceBean" class="headerlink" title="ReferenceBean"></a>ReferenceBean</h3><p>dubbo:reference对应ReferenceBean，ReferenceBean实现了FactoryBean和InitializingBean：</p>
<ol>
<li>ReferenceBean是一个FactoryBean，FactoryBean是Spring中的一个工厂bean，通过getObject得到bean对象。</li>
<li>ReferenceBean实现了InitializingBean，同样是Spring中的一个类，通过afterPropertiesSet可以对bean进行初始化。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取bean对象,具体实现在ReferenceConfig中</span></span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        prepareDubboConfigBeans();</span><br><span class="line">        <span class="keyword">if</span> (init == <span class="keyword">null</span>) &#123;</span><br><span class="line">            init = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldInit()) &#123;</span><br><span class="line">            <span class="comment">// 获取对象</span></span><br><span class="line">            getObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReferenceConfig"><a href="#ReferenceConfig" class="headerlink" title="ReferenceConfig"></a>ReferenceConfig</h3><p>ReferenceConfig是ReferenceBean的父类，获取bean的get方法中，对bean进行了判断，如果为空调用init方法进行初始化：</p>
<ol>
<li><p>与Provider服务暴露流程一样，调用了 DubboBootstrap的init进行了初始化</p>
</li>
<li><p>调用createProxy创建代理对象：</p>
<p>（1）判断是本地JVM引用还是远程引用</p>
<p>（2）如果是远程引用，根据url判断是直连的方式还是从注册中心进行引用</p>
<p>（3）会根据具体的协议调用PROTOCOL的refer方法生成Invoker对象</p>
<p>（4）根据Invoker对象创建代理对象</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfigBase</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The invoker of ReferenceConfig("</span> + url + <span class="string">") has already destroyed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始化</span></span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bootstrap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bootstrap = DubboBootstrap.getInstance();</span><br><span class="line">            <span class="comment">// DubboBootstrap进行初始化</span></span><br><span class="line">            bootstrap.init();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        checkAndUpdateSubConfigs();</span><br><span class="line"></span><br><span class="line">        checkStubAndLocal(interfaceClass);</span><br><span class="line">        ConfigValidationUtils.checkMock(interfaceClass, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(SIDE_KEY, CONSUMER_SIDE);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        ref = createProxy(map);</span><br><span class="line"></span><br><span class="line">        serviceMetadata.setTarget(ref);</span><br><span class="line">        serviceMetadata.addAttribute(PROXY_CLASS_REF, ref);</span><br><span class="line">        ConsumerModel consumerModel = repository.lookupReferredService(serviceMetadata.getServiceKey());</span><br><span class="line">        consumerModel.setProxyObject(ref);</span><br><span class="line">        consumerModel.init(attributes);</span><br><span class="line"></span><br><span class="line">        initialized = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dispatch a ReferenceConfigInitializedEvent since 2.7.4</span></span><br><span class="line">        dispatch(<span class="keyword">new</span> ReferenceConfigInitializedEvent(<span class="keyword">this</span>, invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>, <span class="string">"deprecation"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否为本地JVM引用</span></span><br><span class="line">        <span class="keyword">if</span> (shouldJvmRefer(map)) &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">            invoker = REF_PROTOCOL.refer(interfaceClass, url);</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Using injvm service "</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            urls.clear();</span><br><span class="line">            <span class="comment">// 如果url不为空，代表是直连的方式</span></span><br><span class="line">            <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                String[] us = SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">                <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                        URL url = URL.valueOf(u);</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                            url = url.setPath(interfaceName);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                            urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果url为空，代表从注册中心进行引用</span></span><br><span class="line">                <span class="keyword">if</span> (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) &#123;</span><br><span class="line">                    checkRegistry();</span><br><span class="line">                    List&lt;URL&gt; us = ConfigValidationUtils.loadRegistries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                            URL monitorUrl = ConfigValidationUtils.loadMonitor(<span class="keyword">this</span>, u);</span><br><span class="line">                            <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                            &#125;</span><br><span class="line">                            urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果只有一个url</span></span><br><span class="line">            <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用Protocol的refer方法，REF_PROTOCOL使用ExtensionLoader来加载具体的扩展类</span></span><br><span class="line">                invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果有多个</span></span><br><span class="line">                List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">                URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                    invokers.add(REF_PROTOCOL.refer(interfaceClass, url));</span><br><span class="line">                    <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                        registryURL = url; <span class="comment">// use last registry url</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// registry url is available</span></span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    URL u = registryURL.addParameterIfAbsent(CLUSTER_KEY, ZoneAwareCluster.NAME);</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    invoker = CLUSTER.join(<span class="keyword">new</span> StaticDirectory(u, invokers));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//</span></span><br><span class="line">                    invoker = CLUSTER.join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        String metadata = map.get(METADATA_KEY);</span><br><span class="line">        WritableMetadataService metadataService = WritableMetadataService.getExtension(metadata == <span class="keyword">null</span> ? DEFAULT_METADATA_STORAGE_TYPE : metadata);</span><br><span class="line">        <span class="keyword">if</span> (metadataService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            URL consumerURL = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, map.remove(REGISTER_IP_KEY), <span class="number">0</span>, map.get(INTERFACE_KEY), map);</span><br><span class="line">            metadataService.publishServiceDefinition(consumerURL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> (T) PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Invoker的创建"><a href="#Invoker的创建" class="headerlink" title="Invoker的创建"></a>Invoker的创建</h3><p>Protocol使用ExtensionLoader来加载具体的扩展类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol REF_PROTOCOL = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>
<p>使用的是registry，因此将会进入RegistryProtocol的refer方法。</p>
<h4 id="RegistryProtocol"><a href="#RegistryProtocol" class="headerlink" title="RegistryProtocol"></a>RegistryProtocol</h4><p>doRefer方法中，会创建RegistryDirectory对象，并调用subscribe进行订阅：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        url = getRegistryUrl(url);</span><br><span class="line">        <span class="comment">// 获取注册中心</span></span><br><span class="line">        Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">        <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">        String group = qs.get(GROUP_KEY);</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">"*"</span>.equals(group)) &#123;</span><br><span class="line">                <span class="keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 服务引用</span></span><br><span class="line">        <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建RegistryDirectory</span></span><br><span class="line">        RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">        directory.setRegistry(registry);</span><br><span class="line">        directory.setProtocol(protocol);</span><br><span class="line">        Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getConsumerUrl().getParameters());</span><br><span class="line">        <span class="comment">// 创建CONSUMER订阅URL</span></span><br><span class="line">        URL subscribeUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">        <span class="keyword">if</span> (directory.isShouldRegister()) &#123;</span><br><span class="line">            directory.setRegisteredConsumerUrl(subscribeUrl);</span><br><span class="line">            registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        directory.buildRouterChain(subscribeUrl);</span><br><span class="line">        <span class="comment">// 向注册中心订阅</span></span><br><span class="line">        directory.subscribe(toSubscribeUrl(subscribeUrl));</span><br><span class="line">        <span class="comment">// 创建Invoker对象</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = cluster.join(directory);</span><br><span class="line">        List&lt;RegistryProtocolListener&gt; listeners = findRegistryProtocolListeners(url);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(listeners)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RegistryInvokerWrapper&lt;T&gt; registryInvokerWrapper = <span class="keyword">new</span> RegistryInvokerWrapper&lt;&gt;(directory, cluster, invoker, subscribeUrl);</span><br><span class="line">        <span class="keyword">for</span> (RegistryProtocolListener listener : listeners) &#123;</span><br><span class="line">            listener.onRefer(<span class="keyword">this</span>, registryInvokerWrapper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> registryInvokerWrapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RegistryDirectory"><a href="#RegistryDirectory" class="headerlink" title="RegistryDirectory"></a>RegistryDirectory</h4><p>RegistryDirectory继承了NotifyListener，是一个监听器。</p>
<p>RegistryDirectory中实现了subscribe方法，可以看到它是通过调用Registry的subscribe实现的，Registry是一个接口，我们使用的是zookeeper注册中心，所以接下来进入ZookeeperRegistry：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">NotifyListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Registry</span></span><br><span class="line">   <span class="keyword">private</span> Registry registry; </span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        setConsumerUrl(url);</span><br><span class="line">        CONSUMER_CONFIGURATION_LISTENER.addNotifyListener(<span class="keyword">this</span>);</span><br><span class="line">        serviceConfigurationListener = <span class="keyword">new</span> ReferenceConfigurationListener(<span class="keyword">this</span>, url);</span><br><span class="line">        <span class="comment">// 1.向注册中心订阅, this当前对象作为监听器对象传入，注意这里的this指的RegistryDirectory，因为是通过RegistryDirectory调用的</span></span><br><span class="line">        <span class="comment">// 2.Registry是一个接口，有不同的实现类，接下来以ZookeeperRegistry为例,进入到ZookeeperRegistry的subscribe方法</span></span><br><span class="line">        registry.subscribe(url, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ZookeeperRegistry"><a href="#ZookeeperRegistry" class="headerlink" title="ZookeeperRegistry"></a>ZookeeperRegistry</h4><h5 id="FailbackRegistry"><a href="#FailbackRegistry" class="headerlink" title="FailbackRegistry"></a>FailbackRegistry</h5><p>subscribe方法在它的父类FailbackRegistry中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.subscribe(url, listener);</span><br><span class="line">        removeFailedSubscribed(url, listener);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 又调用了doSubscribe</span></span><br><span class="line">            doSubscribe(url, listener);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ZookeeperRegistry的doSubscribe方法中，会创建ZK客户端，从注册中心进行订阅，订阅之后会调用notify方法通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">                String root = toRootPath();</span><br><span class="line">                ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.computeIfAbsent(url, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">                ChildListener zkListener = listeners.computeIfAbsent(listener, k -&gt; (parentPath, currentChilds) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String child : currentChilds) &#123;</span><br><span class="line">                        child = URL.decode(child);</span><br><span class="line">                        <span class="keyword">if</span> (!anyServices.contains(child)) &#123;</span><br><span class="line">                            anyServices.add(child);</span><br><span class="line">                            subscribe(url.setPath(child).addParameters(INTERFACE_KEY, child,</span><br><span class="line">                                    Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 创建zk客户端</span></span><br><span class="line">                zkClient.create(root, <span class="keyword">false</span>);</span><br><span class="line">                List&lt;String&gt; services = zkClient.addChildListener(root, zkListener);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(services)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String service : services) &#123;</span><br><span class="line">                        service = URL.decode(service);</span><br><span class="line">                        anyServices.add(service);</span><br><span class="line">                        subscribe(url.setPath(service).addParameters(INTERFACE_KEY, service,</span><br><span class="line">                                Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), listener);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (String path : toCategoriesPath(url)) &#123;</span><br><span class="line">                    ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.computeIfAbsent(url, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">                    ChildListener zkListener = listeners.computeIfAbsent(listener, k -&gt; (parentPath, currentChilds) -&gt; ZookeeperRegistry.<span class="keyword">this</span>.notify(url, k, toUrlsWithEmpty(url, parentPath, currentChilds)));</span><br><span class="line">                    <span class="comment">// 创建zk客户端</span></span><br><span class="line">                    zkClient.create(path, <span class="keyword">false</span>);</span><br><span class="line">                    List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);</span><br><span class="line">                    <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        urls.addAll(toUrlsWithEmpty(url, path, children));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 通知，在FailbackRegistry中实现</span></span><br><span class="line">                notify(url, listener, urls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to subscribe "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FailbackRegistry中的notify方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.dubbo.registry.support.FailbackRegistry中的notify方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify listener == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 继续调用，在AbstractRegistry中实现</span></span><br><span class="line">        doNotify(url, listener, urls);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception t) &#123;</span><br><span class="line">        addFailedNotified(url, listener, urls);</span><br><span class="line">        logger.error(<span class="string">"Failed to notify for subscribe "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractRegistry中的notify实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.computeIfAbsent(url, u -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">        String category = entry.getKey();</span><br><span class="line">        List&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">        categoryNotified.put(category, categoryList);</span><br><span class="line">        <span class="comment">// 调用了listener的notify，前面的流程可知，传入的是RegistryDirectory，所以接下来进入RegistryDirectory的notify方法</span></span><br><span class="line">        listener.notify(categoryList);</span><br><span class="line">        saveProperties(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上可知，最终会调用NotifyListener的notify方法，前面的内容可知，NotifyListener传入的是RegistryDirectory对象，所以会进入到</p>
<p>RegistryDirectory的notify方法，在这个过程中比较关键的一步是toInvokers方法中将url转为Invoker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">NotifyListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; categoryUrls = urls.stream()</span><br><span class="line">                .filter(Objects::nonNull)</span><br><span class="line">                .filter(<span class="keyword">this</span>::isValidCategory)</span><br><span class="line">                .filter(<span class="keyword">this</span>::isNotCompatibleFor26x)</span><br><span class="line">                .collect(Collectors.groupingBy(<span class="keyword">this</span>::judgeCategory));</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 刷新Invoker</span></span><br><span class="line">        refreshOverrideAndInvoker(providerURLs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshOverrideAndInvoker</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// mock zookeeper://xxx?mock=return null</span></span><br><span class="line">        overrideDirectoryUrl();</span><br><span class="line">        <span class="comment">// 刷新Invoker</span></span><br><span class="line">        refreshInvoker(urls);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 刷新Invoker</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(invokerUrls, <span class="string">"invokerUrls should not be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (invokerUrls.size() == <span class="number">1</span></span><br><span class="line">                &amp;&amp; invokerUrls.get(<span class="number">0</span>) != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; EMPTY_PROTOCOL.equals(invokerUrls.get(<span class="number">0</span>).getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">this</span>.forbidden = <span class="keyword">true</span>; </span><br><span class="line">            <span class="keyword">this</span>.invokers = Collections.emptyList();</span><br><span class="line">            routerChain.setInvokers(<span class="keyword">this</span>.invokers);</span><br><span class="line">            destroyAllInvokers(); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.forbidden = <span class="keyword">false</span>; </span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; </span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 转为Invoker</span></span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 转为Invoker</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        String queryProtocols = <span class="keyword">this</span>.queryMap.get(PROTOCOL_KEY);</span><br><span class="line">        <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line">            ......</span><br><span class="line">            keys.add(key);</span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; </span><br><span class="line">            Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (url.hasParameter(DISABLED_KEY)) &#123;</span><br><span class="line">                        enabled = !url.getParameter(DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        enabled = url.getParameter(ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                        <span class="comment">// 根据不同的协议调用对应的refer方法</span></span><br><span class="line">                        invoker = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Failed to refer invoker for interface:"</span> + serviceType + <span class="string">",url:("</span> + url + <span class="string">")"</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123; </span><br><span class="line">                    <span class="comment">// 将Invoker放入缓存</span></span><br><span class="line">                    newUrlInvokerMap.put(key, invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newUrlInvokerMap.put(key, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keys.clear();</span><br><span class="line">        <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="DubboProtocol"><a href="#DubboProtocol" class="headerlink" title="DubboProtocol"></a>DubboProtocol</h4><p>接下来以DubboProtocal为例，进入refer方法中，refer在DubboProtocol的父类AbstractProtocol中实现：</p>
<ol>
<li>调用了getClients创建客户端连接</li>
<li>创建了DubboInvoker</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncToSyncInvoker&lt;&gt;(protocolBindingRefer(type, url));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">protocolBindingRefer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">protocolBindingRefer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建DubboInvoker</span></span><br><span class="line">        DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">        invokers.add(invoker);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建客户端连接</span></span><br><span class="line">    <span class="keyword">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">boolean</span> useShareConnect = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> connections = url.getParameter(CONNECTIONS_KEY, <span class="number">0</span>);</span><br><span class="line">        List&lt;ReferenceCountExchangeClient&gt; shareClients = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (connections == <span class="number">0</span>) &#123;</span><br><span class="line">            useShareConnect = <span class="keyword">true</span>;</span><br><span class="line">            String shareConnectionsStr = url.getParameter(SHARE_CONNECTIONS_KEY, (String) <span class="keyword">null</span>);</span><br><span class="line">            connections = Integer.parseInt(StringUtils.isBlank(shareConnectionsStr) ? ConfigUtils.getProperty(SHARE_CONNECTIONS_KEY,</span><br><span class="line">                    DEFAULT_SHARE_CONNECTIONS) : shareConnectionsStr);</span><br><span class="line">            shareClients = getSharedClient(url, connections);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建ExchangeClient</span></span><br><span class="line">        ExchangeClient[] clients = <span class="keyword">new</span> ExchangeClient[connections];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (useShareConnect) &#123;</span><br><span class="line">                clients[i] = shareClients.get(i);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 初始化客户端</span></span><br><span class="line">                clients[i] = initClient(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">initClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String str = url.getParameter(CLIENT_KEY, url.getParameter(SERVER_KEY, DEFAULT_REMOTING_CLIENT));</span><br><span class="line">        <span class="comment">// 设置一些参数</span></span><br><span class="line">        url = url.addParameter(CODEC_KEY, DubboCodec.NAME);</span><br><span class="line">        url = url.addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT));</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str + <span class="string">","</span> +</span><br><span class="line">                    <span class="string">" supported client type is "</span> + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), <span class="string">" "</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ExchangeClient client;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进行连接</span></span><br><span class="line">            <span class="keyword">if</span> (url.getParameter(LAZY_CONNECT_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                client = <span class="keyword">new</span> LazyConnectExchangeClient(url, requestHandler);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client = Exchangers.connect(url, requestHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to create remoting client for service("</span> + url + <span class="string">"): "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h3><p>在Invoker创建完毕之后，会通过PROXY_FACTORY创建代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory PROXY_FACTORY = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line"><span class="keyword">return</span> (T) PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic));</span><br></pre></td></tr></table></figure>
<p>在dubbo中默认使用Javassist创建代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建InvokerInvocationHandler</span></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InvokerInvocationHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvokerInvocationHandler</span><span class="params">(Invoker&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invoker = handler;</span><br><span class="line">        String serviceKey = invoker.getUrl().getServiceKey();</span><br><span class="line">        <span class="keyword">if</span> (serviceKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.consumerModel = ApplicationModel.getConsumerModel(serviceKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// invoke方法，调用接口的方法时会调用到invoke方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">        &#125;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(methodName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> invoker.toString();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"$destroy"</span>.equals(methodName)) &#123;</span><br><span class="line">                invoker.destroy();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(methodName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> invoker.hashCode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span> &amp;&amp; <span class="string">"equals"</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建RpcInvocation</span></span><br><span class="line">        RpcInvocation rpcInvocation = <span class="keyword">new</span> RpcInvocation(method, invoker.getInterface().getName(), args);</span><br><span class="line">        String serviceKey = invoker.getUrl().getServiceKey();</span><br><span class="line">        rpcInvocation.setTargetServiceUniqueName(serviceKey);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (consumerModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rpcInvocation.put(Constants.CONSUMER_MODEL, consumerModel);</span><br><span class="line">            rpcInvocation.put(Constants.METHOD_MODEL, consumerModel.getMethodModel(method));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(rpcInvocation).recreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考</strong></p>
<p><a href="https://www.cnblogs.com/shoshana-kong/p/14701714.html" target="_blank" rel="noopener">【月染霜华】Dubbo源码分析（六）服务引用的具体流程</a></p>
<p><a href="https://blog.csdn.net/u011464536/article/details/78217924" target="_blank" rel="noopener">【休息的风】dubbo 源码学习笔记 （三） —— dubbo引用服务的过程</a></p>
<p><a href="https://blog.csdn.net/zhaodongchao1992/article/details/105965823" target="_blank" rel="noopener">【峡谷程序猿】Dubbo2.7.6启动原理之Consumer</a></p>
<p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=393#/detail/pc?id=4274" target="_blank" rel="noopener">【拉勾教育】Dubbo源码解读与实战</a></p>
<p><strong>dubbo版本：2.7.7</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/21/【Dubbo】Dubbo服务暴露流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/21/【Dubbo】Dubbo服务暴露流程/" itemprop="url">【Dubbo】Dubbo服务暴露流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-21T23:00:00+08:00">
                2021-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="DubboBootstrapApplicationListener"><a href="#DubboBootstrapApplicationListener" class="headerlink" title="DubboBootstrapApplicationListener"></a>DubboBootstrapApplicationListener</h3><p>DubboBootstrapApplicationListener是一个监听器，可以监听Dubbo的启动或者关闭事件，如果是启动事件，会通过DubboBootstrap启动dubbo。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboBootstrapApplicationListener</span> <span class="keyword">extends</span> <span class="title">OneTimeExecutionApplicationContextEventListener</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">"dubboBootstrapApplicationListener"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DubboBootstrap dubboBootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBootstrapApplicationListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dubboBootstrap = DubboBootstrap.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationContextEvent</span><span class="params">(ApplicationContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是启动事件</span></span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">            onContextRefreshedEvent((ContextRefreshedEvent) event);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123; <span class="comment">// 如果是关闭事件</span></span><br><span class="line">            onContextClosedEvent((ContextClosedEvent) event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextRefreshedEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        dubboBootstrap.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextClosedEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        dubboBootstrap.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DubboBootstrap"><a href="#DubboBootstrap" class="headerlink" title="DubboBootstrap"></a>DubboBootstrap</h3><p>DubboBootstrap是dubbo启动的核心，首先它会调用initialize方法进行一些初始化操作，然后调用exportServices进行服务暴露。</p>
<p>在exportServices中获取所有需要暴露的服务，进行遍历，对每一个服务进行暴露，Dubbo将每一个服务封装为ServiceConfig类型，具体的暴露过程在ServiceConfig的export方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboBootstrap</span> <span class="keyword">extends</span> <span class="title">GenericEventListener</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Start the bootstrap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DubboBootstrap <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            ready.set(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 初始化操作</span></span><br><span class="line">            initialize();</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(NAME + <span class="string">" is starting..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1. 暴露DUBBO服务</span></span><br><span class="line">            exportServices();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Not only provider register</span></span><br><span class="line">            <span class="keyword">if</span> (!isOnlyRegisterProvider() || hasExportedServices()) &#123;</span><br><span class="line">                <span class="comment">// 2. export MetadataService</span></span><br><span class="line">                exportMetadataService();</span><br><span class="line">                <span class="comment">//3. Register the local ServiceInstance if required</span></span><br><span class="line">                registerServiceInstance();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            referServices();</span><br><span class="line">            <span class="keyword">if</span> (asyncExportingFutures.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.awaitFinish();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.warn(NAME + <span class="string">" exportAsync occurred an exception."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ready.set(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(NAME + <span class="string">" is ready."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ready.set(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(NAME + <span class="string">" is ready."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(NAME + <span class="string">" has started."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暴露服务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有的service</span></span><br><span class="line">        configManager.getServices().forEach(sc -&gt; &#123;</span><br><span class="line">            ServiceConfig serviceConfig = (ServiceConfig) sc;</span><br><span class="line">            serviceConfig.setBootstrap(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 是否异步暴露</span></span><br><span class="line">            <span class="keyword">if</span> (exportAsync) &#123;</span><br><span class="line">                ExecutorService executor = executorRepository.getServiceExporterExecutor();</span><br><span class="line">                Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">                    sc.export();</span><br><span class="line">                    exportedServices.add(sc);</span><br><span class="line">                &#125;);</span><br><span class="line">                asyncExportingFutures.add(future);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 服务暴露</span></span><br><span class="line">                sc.export();</span><br><span class="line">                exportedServices.add(sc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ServiceConfig"><a href="#ServiceConfig" class="headerlink" title="ServiceConfig"></a>ServiceConfig</h3><p>在export中，首先会初始化Metadata元数据相关信息，然后调用doExport进行服务暴露，doExport又是调用doExportUrls完成的。</p>
<p>在doExportUrls中，会获取注册中心的地址，因为一个服务可以支持多种协议，所以会遍历每一个协议，对每一个协议的服务进行暴露，向注册中心注册，同时会将当前的服务加入ServiceRepository容器中，服务暴露具体的过程是在doExportUrlsFor1Protocol中完成的。</p>
<p>doExportUrlsFor1Protocol方法中，会判断协议是否为空，如果为空，默认使用dubbo协议，然后根据协议信息构建URL。根据不同的scope会选择不同的暴露方式，包括本地暴露和远程暴露。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfigBase</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!shouldExport()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bootstrap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bootstrap = DubboBootstrap.getInstance();</span><br><span class="line">            bootstrap.init();</span><br><span class="line">        &#125;</span><br><span class="line">        checkAndUpdateSubConfigs();</span><br><span class="line">        <span class="comment">// 初始化Metadata元数据相关信息</span></span><br><span class="line">        serviceMetadata.setVersion(version);</span><br><span class="line">        serviceMetadata.setGroup(group);</span><br><span class="line">        serviceMetadata.setDefaultGroup(group);</span><br><span class="line">        serviceMetadata.setServiceType(getInterfaceClass());</span><br><span class="line">        serviceMetadata.setServiceInterfaceName(getInterface());</span><br><span class="line">        serviceMetadata.setTarget(getRef());</span><br><span class="line">        <span class="comment">// 是否需要延迟暴露</span></span><br><span class="line">        <span class="keyword">if</span> (shouldDelay()) &#123;</span><br><span class="line">            DELAY_EXPORT_EXECUTOR.schedule(<span class="keyword">this</span>::doExport, getDelay(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 暴露服务</span></span><br><span class="line">            doExport();</span><br><span class="line">        &#125;</span><br><span class="line">        exported();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unexported) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The service "</span> + interfaceClass.getName() + <span class="string">" has already unexported!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经暴露过</span></span><br><span class="line">        <span class="keyword">if</span> (exported) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        exported = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(path)) &#123;</span><br><span class="line">            path = interfaceName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 服务暴露</span></span><br><span class="line">        doExportUrls();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取服务容器</span></span><br><span class="line">        ServiceRepository repository = ApplicationModel.getServiceRepository();</span><br><span class="line">        ServiceDescriptor serviceDescriptor = repository.registerService(getInterfaceClass());</span><br><span class="line">        repository.registerProvider(</span><br><span class="line">                getUniqueServiceName(),</span><br><span class="line">                ref,</span><br><span class="line">                serviceDescriptor,</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                serviceMetadata</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 获取注册中心地址</span></span><br><span class="line">        List&lt;URL&gt; registryURLs = ConfigValidationUtils.loadRegistries(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 遍历所有的协议，因为一个服务可以支持多种协议</span></span><br><span class="line">        <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">            <span class="comment">// 构建KEY，存入ServiceRepository中使用</span></span><br><span class="line">            String pathKey = URL.buildKey(getContextPath(protocolConfig)</span><br><span class="line">                    .map(p -&gt; p + <span class="string">"/"</span> + path)</span><br><span class="line">                    .orElse(path), group, version);</span><br><span class="line">            <span class="comment">// 注册服务，添加到ServiceRepository中</span></span><br><span class="line">            repository.registerService(pathKey, interfaceClass);</span><br><span class="line">            serviceMetadata.setServiceKey(pathKey);</span><br><span class="line">            <span class="comment">// 暴露服务</span></span><br><span class="line">            doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 暴露服务 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">        String name = protocolConfig.getName();</span><br><span class="line">        <span class="comment">// 如果为空，默认为dubbo协议</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            name = DUBBO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略了部分代码</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// export service</span></span><br><span class="line">        String host = findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">        Integer port = findConfigedPorts(protocolConfig, name, map);</span><br><span class="line">        <span class="comment">// 构建url</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="string">"/"</span> + path).orElse(path), map);</span><br><span class="line">        <span class="comment">// You can customize Configurator to append extra parameters</span></span><br><span class="line">        <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                    .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取scope</span></span><br><span class="line">        String scope = url.getParameter(SCOPE_KEY);</span><br><span class="line">        <span class="comment">// don't export when none is configured</span></span><br><span class="line">        <span class="keyword">if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果scope不是REMOTE</span></span><br><span class="line">            <span class="keyword">if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                <span class="comment">// 本地方式暴露服务</span></span><br><span class="line">                exportLocal(url);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 远程方式暴露服务</span></span><br><span class="line">            <span class="keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;</span><br><span class="line">                    <span class="comment">// 遍历注册中心地址</span></span><br><span class="line">                    <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                        <span class="comment">// 如果协议是injvm不进行注册</span></span><br><span class="line">                        <span class="keyword">if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 添加动态参数</span></span><br><span class="line">                        url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));</span><br><span class="line">                        <span class="comment">// 添加监控配置</span></span><br><span class="line">                        URL monitorUrl = ConfigValidationUtils.loadMonitor(<span class="keyword">this</span>, registryURL);</span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                                logger.info(<span class="string">"Register dubbo service "</span> + interfaceClass.getName() + <span class="string">" url "</span> + url + <span class="string">" to registry "</span> + registryURL);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to url "</span> + url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class="line">                        String proxy = url.getParameter(PROXY_KEY);</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                            registryURL = registryURL.addParameter(PROXY_KEY, proxy);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 生成Invoker</span></span><br><span class="line">                        Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class="line">                        <span class="comment">// 生成Invoker的包装类</span></span><br><span class="line">                        DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">                        <span class="comment">// 服务暴露</span></span><br><span class="line">                        Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br><span class="line">                        exporters.add(exporter);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to url "</span> + url);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@since</span> 2.7.0</span></span><br><span class="line"><span class="comment">                 * ServiceData Store</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                WritableMetadataService metadataService = WritableMetadataService.getExtension(url.getParameter(METADATA_KEY, DEFAULT_METADATA_STORAGE_TYPE));</span><br><span class="line">                <span class="keyword">if</span> (metadataService != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    metadataService.publishServiceDefinition(url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本地暴露</strong></p>
<p>本地暴露是将服务暴露在本地的JVM中，可以看到协议是injvm：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * always export injvm</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportLocal</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">      URL local = URLBuilder.from(url)</span><br><span class="line">              .setProtocol(LOCAL_PROTOCOL)</span><br><span class="line">              .setHost(LOCALHOST_VALUE)</span><br><span class="line">              .setPort(<span class="number">0</span>)</span><br><span class="line">              .build();</span><br><span class="line">      Exporter&lt;?&gt; exporter = PROTOCOL.export(</span><br><span class="line">              PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, local));</span><br><span class="line">      exporters.add(exporter);</span><br><span class="line">      logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to local registry url : "</span> + local);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>远程暴露</strong></p>
<p>首先会遍历注册中心地址，因为一个服务可以向多个注册中心注册，并且判断协议是否是injvm，如果是的话不进行注册。然后为url添加动态参数和监控相关的配置，接着通过代理工厂PROXY_FACTORY生成服务的Invoker代理类，并且对Invoker进行了一层包装，包装后的类型为DelegateProviderMetaDataInvoker，最后调用PROTOCOL的export进行服务远程暴露。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 远程方式暴露服务</span></span><br><span class="line"><span class="keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;</span><br><span class="line">        <span class="comment">// 遍历注册中心地址</span></span><br><span class="line">        <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">            <span class="comment">// 如果协议是injvm不进行注册</span></span><br><span class="line">            <span class="keyword">if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加动态参数</span></span><br><span class="line">            url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));</span><br><span class="line">            <span class="comment">// 添加监控配置</span></span><br><span class="line">            URL monitorUrl = ConfigValidationUtils.loadMonitor(<span class="keyword">this</span>, registryURL);</span><br><span class="line">            <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class="line">            String proxy = url.getParameter(PROXY_KEY);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                registryURL = registryURL.addParameter(PROXY_KEY, proxy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 生成Invoker</span></span><br><span class="line">            Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class="line">            <span class="comment">// 生成Invoker的包装类</span></span><br><span class="line">            DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 服务暴露</span></span><br><span class="line">            Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br><span class="line">            exporters.add(exporter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to url "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">        DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br><span class="line">        exporters.add(exporter);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h4><p>PROXY_FACTORY是一个ProxyFactory类型的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory PROXY_FACTORY = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>
<p>ProxyFactory类中使用了SPI注解，由此可知，dubbo默认使用javassist生成代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, <span class="keyword">boolean</span> generic)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><p>ServiceConfig中PROTOCOL的实例化如下，可以看到是通过ExtensionLoader进行实例化的，dubbo是支持多种协议的，那么如何根据配置为不同的协议生成不同的Protocol对象，dubbo就是通过ExtensionLoader实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol PROTOCOL = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>
<p>进入Protocol，可以看到使用@SPI注解，并且export方法中使用了@Adaptive注解，通过ExtensionLoader动态生成Protocol$Adaptive类，根据不同的类型决定使用哪种实现类，默认使用dubbo协议DubboProtocol：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DubboProtocol"><a href="#DubboProtocol" class="headerlink" title="DubboProtocol"></a>DubboProtocol</h4><p>dubbo协议的实现在DubboProtocol中，export方法中是具体的服务暴露过程：</p>
<ol>
<li>将Invoker又包装为了DubboExporter，加入到exporterMap</li>
<li>创建服务，最终是通过Exchangers进行的，生成了ExchangeServer对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 服务暴露</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建servicekey</span></span><br><span class="line">        String key = serviceKey(url);</span><br><span class="line">        <span class="comment">// 将invoker转为DubboExporter</span></span><br><span class="line">        DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">        <span class="comment">// 加入到exporterMap</span></span><br><span class="line">        exporterMap.put(key, exporter);</span><br><span class="line">        Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);</span><br><span class="line">        Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">            String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);</span><br><span class="line">            <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"consumer ["</span> + url.getParameter(INTERFACE_KEY) +</span><br><span class="line">                            <span class="string">"], has set stubproxy support event ,but no stub methods founded."</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打开server</span></span><br><span class="line">        openServer(url);</span><br><span class="line">        optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> exporter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        String key = url.getAddress();</span><br><span class="line">        <span class="keyword">boolean</span> isServer = url.getParameter(IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 根据URL判断是否为服务端</span></span><br><span class="line">        <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">            ProtocolServer server = serverMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    server = serverMap.get(key);</span><br><span class="line">                    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 创建server</span></span><br><span class="line">                        serverMap.put(key, createServer(url));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 重置server</span></span><br><span class="line">                server.reset(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 创建server</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ProtocolServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置参数</span></span><br><span class="line">        url = URLBuilder.from(url)</span><br><span class="line">                <span class="comment">// 设置readonly事件当服务关闭的时候</span></span><br><span class="line">                .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())</span><br><span class="line">                <span class="comment">// 设置心跳</span></span><br><span class="line">                .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))</span><br><span class="line">                .addParameter(CODEC_KEY, DubboCodec.NAME)</span><br><span class="line">                .build();</span><br><span class="line">        String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported server type: "</span> + str + <span class="string">", url: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExchangeServer server;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建ExchangeServer</span></span><br><span class="line">            server = Exchangers.bind(url, requestHandler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to start server(url: "</span> + url + <span class="string">") "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        str = url.getParameter(CLIENT_KEY);</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">            <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将ExchangeServer包装为DubboProtocolServer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DubboProtocolServer(server);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exchangers"><a href="#Exchangers" class="headerlink" title="Exchangers"></a>Exchangers</h3><p>进入到Exchangers的bind方法中，可以看到又是通过 ExtensionLoader来生成具体的扩展类的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exchangers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">        <span class="comment">// 获取Exchanger对象</span></span><br><span class="line">        <span class="keyword">return</span> getExchanger(url).bind(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);</span><br><span class="line">        <span class="comment">// 根据类型获取Exchanger</span></span><br><span class="line">        <span class="keyword">return</span> getExchanger(type);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据类型生成Exchanger</span></span><br><span class="line">        <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4><p>Exchanger使用了SPI机制，默认使用HeaderExchanger：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(HeaderExchanger.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Exchanger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bind.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.EXCHANGER_KEY&#125;)</span><br><span class="line">    <span class="function">ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * connect.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.EXCHANGER_KEY&#125;)</span><br><span class="line">    <span class="function">ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HeaderExchanger"><a href="#HeaderExchanger" class="headerlink" title="HeaderExchanger"></a>HeaderExchanger</h4><p>进入到 ExtensionLoader的bind方法，调用了Transporters的bind方法进行ExchangeServer创建的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchanger</span> <span class="keyword">implements</span> <span class="title">Exchanger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"header"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建了HeaderExchangeServer,并且调用了Transporters的bind方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Transporters"><a href="#Transporters" class="headerlink" title="Transporters"></a>Transporters</h3><p>同样使用ExtensionLoader来生成扩展类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transporters</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RemotingServer <span class="title">bind</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handlers == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ChannelHandler handler;</span><br><span class="line">        <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">            handler = handlers[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getTransporter().bind(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transporter <span class="title">getTransporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过ExtensionLoader创建Transporter对象</span></span><br><span class="line">        <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Transporter"><a href="#Transporter" class="headerlink" title="Transporter"></a>Transporter</h4><p>Transporter使用SPI机制，默认为netty，所以底层默认使用netty网络通信：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"netty"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bind a server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     server url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> server</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.apache.dubbo.remoting.Transporters#bind(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">RemotingServer <span class="title">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Connect to a server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     server url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.apache.dubbo.remoting.Transporters#connect(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/dubbo服务暴露流程.jpg" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://blog.csdn.net/zhaodongchao1992/article/details/106011794" target="_blank" rel="noopener">【峡谷程序猿】Dubbo2.7.6之服务暴露流程</a></p>
<p><a href="https://www.jianshu.com/p/aeb6212138db" target="_blank" rel="noopener">【Mr_1214】dubbo-服务暴露过程之网络通信创建</a></p>
<p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=393#/detail/pc?id=4274" target="_blank" rel="noopener">【拉勾教育】Dubbo源码解读与实战</a></p>
<p><strong>dubbo版本：2.7.7</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/01/【Redis】字典/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/01/【Redis】字典/" itemprop="url">【Redis】字典</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-01T23:30:00+08:00">
                2021-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis-字典"><a href="#Redis-字典" class="headerlink" title="Redis 字典"></a>Redis 字典</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>字典是Redis中的一种数据结构，底层使用哈希表实现，一个哈希表中可以存储多个键值对，它的语法如下，其中KEY为键，field和value为值（也是一个键值对）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value</span><br></pre></td></tr></table></figure>
<p>根据Key和field获取value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET key field</span><br></pre></td></tr></table></figure>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="dictht"><a href="#dictht" class="headerlink" title="dictht"></a>dictht</h5><p>dictht是哈希表的数据结构定义：</p>
<ul>
<li>table：哈希表数组，数组中的元素是dictEntry类型的</li>
<li>size：哈希表数组的大小</li>
<li>sizemask：哈希表大小掩码，一般等于size-1</li>
<li>used：已有节点的数量（存储键值对的数量）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p><img src="/images/dictht.jpg" alt=""></p>
<h5 id="dictEntry"><a href="#dictEntry" class="headerlink" title="dictEntry"></a>dictEntry</h5><p>dictEntry是哈希表节点的结构定义：</p>
<ul>
<li>key：键值对中的键</li>
<li>v：键值对中的值</li>
<li>next：由于会出现哈希冲突，所以next是指向下一个节点的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key; <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v; <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p><img src="/images/redis哈希表.jpg" alt=""></p>
<h5 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h5><p>dict是Redis中字典的结构定义：</p>
<ul>
<li>type：指向dictType的指针</li>
<li>privdata</li>
<li>ht[2]：一个dictht类型的数组，数组大小为2，保存了两个哈希表，rehash时使用</li>
<li>rehashidx：记录了当前rehash的进度</li>
<li>pauserehash：rehash暂停标记，大于0表示没有进行rehash</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">void</span> *privdata; <span class="comment">// 私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">// 保存了两个哈希表</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">// rehash的进度标记</span></span><br><span class="line">    <span class="keyword">int16_t</span> pauserehash; </span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*expandAllowed)(<span class="keyword">size_t</span> moreMem, <span class="keyword">double</span> usedRatio);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<p><img src="/images/redis字典.jpg" alt=""></p>
<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>一个键值对放入哈希表的时候，会根据key的值，计算一个hash值，然后根据hash值与哈希表大小掩码做与运算得到一个索引值，索引值决定元素放入哪个哈希桶中（落入哈希表数组哪个索引位置处）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算hash值</span></span><br><span class="line">hash = dictHashKey(d,key)</span><br><span class="line"><span class="comment">// 计算索引</span></span><br><span class="line">idx = hash &amp; d-&gt;ht[table].sizemask;</span><br></pre></td></tr></table></figure>
<p>在进行哈希计算的时候，不可避免会出现哈希冲突，出现哈希冲突的时候，Redis采用<strong>链式哈希</strong>解决冲突，也就是落入同一个桶中的元素，使用链表将这些冲突的元素链起来（dictEntry中的next指针）。</p>
<p><img src="/images/hash冲突.jpg" alt=""></p>
<h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>由于Redis采用<strong>链式哈希</strong>解决冲突，那么在冲突频繁的场景下，链表会变得越来越长，这种情况下查找效率是比较低下的，需要遍历链表对比KEY的值来获取数据，为了处理效率低下的问题，需要对哈希表进行扩容，扩容的过程称为rehash。</p>
<p>在dict结构替中ht保存了两个哈希表，ht[0]用于数据正常的增删改查，ht[1]用于rehash：</p>
<p>（1）正常情况下，所有的增删改查操作都在ht[0]中进行；</p>
<p>（2）需要进行rehash时，会使用ht[1]建立新的哈希表，并将ht[0]中的数据迁移到ht[1]中；</p>
<p>（3）迁移完成后，ht[0]的空间被释放，然后将ht[1]地址赋给ht[0]，ht[1]的大小被设为0，ht[0]重新接收正常的请求，回到了第（1）步的状态；</p>
<h5 id="rehash的触发条件"><a href="#rehash的触发条件" class="headerlink" title="rehash的触发条件"></a>rehash的触发条件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 判断是否需要扩容 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 如果已经处于rehash状态中直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果ht[0]的大小为0，意味着哈希表为空，此时做初始化操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果已经存储的节点数量大于或等于哈希表数组的大小，并且跨域扩容或者（节点数量/哈希表数组大小）大于一个比例，同时根据字典的类型判断是否允许分配内存*/</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio) &amp;&amp;</span><br><span class="line">        dictTypeExpandAllowed(d))</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 进行扩容</span></span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由于扩容需要分配内存，这里检查字典类型分配是否被允许*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dictTypeExpandAllowed</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;type-&gt;expandAllowed == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> d-&gt;type-&gt;expandAllowed(</span><br><span class="line">                    _dictNextPower(d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>) * <span class="keyword">sizeof</span>(dictEntry*),</span><br><span class="line">                    (<span class="keyword">double</span>)d-&gt;ht[<span class="number">0</span>].used / d-&gt;ht[<span class="number">0</span>].size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>d-&gt;ht[0].used/d-&gt;ht[0].size : 节点数量与哈希表数组大小的比例，称作<strong>负载因子</strong>。</p>
<p>dict_force_resize_ratio 的默认值是 5。</p>
</blockquote>
<ol>
<li>ht[0]的大小为0，此时哈希表是空的，相当于对哈希表做一个初始化的操作。</li>
<li>如果哈希表中存储的节点数量大于或者等于哈希表数组的大小，并且哈希表可以扩容或者负载因子大于dict_force_resize_ratio（默认值为5），根据字典的类型判断允许分配内存，满足这三个条件开始扩容。</li>
</ol>
<p><strong>dict_can_resize</strong></p>
<p>dict_can_resize用来判断哈希表是否可以扩容，有两种状态，值分别为1和0，1代表可以扩容，0代表禁用扩容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict_can_resize = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict_can_resize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>updateDictResizePolicy中对dict_can_resize的状态进行了控制，当前没有RDB子进程并且也没有AOF子进程时设置dict_can_resize状态为可扩容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateDictResizePolicy</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有RDB子进程并且也没有AOF子进程</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>)</span><br><span class="line">        dictEnableResize(); <span class="comment">// 启用扩容</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dictDisableResize(); <span class="comment">// 禁用扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="扩容大小"><a href="#扩容大小" class="headerlink" title="扩容大小"></a>扩容大小</h5><p>从代码中可以看到，扩容后哈希表数组的大小为已经存储的节点数量+1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行扩容</span></span><br><span class="line"><span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>一些旧版本中扩容后的大小为已存储节点数量的2倍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h4 id="渐进式hash"><a href="#渐进式hash" class="headerlink" title="渐进式hash"></a>渐进式hash</h4><p>当哈希表存储节点内容比较多时，需要将原来的节点一个一个拷贝到新的哈希表中，此时Redis主线程无法执行其他请求，造成阻塞，影响性能，为了解决这个问题，引入了渐进式hash。</p>
<p>渐进式hash并不会一次把旧节点全部拷贝到新的哈希表中，而是分多次渐进式的完成拷贝，其中rehashidx记录了迁移进度，每一次迁移的过程中会更新rehashidx的值，下一次进行数据迁移的时候，从rehashidx的位置开始迁移，在dictRehash中可以看到迁移的处理：</p>
<ol>
<li>方法传入了一个参数n，代表本次需要迁移几个哈希桶</li>
<li>根据需要迁移哈希桶的数量，循环处理每一个哈希桶：<ul>
<li>如果当前哈希桶中为空，继续下一个桶的处理rehashidx++</li>
<li>如果当前哈希桶不为空，将当前桶中的所有节点迁移到新的哈希表中，然后更新rehashidx的值继续处理下一个桶</li>
</ul>
</li>
<li>如果已经处理够了n个桶，或者哈希表的所有数据已经迁移完毕，则结束迁移。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环处理每一个哈希桶，n为需要迁移哈希桶的数量</span></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="comment">// 如果当前哈希桶没有存储数据</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// rehashidx的值是哈希表数组的某个索引值（指向了某个哈希桶），意味着当前迁移到数组的哪个索引位置处</span></span><br><span class="line">            d-&gt;rehashidx++; <span class="comment">// 继续下一个桶</span></span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">// 如果当前的哈希桶中存储着数据，将哈希桶存储的所有数据迁移到新的哈希表中</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// rehashidx，继续迁移下一个哈希桶</span></span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断ht[0]的节点是否迁移完成 */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 释放ht[0]的空间</span></span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        <span class="comment">// 将ht[0]指向ht[1]</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 重置ht[1]的大小为0</span></span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 设置rehashidx，-1代表rehash结束</span></span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>_dictRehashStep</strong></p>
<p>_dictRehashStep中可以看到调用dictRehash时，每次迁移哈希桶的数量为1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;pauserehash == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li><p>Redis字典底层使用哈希表实现。</p>
</li>
<li><p>键值对放入哈希表的时候，会根据key的值，计算hash值，出现哈希冲突的时候，Redis采用链式哈希解决冲突，使用链表将这些冲突的元素链起来。</p>
</li>
<li><p>由于Redis采用链式哈希解决冲突，那么在冲突频繁的场景下，链表会变得越来越长，这种情况下查找效率是比较低下的，需要遍历链表对比KEY的值来获取数据，为了处理效率低下的问题，需要对哈希表进行扩容，扩容的过程称为rehash。</p>
</li>
<li><p>当哈希表存储节点内容比较多时，进行rehas的时候主线程无法执行其他请求，造成阻塞，影响性能，所以采用了渐进式hash，渐进式hash并不会一次把旧节点全部拷贝到新的哈希表中，而是分多次渐进式的完成拷贝。</p>
</li>
</ol>
<p><strong>参考</strong></p>
<p>黄健宏《Redis设计与实现》</p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a></p>
<p><a href="https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html" target="_blank" rel="noopener">美团针对Redis Rehash机制的探索和实践</a></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">shan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shan</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
