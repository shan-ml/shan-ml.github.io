<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="SHAN">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SHAN">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SHAN">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>SHAN</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SHAN</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/26/【Redis】集群请求命令处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/26/【Redis】集群请求命令处理/" itemprop="url">【Redis】集群请求命令处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-26T23:00:00+08:00">
                2022-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="集群请求命令处理"><a href="#集群请求命令处理" class="headerlink" title="集群请求命令处理"></a>集群请求命令处理</h2><p>在Redis的命令处理函数<code>processCommand</code>（server.c）中有对集群节点的处理，满足以下条件时进入集群节点处理逻辑中：</p>
<ol>
<li>启用了集群模式，通过<code>server.cluster_enabled</code>判断</li>
<li>发送命令的节点不是主节点</li>
<li>收到的命令中包含了key参数或者命令是EXEC，EXEC命令与MULTI结合使用，用于执行事务</li>
</ol>
<p>条件三的判断条件有些绕，<code>!cmdHasMovableKeys(c-&gt;cmd) &amp;&amp; c-&gt;cmd-&gt;firstkey == 0</code>意味着命令中没有key参数,<code>c-&gt;cmd-&gt;proc != execCommand</code>表示当前命令不是EXEC，然后对<code>(!cmdHasMovableKeys(c-&gt;cmd) &amp;&amp; c-&gt;cmd-&gt;firstkey == 0 &amp;&amp; c-&gt;cmd-&gt;proc != execCommand)</code>整体做了取反操作，那么看以下两种情况：</p>
<ul>
<li>如果命令中带有Key，那么<code>!cmdHasMovableKeys(c-&gt;cmd)</code>就已返回false，又因为对整体做了取反操作，所以条件成立，意味着收到命令中带有Key时需要执行重定向处理</li>
<li>如果收到的命令是EXEC，<code>c-&gt;cmd-&gt;proc != execCommand</code>返回false，对整体取反变成true，所以条件也成立，意味着收到EXEC命令的时候执行重定向处理</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 如果启用了集群且发送命令的节点不是主节点，并且收到的命令中包含了key参数或者命令是EXEC时 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_LUA &amp;&amp;</span><br><span class="line">          server.lua_caller-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(!cmdHasMovableKeys(c-&gt;cmd) &amp;&amp; c-&gt;cmd-&gt;firstkey == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != execCommand))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> hashslot;</span><br><span class="line">        <span class="keyword">int</span> error_code;</span><br><span class="line">        <span class="comment">// 查询节点</span></span><br><span class="line">        clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,&amp;hashslot,&amp;error_code);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span> || n != server.cluster-&gt;myself) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;cmd-&gt;proc == execCommand) &#123;</span><br><span class="line">                discardTransaction(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flagTransaction(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重定向</span></span><br><span class="line">            clusterRedirectClient(c,n,hashslot,error_code);</span><br><span class="line">            c-&gt;cmd-&gt;rejected_calls++;</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果参数中有key将会返回1 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmdHasMovableKeys</span><span class="params">(struct redisCommand *cmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (cmd-&gt;getkeys_proc &amp;&amp; !(cmd-&gt;flags &amp; CMD_MODULE)) ||</span><br><span class="line">            cmd-&gt;flags &amp; CMD_MODULE_GETKEYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MULTI命令的处理"><a href="#MULTI命令的处理" class="headerlink" title="MULTI命令的处理"></a>MULTI命令的处理</h3><p>上面说到，如果是<code>EXEC</code>命令时，也会进入到集群节点处理逻辑，<code>EXEC</code>命令一般与<code>MULTI</code>结合使用，用于执行事务。比如以下例子中，使用<code>MULTI</code>开启事务，执行对a账户增1，b账户减1的操作，可以看到返回结果为<code>QUEUED</code>，命令被缓存起来，直到执行<code>EXEC</code>命令，Redis才开始提交命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; INCR a:account</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DECR b:account</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) (integer) <span class="number">1</span></span><br><span class="line"><span class="number">2</span>) (integer) <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>由于集群也需要对<code>EXEC</code>命令处理，所以先看一下<code>MULTI</code>命令的处理逻辑，<strong><code>MULTI</code>命令对应的执行函数为<code>multiCommand</code>，可以看到它在处理的时候为客户端设置了<code>CLIENT_MULTI</code>标记</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"MULTI calls can not be nested"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置CLIENT_MULTI标记</span></span><br><span class="line">    c-&gt;flags |= CLIENT_MULTI;</span><br><span class="line"></span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Redis的命令处理函数中可以找到对<code>CLIENT_MULTI</code>的处理逻辑，<strong>如果客户端标记中有CLIENT_MULTI</strong>，并且当前命令不是EXEC、DISCARD、MULTI、WATCH和RESET，将调用<code>queueMultiCommand</code>函数，对命令进行缓存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 处理MULTI命令 */</span></span><br><span class="line">    <span class="comment">/* 如果客户端标记中有CLIENT_MULTI，并且当前命令不是EXEC、DISCARD、MULTI、WATCH和RESET */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != resetCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        queueMultiCommand(c); <span class="comment">// 加入到multi队列中，先将命令缓存</span></span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnKeys();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MULTI命令结构体定义"><a href="#MULTI命令结构体定义" class="headerlink" title="MULTI命令结构体定义"></a>MULTI命令结构体定义</h4><p>在客户端结构体定义中，可以看到使用了<code>multiState</code>缓存MULTI命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    multiState mstate;      <span class="comment">/* 存储MULTI/EXEC命令的结构体 */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>multiState</strong></p>
<p>MULTI命令对应的结构体为<code>multiState</code>，<code>multiState</code>中使用了<code>multiCmd</code>结构体来缓存具体的命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    multiCmd *commands;     <span class="comment">/* MULTI命令数组 */</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">/* 缓存的命令个数 */</span></span><br><span class="line">    <span class="keyword">int</span> cmd_flags;          <span class="comment">/* 命令标记 */</span></span><br><span class="line">    <span class="keyword">int</span> cmd_inv_flags;      <span class="comment">/* 与cmd_flags一致 */</span></span><br><span class="line">&#125; multiState;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* multi命令 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span> <span class="comment">/* 命令 */</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure>
<h4 id="MULTI命令的缓存"><a href="#MULTI命令的缓存" class="headerlink" title="MULTI命令的缓存"></a>MULTI命令的缓存</h4><p><strong>queueMultiCommand</strong></p>
<p>对MULTI命令缓存的处理在queueMultiCommand函数中，它在multi.c文件中定义：</p>
<ol>
<li>将<code>multiCmd</code>加入到缓存数组<code>c-&gt;mstate.commands</code>中，对命令进行缓存</li>
<li>将当前命令的内容设置到<code>multiCmd</code>中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将当前命令加入到MULTI命令中 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueMultiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MULTI命令</span></span><br><span class="line">    multiCmd *mc;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_DIRTY_EXEC)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c-&gt;mstate.commands = zrealloc(c-&gt;mstate.commands,</span><br><span class="line">            <span class="keyword">sizeof</span>(multiCmd)*(c-&gt;mstate.count+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 到加入MULTI数组中</span></span><br><span class="line">    mc = c-&gt;mstate.commands+c-&gt;mstate.count;</span><br><span class="line">    <span class="comment">// 设置命令</span></span><br><span class="line">    mc-&gt;cmd = c-&gt;cmd;</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    mc-&gt;argc = c-&gt;argc;</span><br><span class="line">    mc-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    <span class="built_in">memcpy</span>(mc-&gt;argv,c-&gt;argv,<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        incrRefCount(mc-&gt;argv[j]);</span><br><span class="line">    <span class="comment">// 缓存的命令数加1</span></span><br><span class="line">    c-&gt;mstate.count++;</span><br><span class="line">    <span class="comment">// 设置客户端标记</span></span><br><span class="line">    c-&gt;mstate.cmd_flags |= c-&gt;cmd-&gt;flags;</span><br><span class="line">    c-&gt;mstate.cmd_inv_flags |= ~c-&gt;cmd-&gt;flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询节点"><a href="#查询节点" class="headerlink" title="查询节点"></a>查询节点</h3><p><strong>getNodeByQuery</strong></p>
<p><strong>getNodeByQuery函数用于根据KEY查询数据所在的节点</strong>，处理逻辑如下：</p>
<ol>
<li><p>如果是EXEC命令，从客户端获取multiState，multiState中缓存了MULTI命令，如果不是MULTI命令，而是单个命令，同样使用multiState来存放命令，之后就可以统一使用multiState来获取请求中的命令</p>
</li>
<li><p>根据命令的个数进行遍历，处理每一个命令</p>
<p>（1）从命令中获取key的个数，处理每一个key</p>
<p>（2）查询每一个key所在的slot</p>
<p>（3）如果处理的是第一个key，根据所属slot获取所在的节点，记为<code>n</code>，有以下三种情况：</p>
<p>​          情况一：未获取到节点（有可能节点已下线但是还未更新状态），记录错误信息为<code>CLUSTER_REDIR_DOWN_UNBOUND</code>，表示key未绑定到slot，返回NULL</p>
<p>​          情况二：<strong>可以查找到节点，并且是当前节点自己，但是key所属slot正在做数据迁出操作（从当前节点迁出）</strong>，此时将<code>migrating_slot</code>置为1</p>
<p>​          情况三：<strong>可以查找到节点，并且不是当前节点自己，但是key所属slot正在迁入到当前节点</strong>，此时将<code>importing_slot</code>置为1</p>
<p>（4）如果处理的不是第一个key，判断当前key所属的slot是否与第一个key的slot一致：</p>
<p>​          情况一：如果不一致，表示不同的key所属的slot不同，将error_code置为<code>CLUSTER_REDIR_CROSS_SLOT</code>，返回NULL</p>
<p>​          情况二：如果一致，将<code>multiple_keys</code>置为1，表示请求中有多个KEY，做一个标记</p>
<p>（5）根据<code>migrating_slot</code>和<code>importing_slot</code>的值判断key所属slot是否正在迁出或者迁入，迁出意味着key对应的数据正在从当前节点迁出到其他节点，迁入意味着key对应的数据正在迁入到当前节点，由于数据未迁移完毕，所以这两种情况都需要<strong>检查key是否在当前节点的数据库中，如果不在意味着当前节点没有该key的数据</strong>，需要记录缺失的KEY的数量，<code>missing_keys</code>增1</p>
</li>
<li><p>根据第二步查询后的结果，进行如下处理：</p>
<ul>
<li><p>未查找到节点，也就是<code>n</code>为空，返回当前节点自己</p>
</li>
<li><p>当前节点不处于正常状态（CLUSTER_OK）</p>
<p>（1）如果未开启allow_reads_when_down（在节点下线时允许读），error_code置为<code>CLUSTER_REDIR_DOWN_STATE</code>，并返回NULL</p>
<p>（2）当前命令中有写标记，error_code置为<code>CLUSTER_REDIR_DOWN_RO_STATE</code>，并返回NULL</p>
<p>（3）非以上两种情况，<strong>表示开启了allow_reads_when_down，并且是读操作，所以当前节点依旧可以处理请求</strong>，继续往下执行</p>
</li>
<li><p>如果数据正在迁出或者正在迁入，并且当前命令是MIGRATE数据迁移的命令，返回当前节点 </p>
</li>
<li><p>如果key所在slot数据正在从当前节点迁出，并且当前节点数据库中有缺失的key，error_code置为<code>CLUSTER_REDIR_ASK</code>并返回迁出到的那个节点</p>
</li>
<li><p>如果key所在slot正在迁入到当前节点，并且当前命令是ASK ，此时<strong>如果请求中有多个KEY并且当前节点存在缺失的KEY，表示有些key不在当前节点</strong>，error_code置为<code>CLUSTER_REDIR_UNSTABLE</code>返回NULL，<strong>否则返回当前节点即可</strong></p>
</li>
<li><p>如果客户端有只读标记、 当前命令不是写命令、<strong>当前节点是从节点并且它的主节点是根据key所属slot查找到的节点</strong>，返回当前节点，因为从节点数据是从master节点同步的，而master节点正是要查找的节点，从节点也可以处理读请求</p>
</li>
<li><p><strong>如果查询到的节点不是当前节点，将error_code置为<code>CLUSTER_REDIR_MOVED</code>，表示数据已经移动到其他节点，此时返回key所属slot对应的实际节点</strong></p>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">clusterNode *<span class="title">getNodeByQuery</span><span class="params">(client *c, struct redisCommand *cmd, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> *hashslot, <span class="keyword">int</span> *error_code)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集群节点</span></span><br><span class="line">    clusterNode *n = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 记录命令中的第一个KEY</span></span><br><span class="line">    robj *firstkey = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> multiple_keys = <span class="number">0</span>;</span><br><span class="line">    multiState *ms, _ms;</span><br><span class="line">    multiCmd mc;</span><br><span class="line">    <span class="keyword">int</span> i, slot = <span class="number">0</span>, migrating_slot = <span class="number">0</span>, importing_slot = <span class="number">0</span>, missing_keys = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (server.cluster_module_flags &amp; CLUSTER_MODULE_FLAG_NO_REDIRECTION)</span><br><span class="line">        <span class="keyword">return</span> myself;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error_code) *error_code = CLUSTER_REDIR_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是EXEC命令 */</span></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == execCommand) &#123;</span><br><span class="line">        <span class="comment">/* 校验是否有CLIENT_MULTI标记 */</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) <span class="keyword">return</span> myself;</span><br><span class="line">        <span class="comment">// 获取multiState</span></span><br><span class="line">        ms = &amp;c-&gt;mstate;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 如果不是MULTI命令，而是单个命令，同样使用multiState来存储命令 */</span></span><br><span class="line">        ms = &amp;_ms;</span><br><span class="line">        _ms.commands = &amp;mc;</span><br><span class="line">        _ms.count = <span class="number">1</span>; <span class="comment">// 命令个数设置为1</span></span><br><span class="line">        mc.argv = argv;</span><br><span class="line">        mc.argc = argc;</span><br><span class="line">        mc.cmd = cmd; <span class="comment">// 设置命令</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据命令的个数进行遍历，处理每一个命令 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ms-&gt;count; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">mcmd</span>;</span></span><br><span class="line">        robj **margv;</span><br><span class="line">        <span class="keyword">int</span> margc, *keyindex, numkeys, j;</span><br><span class="line"></span><br><span class="line">        mcmd = ms-&gt;commands[i].cmd; <span class="comment">// 获取命令</span></span><br><span class="line">        margc = ms-&gt;commands[i].argc;</span><br><span class="line">        margv = ms-&gt;commands[i].argv;</span><br><span class="line"></span><br><span class="line">        getKeysResult result = GETKEYS_RESULT_INIT;</span><br><span class="line">        <span class="comment">// 从命令中获取key的个数</span></span><br><span class="line">        numkeys = getKeysFromCommand(mcmd,margv,margc,&amp;result);</span><br><span class="line">        keyindex = result.keys;</span><br><span class="line">        <span class="comment">// 遍历每一个key</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) &#123;</span><br><span class="line">            <span class="comment">// 获取key</span></span><br><span class="line">            robj *thiskey = margv[keyindex[j]];</span><br><span class="line">            <span class="comment">// 查询key所在的slot</span></span><br><span class="line">            <span class="keyword">int</span> thisslot = keyHashSlot((<span class="keyword">char</span>*)thiskey-&gt;ptr,</span><br><span class="line">                                       sdslen(thiskey-&gt;ptr));</span><br><span class="line">            <span class="comment">// 如果是第一个key</span></span><br><span class="line">            <span class="keyword">if</span> (firstkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* 将第一个key记录在firstkey */</span></span><br><span class="line">                firstkey = thiskey;</span><br><span class="line">                <span class="comment">// 记录slot</span></span><br><span class="line">                slot = thisslot;</span><br><span class="line">                <span class="comment">// 根据slot获取集群节点</span></span><br><span class="line">                n = server.cluster-&gt;slots[slot];</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 如果未获取到节点（有可能节点已下线），记录错误信息，返回NULL */</span></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    getKeysFreeResult(&amp;result);</span><br><span class="line">                    <span class="keyword">if</span> (error_code)</span><br><span class="line">                        *error_code = CLUSTER_REDIR_DOWN_UNBOUND;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 如果根据slot查到的节点是当前节点自己，并且slot正在做数据迁出操作 */</span></span><br><span class="line">                <span class="keyword">if</span> (n == myself &amp;&amp;</span><br><span class="line">                    server.cluster-&gt;migrating_slots_to[slot] != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    migrating_slot = <span class="number">1</span>; <span class="comment">// migrating_slot置为1，标记正在做数据迁出操作</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.cluster-&gt;importing_slots_from[slot] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果key所属的slot正在做数据迁入操作，importing_slot置为1</span></span><br><span class="line">                    importing_slot = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">/* 如果不是第一个key*/</span></span><br><span class="line">                <span class="keyword">if</span> (!equalStringObjects(firstkey,thiskey)) &#123;</span><br><span class="line">                    <span class="comment">// 如果和第一个key的slot不一致，error_code置为CLUSTER_REDIR_CROSS_SLOT</span></span><br><span class="line">                    <span class="keyword">if</span> (slot != thisslot) &#123;</span><br><span class="line">                    </span><br><span class="line">                        getKeysFreeResult(&amp;result);</span><br><span class="line">                        <span class="keyword">if</span> (error_code)</span><br><span class="line">                            *error_code = CLUSTER_REDIR_CROSS_SLOT;    <span class="comment">/* 不同的key所属不同的slot */</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* 标记请求中有多个KEY */</span></span><br><span class="line">                        multiple_keys = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果slot正在迁入或者迁出，检查key是否在当前节点的db中，如果不在记录缺失的KEY的数量 */</span></span><br><span class="line">            <span class="keyword">if</span> ((migrating_slot || importing_slot) &amp;&amp;</span><br><span class="line">                lookupKeyRead(&amp;server.db[<span class="number">0</span>],thiskey) == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                missing_keys++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        getKeysFreeResult(&amp;result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果未查到，返回当前节点自己 */</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">NULL</span>) <span class="keyword">return</span> myself;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前节点的状态不是CLUSTER_OK状态，节点可能处于异常状态，只有在开启了allow_reads_when_down（在节点下线时允许读）并且当前命令是读操作才继续往下处理，否则记录错误信息返回NULL */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;state != CLUSTER_OK) &#123;</span><br><span class="line">         <span class="comment">// 如果设置了节点下线时不允许读</span></span><br><span class="line">        <span class="keyword">if</span> (!server.cluster_allow_reads_when_down) &#123;</span><br><span class="line">            <span class="comment">/* 记录错误信息，返回NULL */</span></span><br><span class="line">            <span class="keyword">if</span> (error_code) *error_code = CLUSTER_REDIR_DOWN_STATE;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;flags &amp; CMD_WRITE) &#123; <span class="comment">// 如果命令中有写标记</span></span><br><span class="line">            <span class="comment">/* The cluster is configured to allow read only commands */</span></span><br><span class="line">            <span class="keyword">if</span> (error_code) *error_code = CLUSTER_REDIR_DOWN_RO_STATE;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Fall through and allow the command to be executed:</span></span><br><span class="line"><span class="comment">             * this happens when server.cluster_allow_reads_when_down is</span></span><br><span class="line"><span class="comment">             * true and the command is not a write command */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新hashslot */</span></span><br><span class="line">    <span class="keyword">if</span> (hashslot) *hashslot = slot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果数据正在迁出或者正在迁入，并且当前命令是MIGRATE数据迁移的命令，返回当前节点 */</span></span><br><span class="line">    <span class="keyword">if</span> ((migrating_slot || importing_slot) &amp;&amp; cmd-&gt;proc == migrateCommand)</span><br><span class="line">        <span class="keyword">return</span> myself;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果key所在slot数据正在迁出，并且当前节点数据库中有缺失的key*/</span></span><br><span class="line">    <span class="keyword">if</span> (migrating_slot &amp;&amp; missing_keys) &#123;</span><br><span class="line">        <span class="comment">// error_code设置为CLUSTER_REDIR_ASK</span></span><br><span class="line">        <span class="keyword">if</span> (error_code) *error_code = CLUSTER_REDIR_ASK;</span><br><span class="line">        <span class="comment">// 返回迁出到的那个节点</span></span><br><span class="line">        <span class="keyword">return</span> server.cluster-&gt;migrating_slots_to[slot];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果key所在slot正在做数据迁入，并且当前命令是ASK */</span></span><br><span class="line">    <span class="keyword">if</span> (importing_slot &amp;&amp;</span><br><span class="line">        (c-&gt;flags &amp; CLIENT_ASKING || cmd-&gt;flags &amp; CMD_ASKING))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果请求中有多个KEY并且有当前节点数据库中有缺失的key</span></span><br><span class="line">        <span class="keyword">if</span> (multiple_keys &amp;&amp; missing_keys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error_code) *error_code = CLUSTER_REDIR_UNSTABLE;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回当前节点</span></span><br><span class="line">            <span class="keyword">return</span> myself;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 是否是写命令 */</span></span><br><span class="line">    <span class="keyword">int</span> is_write_command = (c-&gt;cmd-&gt;flags &amp; CMD_WRITE) ||</span><br><span class="line">                           (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_flags &amp; CMD_WRITE));</span><br><span class="line">    <span class="comment">// 如果客户端有只读标记、当前命令不是写命令，当前节点是从节点并且它的主节点是根据key所属slot查找到节点</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_READONLY &amp;&amp;</span><br><span class="line">        !is_write_command &amp;&amp;</span><br><span class="line">        nodeIsSlave(myself) &amp;&amp;</span><br><span class="line">        myself-&gt;slaveof == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回当前节点即可</span></span><br><span class="line">        <span class="keyword">return</span> myself;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果查询到的节点不是当前节点，将error_code置为CLUSTER_REDIR_MOVED，返回key所属slot对应的实际节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (n != myself &amp;&amp; error_code) *error_code = CLUSTER_REDIR_MOVED;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="根据Key从DB中查询Value"><a href="#根据Key从DB中查询Value" class="headerlink" title="根据Key从DB中查询Value"></a>根据Key从DB中查询Value</h4><p><strong>redisDb</strong></p>
<p>Redis数据库对应的结构体定义为redisDb，里面有个字典类型的对象，存储键值对数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 存储的键值对数据 */</span></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<p><strong>lookupKeyRead</strong></p>
<p>lookupKeyRead函数用于从redisDb中根据key查找数据，最终是调用lookupKey函数完成的，根据Key从字典中查找并返回value：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用lookupKeyReadWithFlags查找</span></span><br><span class="line">    <span class="keyword">return</span> lookupKeyReadWithFlags(db,key,LOOKUP_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    expireIfNeeded(db,key);</span><br><span class="line">    <span class="comment">// 调用lookupKey函数查找</span></span><br><span class="line">    <span class="keyword">return</span> lookupKey(db,key,flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据KEY从字典中进行查找</span></span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="comment">// 如果不为空</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        <span class="keyword">if</span> (!hasActiveChildProcess() &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH))&#123;</span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">                updateLFU(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                val-&gt;lru = LRU_CLOCK();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回value</span></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集群重定向"><a href="#集群重定向" class="headerlink" title="集群重定向"></a>集群重定向</h3><p><strong>clusterRedirectClient</strong></p>
<p>clusterRedirectClient用于集群重定向处理，在getNodeByQuery函数中，根据查询节点的情况对error_code设置了不同的值，在clusterRedirectClient函数中可以看到对error_code的判断，根据error_code的不同，向客户端响应不同的内容：</p>
<ol>
<li>如果error_code是<code>CLUSTER_REDIR_CROSS_SLOT</code>，表示请求中有多个KEY，但是KEY所属slot不在同一个slot中</li>
<li>如果error_code是<code>CLUSTER_REDIR_UNSTABLE</code>，表示请求中有多个KEY并且在一个slot，但是数据可能正在迁入或迁出的过程中，节点中有缺失的KEY，slot处于一个不稳定的状态</li>
<li>如果error_code是<code>CLUSTER_REDIR_DOWN_STATE</code>，表示节点处于下线状态</li>
<li>如果error_code是<code>CLUSTER_REDIR_DOWN_RO_STATE</code>，表示节点处于下线状态，只接收读命令</li>
<li>如果error_code是<code>CLUSTER_REDIR_DOWN_UNBOUND</code>，标识key未绑定到节点，也就是根据key所属slot未查询到节点</li>
<li>如果error_code是<code>CLUSTER_REDIR_MOVED</code>或者<code>CLUSTER_REDIR_ASK</code>：<ul>
<li><strong><code>CLUSTER_REDIR_MOVED</code>表示key所属slot已从当前节点迁出，此时向客户端响应MOVED命令并将迁出后slot以及所在节点ip和端口返回</strong></li>
<li><strong><code>CLUSTER_REDIR_ASK</code>表示key所属slot正在从当前节点迁出的过程中，请求中的key有可能一部分还未迁出，一部分已经迁出完毕，此时向客户端返回ASK命令，并将slot以及迁出到的目标节点的ip和端口返回</strong></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterRedirectClient</span><span class="params">(client *c, clusterNode *n, <span class="keyword">int</span> hashslot, <span class="keyword">int</span> error_code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error_code == CLUSTER_REDIR_CROSS_SLOT) &#123;</span><br><span class="line">        <span class="comment">// 如果是CLUSTER_REDIR_CROSS_SLOT，向客户端回复key不在同一个slot中</span></span><br><span class="line">        addReplyError(c,<span class="string">"-CROSSSLOT Keys in request don't hash to the same slot"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error_code == CLUSTER_REDIR_UNSTABLE) &#123;</span><br><span class="line">        <span class="comment">/* 请求中有多个key并且在一个slot，但是数据可能正在迁入或迁出的过程中,slot并不稳定 */</span></span><br><span class="line">        addReplyError(c,<span class="string">"-TRYAGAIN Multiple keys request during rehashing of slot"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error_code == CLUSTER_REDIR_DOWN_STATE) &#123;</span><br><span class="line">        <span class="comment">// 节点处于下线状态</span></span><br><span class="line">        addReplyError(c,<span class="string">"-CLUSTERDOWN The cluster is down"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error_code == CLUSTER_REDIR_DOWN_RO_STATE) &#123;</span><br><span class="line">        <span class="comment">// 节点已经下线只接收读命令</span></span><br><span class="line">        addReplyError(c,<span class="string">"-CLUSTERDOWN The cluster is down and only accepts read commands"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error_code == CLUSTER_REDIR_DOWN_UNBOUND) &#123;</span><br><span class="line">        <span class="comment">// 如果是CLUSTER_REDIR_DOWN_UNBOUND，表示根据key所属slot未查询到节点</span></span><br><span class="line">        addReplyError(c,<span class="string">"-CLUSTERDOWN Hash slot not served"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error_code == CLUSTER_REDIR_MOVED ||</span><br><span class="line">               error_code == CLUSTER_REDIR_ASK)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">/* 如果是MOVED或者ASK，需要进行请求重定向处理，向客户端返回ASK或者MOVED命令,并将目标节点的ip和端口返回 */</span></span><br><span class="line">        <span class="keyword">int</span> use_pport = (server.tls_cluster &amp;&amp;</span><br><span class="line">                         c-&gt;conn &amp;&amp; connGetType(c-&gt;conn) != CONN_TYPE_TLS);</span><br><span class="line">        <span class="keyword">int</span> port = use_pport &amp;&amp; n-&gt;pport ? n-&gt;pport : n-&gt;port;</span><br><span class="line">        <span class="comment">// 返回响应，包括ASK或者MOVED命令、slot信息、目标节点的ip端口</span></span><br><span class="line">        addReplyErrorSds(c,sdscatprintf(sdsempty(),</span><br><span class="line">            <span class="string">"-%s %d %s:%d"</span>,</span><br><span class="line">            (error_code == CLUSTER_REDIR_ASK) ? <span class="string">"ASK"</span> : <span class="string">"MOVED"</span>,</span><br><span class="line">            hashslot, n-&gt;ip, port));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"getNodeByQuery() unknown error."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考</strong></p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a><br><a href="https://my.oschina.net/u/3474060/blog/952612" target="_blank" rel="noopener">zhaiguanjie-Redis源码剖析</a></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/26/【Redis】集群数据迁移/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/26/【Redis】集群数据迁移/" itemprop="url">【Redis】集群数据迁移</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-26T23:00:00+08:00">
                2022-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis通过对KEY计算hash，将KEY映射到slot，集群中每个节点负责一部分slot的方式管理数据，slot最大个数为16384。<br>在集群节点对应的结构体变量clusterNode中可以看到slots数组，数组的大小为CLUSTER_SLOTS除以8，CLUSTER_SLOTS的值是16384：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTER_SLOTS 16384</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[CLUSTER_SLOTS/<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"> </span><br><span class="line">&#125; clusterNode;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为一个字符占8位，所以数组个数为16384除以8，每一位可以表示一个slot，如果某一位的值为1，表示当前节点负责这一位对应的slot。</p>
</blockquote>
<p><strong>clusterState</strong></p>
<p>clusterNode里面保存了节点相关的信息，集群数据迁移信息并未保存在clusterNode中，而是使用了clusterState结构体来保存：</p>
<ul>
<li>migrating_slots_to数组: 记录当前节点负责的slot迁移到了哪个节点</li>
<li>importing_slots_from数组: 记录当前节点负责的slot是从哪个节点迁入的</li>
<li>slots数组：记录每个slot是由哪个集群节点负责的</li>
<li>slots_keys_count：slot中key的数量</li>
<li>slots_to_keys：是一个字典树，记录KEY和SLOT的对应关系</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    clusterNode *myself;  <span class="comment">/* 当前节点自己 */</span></span><br><span class="line">    clusterNode *migrating_slots_to[CLUSTER_SLOTS];</span><br><span class="line">    clusterNode *importing_slots_from[CLUSTER_SLOTS];</span><br><span class="line">    clusterNode *slots[CLUSTER_SLOTS];</span><br><span class="line">    <span class="keyword">uint64_t</span> slots_keys_count[CLUSTER_SLOTS];</span><br><span class="line">    rax *slots_to_keys;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<p><strong>clusterState与clusterNode的关系</strong></p>
<p><img src="/images/clusterstate.jpg" alt=""></p>
<h2 id="集群数据迁移"><a href="#集群数据迁移" class="headerlink" title="集群数据迁移"></a>集群数据迁移</h2><p>在手动进行数据迁移时，需要执行以下步骤：</p>
<ol>
<li>在源节点和目标节点分别使用<code>CLUSTER  SETSLOT MIGRATING</code>和<code>CLUSTER  SETSLOT IMPORTING</code>标记slot迁出和迁入信息</li>
<li>在源节点使用<code>CLUSTER  GETKEYSINSLOT</code>命令获取待迁出的KEY</li>
<li>在源节点执行<code>MIGRATE</code>命令进行数据迁移，<code>MIGRATE</code>既支持单个KEY的迁移，也支持多个KEY的迁移</li>
<li>在源节点和目标节点使用<code>CLUSTER SETSLOT</code>命令标记slot最终迁移节点</li>
</ol>
<h3 id="标记数据迁移节点"><a href="#标记数据迁移节点" class="headerlink" title="标记数据迁移节点"></a>标记数据迁移节点</h3><p>在进行数据迁移之前，首先在需要迁入的目标节点使用<code>SETSLOT</code>命令标记要将SLOT从哪个节点迁入到当前节点：</p>
<ul>
<li><slot>：哈希槽的值</slot></li>
<li><node>：表示slot所在的节点</node></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER  SETSLOT  &lt;slot&gt;  IMPORTING  &lt;node&gt;</span><br></pre></td></tr></table></figure>
<p>然后在源节点也就是slot所在节点使用<code>MIGRATING</code>命令将数据迁出到目标节点：</p>
<ul>
<li><slot>：哈希槽的值</slot></li>
<li><node>：表示slot要迁出到的目标节点</node></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER  SETSLOT  &lt;slot&gt;  MIGRATING  &lt;node&gt;</span><br></pre></td></tr></table></figure>
<p>比如slot1当前在node1中，需要将slot1迁出到node2,那么首先在nodd2上执行<code>IMPORTING</code>命令，标记slot准备从node1迁到当前节点node2中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER  SETSLOT  slot1  IMPORTING  node1</span><br></pre></td></tr></table></figure>
<p>然后在node1中执行<code>MIGRATING</code>命令标记slot1需要迁移到node2：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER  SETSLOT  slot1  MIGRATING  node2</span><br></pre></td></tr></table></figure>
<p><strong>clusterCommand</strong><br><code>SETSLOT</code>命令的处理在clusterCommand函数（cluster.c文件中）中：</p>
<ol>
<li>校验当前节点是否是从节点，如果当前节点是从节点，返回错误，<code>SETSLOT</code>只能用于主节点</li>
<li>如果是<code>migrating</code>命令，表示slot需要从当前节点迁出到其他节点，处理如下：<br>（1） 如果需要迁移的slot不在当前节点，返回错误<br>（2）如果要迁移到的目标slot节点未查询到，返回错误<br>（3）将当前节点的migrating_slots_to[slot]的值置为迁出到的目标节点，记录slot迁移到了哪个节点</li>
<li>如果是<code>importing</code>命令，表示slot需要从其他节点迁入到当前节点<br>（1）如果要迁移的slot已经在当前节点，返回slot数据已经在当前节点的响应<br>（2）由于importing需要从slot所在节点迁移到当前节点，如果未从集群中查询slot当前所在节点，返回错误信息<br>（3）将当前节点的importing_slots_from[slot]置为slot所在节点，记录slot是从哪个节点迁入到当前节点的</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled == <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"This instance has cluster support disabled"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">2</span> &amp;&amp; !strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"help"</span>)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"setslot"</span>) &amp;&amp; c-&gt;argc &gt;= <span class="number">4</span>) &#123; <span class="comment">// 处理setslot命令</span></span><br><span class="line">        <span class="keyword">int</span> slot;</span><br><span class="line">        clusterNode *n;</span><br><span class="line">        <span class="comment">// 如果当前节点是从节点，返回错误，SETSLOT只能用于主节点</span></span><br><span class="line">        <span class="keyword">if</span> (nodeIsSlave(myself)) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"Please use SETSLOT only with masters."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询slot</span></span><br><span class="line">        <span class="keyword">if</span> ((slot = getSlotOrReply(c,c-&gt;argv[<span class="number">2</span>])) == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 处理migrating迁出</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">3</span>]-&gt;ptr,<span class="string">"migrating"</span>) &amp;&amp; c-&gt;argc == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果需要迁移的slot不在当前节点，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (server.cluster-&gt;slots[slot] != myself) &#123;</span><br><span class="line">                addReplyErrorFormat(c,<span class="string">"I'm not the owner of hash slot %u"</span>,slot);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果要迁移到的目标节点未查询到，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> ((n = clusterLookupNode(c-&gt;argv[<span class="number">4</span>]-&gt;ptr)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                addReplyErrorFormat(c,<span class="string">"I don't know about node %s"</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">4</span>]-&gt;ptr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前节点的migrating_slots_to[slot]置为目标节点，记录slot要迁移到的节点</span></span><br><span class="line">            server.cluster-&gt;migrating_slots_to[slot] = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">3</span>]-&gt;ptr,<span class="string">"importing"</span>) &amp;&amp; c-&gt;argc == <span class="number">5</span>) &#123; <span class="comment">// 处理importing迁入</span></span><br><span class="line">            <span class="comment">// 如果要迁移的slot已经在当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (server.cluster-&gt;slots[slot] == myself) &#123;</span><br><span class="line">                addReplyErrorFormat(c,</span><br><span class="line">                    <span class="string">"I'm already the owner of hash slot %u"</span>,slot);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// importing需要从slot所在节点迁移到当前节点，如果未从集群中查询slot当前所在节点，返回错误信息</span></span><br><span class="line">            <span class="keyword">if</span> ((n = clusterLookupNode(c-&gt;argv[<span class="number">4</span>]-&gt;ptr)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                addReplyErrorFormat(c,<span class="string">"I don't know about node %s"</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">4</span>]-&gt;ptr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录slot是从哪个节点迁移过来的</span></span><br><span class="line">            server.cluster-&gt;importing_slots_from[slot] = n;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 省略其他if else</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyError(c,</span><br><span class="line">                <span class="string">"Invalid CLUSTER SETSLOT action or number of arguments. Try CLUSTER HELP"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_UPDATE_STATE);</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplySubcommandSyntaxError(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取待迁出的key"><a href="#获取待迁出的key" class="headerlink" title="获取待迁出的key"></a>获取待迁出的key</h3><p>在标记完迁入、迁出节点后，就可以使用<code>CLUSTER  GETKEYSINSLOT</code>命令获取待迁出的KEY：</p>
<p><slot>：哈希槽的值</slot></p>
<p><count>：迁出KEY的数量</count></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER  GETKEYSINSLOT  &lt;slot&gt;  &lt;count&gt;</span><br></pre></td></tr></table></figure>
<p><code>getkeysinslot</code>命令的处理也在clusterCommand函数中，处理逻辑如下：</p>
<ol>
<li>从命令中解析slot的值以及count的值，count的值记为maxkeys，并校验合法性</li>
<li>调用countKeysInSlot函数获取slot中key的数量，与maxkeys对比，如果小于maxkeys，就将maxkeys的值更新为slot中key的数量</li>
<li>根据获取key的个数分配相应的内存空间</li>
<li>从slot中获取key并将数据返回给客户端</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled == <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"This instance has cluster support disabled"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">2</span> &amp;&amp; !strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"help"</span>)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"getkeysinslot"</span>) &amp;&amp; c-&gt;argc == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">/* CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt; */</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> maxkeys, slot;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> numkeys, j;</span><br><span class="line">        robj **keys;</span><br><span class="line">        <span class="comment">// 从命令中获取slot的值并转为长整型</span></span><br><span class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;slot,<span class="literal">NULL</span>) != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 从命令中获取key的最大个数并转为长整型</span></span><br><span class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;maxkeys,<span class="literal">NULL</span>)</span><br><span class="line">            != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果slot的值小于0或者大于CLUSTER_SLOTS或者key的最大个数为0</span></span><br><span class="line">        <span class="keyword">if</span> (slot &lt; <span class="number">0</span> || slot &gt;= CLUSTER_SLOTS || maxkeys &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"Invalid slot or number of keys"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 计算slot中key的数量</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> keys_in_slot = countKeysInSlot(slot);</span><br><span class="line">        <span class="comment">// 如果maxkeys大于slot中key的数量，更新maxkeys的值为slot中key的数量</span></span><br><span class="line">        <span class="keyword">if</span> (maxkeys &gt; keys_in_slot) maxkeys = keys_in_slot;</span><br><span class="line">        <span class="comment">// 分配空间</span></span><br><span class="line">        keys = zmalloc(<span class="keyword">sizeof</span>(robj*)*maxkeys);</span><br><span class="line">        <span class="comment">// 从slot中获取key</span></span><br><span class="line">        numkeys = getKeysInSlot(slot, keys, maxkeys);</span><br><span class="line">        addReplyArrayLen(c,numkeys);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) &#123;</span><br><span class="line">            <span class="comment">// 返回key</span></span><br><span class="line">            addReplyBulk(c,keys[j]);</span><br><span class="line">            decrRefCount(keys[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(keys);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplySubcommandSyntaxError(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><h4 id="源节点数据迁移"><a href="#源节点数据迁移" class="headerlink" title="源节点数据迁移"></a>源节点数据迁移</h4><p>完成上两步之后，接下来需要在源节点中执行<code>MIGRATE</code>命令进行数据迁移，<code>MIGRATE</code>既支持单个KEY的迁移，也支持多个KEY的迁移，语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 单个KEY</span><br><span class="line">MIGRATE host port key dbid timeout [COPY | REPLACE | AUTH password | AUTH2 username password]</span><br><span class="line">                                    </span><br><span class="line"><span class="meta">#</span> 多个KEY</span><br><span class="line">MIGRATE host port "" dbid timeout [COPY | REPLACE | AUTH password | AUTH2 username password] KEYS key2 ... keyN</span><br></pre></td></tr></table></figure>
<ul>
<li>host：ip地址</li>
<li>Port：端口</li>
<li>key：迁移的key</li>
<li>KEYS：如果一次迁移多个KEY，使用KEYS，后跟迁移的key1 … keyN</li>
<li>dbid：数据库id</li>
<li><strong>COPY：如果目标节点已经存在迁移的key，则报错，如果目标节点不存在迁移的key，则正常进行迁移，在迁移完成后删除源节点中的key</strong></li>
<li><strong>REPLACE：如果目标节点不存在迁移的key，正常进行迁移，如果目标节点存在迁移的key，进行替换，覆盖目标节点中已经存在的key</strong></li>
<li>AUTH：验证密码</li>
</ul>
<p><strong>migrateCommand</strong></p>
<p><code>MIGRATE</code>命令对应的处理函数在migrateCommand中（cluster.c文件中），处理逻辑如下：</p>
<ol>
<li>解析命令中的参数，判断是否有replace、auth、keys等参数<ul>
<li>如果有replace参数，表示在迁移数据时如果key已经在目标节点存在，进行替换</li>
<li>如果有keys参数，表示命令中有多个key，计算命令中key的个数记为num_keys</li>
</ul>
</li>
<li>处理命令中解析到的所有key，调用lookupKeyRead函数查找key：<ul>
<li>如果查找到，将key放入kv对象中，<strong>kv中存储实际要处理的KEY，value放入ov对象中，ov中存储key对应的value</strong></li>
<li>如果未查找到key，跳过当前key，处理下一个key</li>
</ul>
</li>
<li>因为有部分key可能未查询到，所以更新实际需要处理的key的数量num_keys</li>
<li>根据命令中的ip端口信息，与目标节点建立连接</li>
<li>调用rioInitWithBuffer函数初始化一块缓冲区</li>
<li>处理实际需要迁移的key，主要是将数据填入缓冲区<ul>
<li>根据key获取过期时间，如果已过期不进行处理</li>
<li>判断是否开启了集群，如果开启了集群将<code>RESTORE-ASKING</code>写入缓冲区，如果未开启，写入RESTORE命令</li>
<li>将key写入缓冲区</li>
<li><strong>调用createDumpPayload函数，创建payload，将RDB版本、CRC64校验和以及value内容写入 </strong>，目标节点收到数据时需要进行校验</li>
<li>将payload数据填充到缓冲区</li>
</ul>
</li>
<li><strong>将缓冲区的数据按照64K的块大小发送到目标节点</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">migrateCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">    robj **ov = <span class="literal">NULL</span>; <span class="comment">/* 保存要迁移的key对应的value */</span></span><br><span class="line">    robj **kv = <span class="literal">NULL</span>; <span class="comment">/* 保存要迁移的key. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> first_key = <span class="number">3</span>; <span class="comment">/* 第一个key */</span></span><br><span class="line">    <span class="keyword">int</span> num_keys = <span class="number">1</span>;  <span class="comment">/* 迁移key的数量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析命令中的参数 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">6</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> moreargs = (c-&gt;argc<span class="number">-1</span>) - j;</span><br><span class="line">        <span class="comment">// 如果是copy</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">"copy"</span>)) &#123;</span><br><span class="line">            copy = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">"replace"</span>)) &#123; <span class="comment">// 如果是replace</span></span><br><span class="line">            replace = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">"auth"</span>)) &#123; <span class="comment">// 如果需要验证密码</span></span><br><span class="line">            <span class="keyword">if</span> (!moreargs) &#123;</span><br><span class="line">                addReplyErrorObject(c,shared.syntaxerr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="comment">// 获取密码</span></span><br><span class="line">            password = c-&gt;argv[j]-&gt;ptr;</span><br><span class="line">            redactClientCommandArgument(c,j);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">"auth2"</span>)) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">"keys"</span>)) &#123; <span class="comment">// 如果一次迁移多个key</span></span><br><span class="line">            <span class="keyword">if</span> (sdslen(c-&gt;argv[<span class="number">3</span>]-&gt;ptr) != <span class="number">0</span>) &#123;</span><br><span class="line">                addReplyError(c,</span><br><span class="line">                    <span class="string">"When using MIGRATE KEYS option, the key argument"</span></span><br><span class="line">                    <span class="string">" must be set to the empty string"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 或取第一个key</span></span><br><span class="line">            first_key = j+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 计算key的数量</span></span><br><span class="line">            num_keys = c-&gt;argc - j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* All the remaining args are keys. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyErrorObject(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 校验timeout和dbid的值 */</span></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">5</span>],&amp;timeout,<span class="literal">NULL</span>) != C_OK ||</span><br><span class="line">        getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">4</span>],&amp;dbid,<span class="literal">NULL</span>) != C_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果超时时间小于0，默认设置1000毫秒</span></span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) timeout = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间，kv记录在源节点中实际查找到的key</span></span><br><span class="line">    ov = zrealloc(ov,<span class="keyword">sizeof</span>(robj*)*num_keys);</span><br><span class="line">    kv = zrealloc(kv,<span class="keyword">sizeof</span>(robj*)*num_keys);</span><br><span class="line">    <span class="keyword">int</span> oi = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 处理KEY</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num_keys; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果可以从源节点查找到key</span></span><br><span class="line">        <span class="keyword">if</span> ((ov[oi] = lookupKeyRead(c-&gt;db,c-&gt;argv[first_key+j])) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录查找到的key</span></span><br><span class="line">            kv[oi] = c-&gt;argv[first_key+j];</span><br><span class="line">            <span class="comment">// 记录查找到的个数</span></span><br><span class="line">            oi++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只处理实际查找到的key</span></span><br><span class="line">    num_keys = oi;</span><br><span class="line">    <span class="comment">// 如果为0，不进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(ov); zfree(kv); <span class="comment">// 释放空间</span></span><br><span class="line">        addReplySds(c,sdsnew(<span class="string">"+NOKEY\r\n"</span>)); <span class="comment">// 返回NOKEY响应</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">try_again:</span><br><span class="line">    write_error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 与目标节点建立连接 */</span></span><br><span class="line">    cs = migrateGetSocket(c,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],timeout);</span><br><span class="line">    <span class="keyword">if</span> (cs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        zfree(ov); zfree(kv);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* error sent to the client by migrateGetSocket() */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化缓冲区</span></span><br><span class="line">    rioInitWithBuffer(&amp;cmd,sdsempty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果密码不为空，验证密码 */</span></span><br><span class="line">    <span class="keyword">if</span> (password) &#123;</span><br><span class="line">        <span class="keyword">int</span> arity = username ? <span class="number">3</span> : <span class="number">2</span>;</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkCount(&amp;cmd,<span class="string">'*'</span>,arity));</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkString(&amp;cmd,<span class="string">"AUTH"</span>,<span class="number">4</span>));</span><br><span class="line">        <span class="keyword">if</span> (username) &#123;</span><br><span class="line">            serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkString(&amp;cmd,username,</span><br><span class="line">                                 sdslen(username)));</span><br><span class="line">        &#125;</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkString(&amp;cmd,password,</span><br><span class="line">            sdslen(password)));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理KEY，只保留未过期的KEY</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num_keys; j++) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ttl = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取KEY的过期时间，返回-1表示未设置过期时间，否则返回过期时间</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> expireat = getExpire(c-&gt;db,kv[j]);</span><br><span class="line">        <span class="comment">// 如果设置了过期时间</span></span><br><span class="line">        <span class="keyword">if</span> (expireat != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算ttl：过期时间减去当前时间</span></span><br><span class="line">            ttl = expireat-mstime();</span><br><span class="line">            <span class="comment">// 如果已过期</span></span><br><span class="line">            <span class="keyword">if</span> (ttl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ttl &lt; <span class="number">1</span>) ttl = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 记录未过期的KEY */</span></span><br><span class="line">        ov[non_expired] = ov[j];</span><br><span class="line">        kv[non_expired++] = kv[j];</span><br><span class="line"></span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,</span><br><span class="line">            rioWriteBulkCount(&amp;cmd,<span class="string">'*'</span>,replace ? <span class="number">5</span> : <span class="number">4</span>));</span><br><span class="line">        <span class="comment">// 是否启用集群</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled)</span><br><span class="line">            serverAssertWithInfo(c,<span class="literal">NULL</span>,</span><br><span class="line">                rioWriteBulkString(&amp;cmd,<span class="string">"RESTORE-ASKING"</span>,<span class="number">14</span>)); <span class="comment">// 将RESTORE-ASKING命令写入缓冲区</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkString(&amp;cmd,<span class="string">"RESTORE"</span>,<span class="number">7</span>)); <span class="comment">// 如果未开启集群将RESTORE命令写入缓冲区</span></span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,sdsEncodedObject(kv[j]));</span><br><span class="line">        <span class="comment">// 将key写入缓冲区</span></span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkString(&amp;cmd,kv[j]-&gt;ptr,</span><br><span class="line">                sdslen(kv[j]-&gt;ptr)));</span><br><span class="line">        <span class="comment">// 将ttl写入缓存区</span></span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkLongLong(&amp;cmd,ttl));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 创建payload，将RDB版本、CRC64校验和以及value内容写入 */</span></span><br><span class="line">        createDumpPayload(&amp;payload,ov[j],kv[j]);</span><br><span class="line">        <span class="comment">// 将payload数据写入缓冲区</span></span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,</span><br><span class="line">            rioWriteBulkString(&amp;cmd,payload.io.buffer.ptr,</span><br><span class="line">                               sdslen(payload.io.buffer.ptr)));</span><br><span class="line">        sdsfree(payload.io.buffer.ptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果设置了REPLACE参数，将REPLACE写入缓冲区 */</span></span><br><span class="line">        <span class="keyword">if</span> (replace)</span><br><span class="line">            serverAssertWithInfo(c,<span class="literal">NULL</span>,rioWriteBulkString(&amp;cmd,<span class="string">"REPLACE"</span>,<span class="number">7</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新实际需要处理的key */</span></span><br><span class="line">    num_keys = non_expired;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将缓冲区的数据按照64K的块大小发送到目标节点 */</span></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        sds buf = cmd.io.buffer.ptr;</span><br><span class="line">        <span class="keyword">size_t</span> pos = <span class="number">0</span>, towrite;</span><br><span class="line">        <span class="keyword">int</span> nwritten = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((towrite = sdslen(buf)-pos) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 需要发送的数据，如果超过了64K就按照64K的大小发送</span></span><br><span class="line">            towrite = (towrite &gt; (<span class="number">64</span>*<span class="number">1024</span>) ? (<span class="number">64</span>*<span class="number">1024</span>) : towrite);</span><br><span class="line">            <span class="comment">// 发送数据</span></span><br><span class="line">            nwritten = connSyncWrite(cs-&gt;conn,buf+pos,towrite,timeout);</span><br><span class="line">            <span class="keyword">if</span> (nwritten != (<span class="keyword">signed</span>)towrite) &#123;</span><br><span class="line">                write_error = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">goto</span> socket_err;</span><br><span class="line">            &#125;</span><br><span class="line">            pos += nwritten;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>createDumpPayload</strong></p>
<p>createDumpPayload函数在cluster.c文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * DUMP, RESTORE and MIGRATE commands</span></span><br><span class="line"><span class="comment"> * -------------------------------------------------------------------------- */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createDumpPayload</span><span class="params">(rio *payload, robj *o, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">uint64_t</span> crc;</span><br><span class="line">    <span class="comment">// 初始化缓冲区</span></span><br><span class="line">    rioInitWithBuffer(payload,sdsempty());</span><br><span class="line">    <span class="comment">// 将value的数据类型写入缓冲区</span></span><br><span class="line">    serverAssert(rdbSaveObjectType(payload,o));</span><br><span class="line">    <span class="comment">// 将value写入缓冲区</span></span><br><span class="line">    serverAssert(rdbSaveObject(payload,o,key));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the footer, this is how it looks like:</span></span><br><span class="line"><span class="comment">     * ----------------+---------------------+---------------+</span></span><br><span class="line"><span class="comment">     * ... RDB payload | 2 bytes RDB version | 8 bytes CRC64 |</span></span><br><span class="line"><span class="comment">     * ----------------+---------------------+---------------+</span></span><br><span class="line"><span class="comment">     * RDB version and CRC are both in little endian.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置RDB版本 */</span></span><br><span class="line">    buf[<span class="number">0</span>] = RDB_VERSION &amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">1</span>] = (RDB_VERSION &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    payload-&gt;io.buffer.ptr = sdscatlen(payload-&gt;io.buffer.ptr,buf,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置CRC64校验和用于校验数据 */</span></span><br><span class="line">    crc = crc64(<span class="number">0</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)payload-&gt;io.buffer.ptr,</span><br><span class="line">                sdslen(payload-&gt;io.buffer.ptr));</span><br><span class="line">    memrev64ifbe(&amp;crc);</span><br><span class="line">    payload-&gt;io.buffer.ptr = sdscatlen(payload-&gt;io.buffer.ptr,&amp;crc,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="目标节点处理数据"><a href="#目标节点处理数据" class="headerlink" title="目标节点处理数据"></a>目标节点处理数据</h4><p><strong>restoreCommand</strong></p>
<p>目标节点收到迁移的数据的处理逻辑在restoreCommand中（cluster.c文件中）：</p>
<ol>
<li>解析请求中的参数，判断是否有replace</li>
<li>如果没有replace并且key已经在当前节点存在，返回错误信息</li>
<li>调用verifyDumpPayload函数校验RDB版本和CRC校验和</li>
<li>从请求中解析value的数据类型和value值</li>
<li>如果设置了<code>replace</code>先删除数据库中存在的key</li>
<li>将key和vlaue添加到节点的数据库中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* RESTORE key ttl serialized-value [REPLACE] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restoreCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ttl, lfu_freq = <span class="number">-1</span>, lru_idle = <span class="number">-1</span>, lru_clock = <span class="number">-1</span>;</span><br><span class="line">    rio payload;</span><br><span class="line">    <span class="keyword">int</span> j, type, replace = <span class="number">0</span>, absttl = <span class="number">0</span>;</span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析请求中的参数 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">4</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> additional = c-&gt;argc-j<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">"replace"</span>)) &#123; <span class="comment">// 如果有replace</span></span><br><span class="line">            replace = <span class="number">1</span>; <span class="comment">// 标记</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyErrorObject(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果没有replace并且key已经在数据库存在，返回错误信息 */</span></span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!replace &amp;&amp; lookupKeyWrite(c-&gt;db,key) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReplyErrorObject(c,shared.busykeyerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the TTL value makes sense */</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;ttl,<span class="literal">NULL</span>) != C_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ttl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"Invalid TTL value, must be &gt;= 0"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 校验RDB版本和CRC */</span></span><br><span class="line">    <span class="keyword">if</span> (verifyDumpPayload(c-&gt;argv[<span class="number">3</span>]-&gt;ptr,sdslen(c-&gt;argv[<span class="number">3</span>]-&gt;ptr)) == C_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"DUMP payload version or checksum are wrong"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rioInitWithBuffer(&amp;payload,c-&gt;argv[<span class="number">3</span>]-&gt;ptr);</span><br><span class="line">    <span class="comment">// 解析value的数据类型和value值</span></span><br><span class="line">    <span class="keyword">if</span> (((type = rdbLoadObjectType(&amp;payload)) == <span class="number">-1</span>) ||</span><br><span class="line">        ((obj = rdbLoadObject(type,&amp;payload,key-&gt;ptr)) == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"Bad data format"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> deleted = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果设置了replace</span></span><br><span class="line">    <span class="keyword">if</span> (replace)</span><br><span class="line">        deleted = dbDelete(c-&gt;db,key); <span class="comment">// 先删除数据库中存在的key</span></span><br><span class="line">    <span class="keyword">if</span> (ttl &amp;&amp; !absttl) ttl+=mstime();</span><br><span class="line">    <span class="keyword">if</span> (ttl &amp;&amp; checkAlreadyExpired(ttl)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">            rewriteClientCommandVector(c,<span class="number">2</span>,shared.del,key);</span><br><span class="line">            signalModifiedKey(c,c-&gt;db,key);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125;</span><br><span class="line">        decrRefCount(obj);</span><br><span class="line">        addReply(c, shared.ok);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将key和vlaue添加到节点的数据库中 */</span></span><br><span class="line">    dbAdd(c-&gt;db,key,obj);</span><br><span class="line">    <span class="keyword">if</span> (ttl) &#123;</span><br><span class="line">        setExpire(c,c-&gt;db,key,ttl);</span><br><span class="line">    &#125;</span><br><span class="line">    objectSetLRUOrLFU(obj,lfu_freq,lru_idle,lru_clock,<span class="number">1000</span>);</span><br><span class="line">    signalModifiedKey(c,c-&gt;db,key);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"restore"</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标记迁移结果"><a href="#标记迁移结果" class="headerlink" title="标记迁移结果"></a>标记迁移结果</h3><p>数据迁移的最后一步，<strong>需要使用<code>CLUSTER SETSLOT</code>命令，在源节点和目标节点执行以下命令，标记slot最终所属的节点，并清除第一步中标记的迁移信息</strong>：</p>
<p><slot>：哈希槽</slot></p>
<p><node>：哈希槽最终所在节点id</node></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETSLOT &lt;slot&gt; NODE &lt;node&gt;</span><br></pre></td></tr></table></figure>
<p><strong>clusterCommand</strong></p>
<p><code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;node&gt;</code>命令的处理依旧在<strong>clusterCommand</strong>函数中，处理逻辑如下：</p>
<ol>
<li>根据命令中传入的nodeid查找节点记为n，如果未查询到，返回错误信息</li>
<li>果slot已经在当前节点，但是根据nodeid查找到的节点n不是当前节点，说明slot所属节点与命令中指定的节点不一致，返回错误信息</li>
<li><strong>在源节点上执行命令时，如果slot中key的数量为0，表示slot上的数据都已迁移完毕，而migrating_slots_to[slot]记录了slot迁移到的目标节点，既然数据已经迁移完成此时需要将migrating_slots_to[slot]迁出信息清除</strong></li>
<li>调用clusterDelSlot函数先将slot删除<ul>
<li>获取slot所属节点</li>
<li>将slot所属节点ClusterNode结构体中的slots数组对应的标记位取消，表示节点不再负责此slot</li>
<li>将slot所属节点ClusterState结构体中的slots数组对应元素置为NULL，表示当前slot所属节点为空</li>
</ul>
</li>
<li><strong>调用clusterAddSlot将slot添加到最终所属的节点中</strong></li>
<li><strong>在目标节点上执行命令时，如果slot所属节点为当前节点，并且importing_slots_from[slot]不为空， importing_slots_from[slot]中记录了slot是从哪个节点迁移过来，此时数据已经迁移完毕，清除 importing_slots_from[slot]中的迁入信息</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled == <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"This instance has cluster support disabled"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">2</span> &amp;&amp; !strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"help"</span>)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"setslot"</span>) &amp;&amp; c-&gt;argc &gt;= <span class="number">4</span>) &#123; <span class="comment">// 处理setslot命令</span></span><br><span class="line">        <span class="keyword">int</span> slot;</span><br><span class="line">        clusterNode *n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nodeIsSlave(myself)) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"Please use SETSLOT only with masters."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((slot = getSlotOrReply(c,c-&gt;argv[<span class="number">2</span>])) == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">3</span>]-&gt;ptr,<span class="string">"migrating"</span>) &amp;&amp; c-&gt;argc == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">// migrating处理</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">3</span>]-&gt;ptr,<span class="string">"importing"</span>) &amp;&amp; c-&gt;argc == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">// importing处理</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">3</span>]-&gt;ptr,<span class="string">"stable"</span>) &amp;&amp; c-&gt;argc == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">// stable处理</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">3</span>]-&gt;ptr,<span class="string">"node"</span>) &amp;&amp; c-&gt;argc == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">/* CLUSTER SETSLOT &lt;SLOT&gt; NODE &lt;NODE ID&gt; 命令处理 */</span></span><br><span class="line">            <span class="comment">// 根据nodeid查找节点</span></span><br><span class="line">            clusterNode *n = clusterLookupNode(c-&gt;argv[<span class="number">4</span>]-&gt;ptr);</span><br><span class="line">            <span class="comment">// 如果未查询到，返回错误信息</span></span><br><span class="line">            <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">                addReplyErrorFormat(c,<span class="string">"Unknown node %s"</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">4</span>]-&gt;ptr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 如果slot已经在当前节点，但是根据node id查找到的节点不是当前节点，返回错误信息*/</span></span><br><span class="line">            <span class="keyword">if</span> (server.cluster-&gt;slots[slot] == myself &amp;&amp; n != myself) &#123;</span><br><span class="line">                <span class="keyword">if</span> (countKeysInSlot(slot) != <span class="number">0</span>) &#123;</span><br><span class="line">                    addReplyErrorFormat(c,</span><br><span class="line">                        <span class="string">"Can't assign hashslot %d to a different node "</span></span><br><span class="line">                        <span class="string">"while I still hold keys for this hash slot."</span>, slot);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 在源节点上执行命令时 */</span></span><br><span class="line">            <span class="comment">/* 如果slot中key的数量为0，表示slot上的数据都已迁移完毕，而migrating_slots_to[slot]记录了slot迁移到的目标节点，既然数据已经迁移完成此时可以将迁移信息清除*/</span></span><br><span class="line">            <span class="keyword">if</span> (countKeysInSlot(slot) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                server.cluster-&gt;migrating_slots_to[slot])</span><br><span class="line">                server.cluster-&gt;migrating_slots_to[slot] = <span class="literal">NULL</span>;<span class="comment">// 清除迁移信息</span></span><br><span class="line">            <span class="comment">// 先删除slot</span></span><br><span class="line">            clusterDelSlot(slot);</span><br><span class="line">            <span class="comment">// 添加slot到节点n</span></span><br><span class="line">            clusterAddSlot(n,slot);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 在目标节点上执行命令时 */</span></span><br><span class="line">            <span class="comment">/* 如果slot所属节点为当前节点，并且importing_slots_from[slot]不为空， importing_slots_from[slot]中记录了slot是从哪个节点迁移过来*/</span></span><br><span class="line">            <span class="keyword">if</span> (n == myself &amp;&amp;</span><br><span class="line">                server.cluster-&gt;importing_slots_from[slot])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 更新节点的configEpoch */</span></span><br><span class="line">                <span class="keyword">if</span> (clusterBumpConfigEpochWithoutConsensus() == C_OK) &#123;</span><br><span class="line">                    serverLog(LL_WARNING,</span><br><span class="line">                        <span class="string">"configEpoch updated after importing slot %d"</span>, slot);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 清除importing_slots_from[slot]迁移信息</span></span><br><span class="line">                server.cluster-&gt;importing_slots_from[slot] = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">/* 广播PONG消息，让其他节点尽快知道slot的最新信息 */</span></span><br><span class="line">                clusterBroadcastPong(CLUSTER_BROADCAST_ALL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyError(c,</span><br><span class="line">                <span class="string">"Invalid CLUSTER SETSLOT action or number of arguments. Try CLUSTER HELP"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_UPDATE_STATE);</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplySubcommandSyntaxError(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考</strong></p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/19/【Redis】集群故障转移/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/19/【Redis】集群故障转移/" itemprop="url">【Redis】集群故障转移</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-19T23:00:00+08:00">
                2022-05-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="集群故障转移"><a href="#集群故障转移" class="headerlink" title="集群故障转移"></a>集群故障转移</h2><h3 id="节点下线"><a href="#节点下线" class="headerlink" title="节点下线"></a>节点下线</h3><p>在集群定时任务<code>clusterCron</code>中，会遍历集群中的节点，对每个节点进行检查，判断节点是否下线。与节点下线相关的状态有两个，分别为<code>CLUSTER_NODE_PFAIL</code>和<code>CLUSTER_NODE_FAIL</code>。</p>
<p><code>CLUSTER_NODE_PFAIL</code>：当前节点认为某个节点下线时，会将节点状态改为<code>CLUSTER_NODE_PFAIL</code>，由于可能存在误判，所以需要根据集群中的其他节点共同决定是否真的将节点标记为下线状态，<strong><code>CLUSTER_NODE_PFAIL</code>可以理解为疑似下线，类似哨兵集群中的主观下线</strong>。</p>
<p><code>CLUSTER_NODE_FAIL</code>：集群中有过半的节点标认为节点已下线，此时将节点置为<code>CLUSTER_NODE_FAIL</code>标记节点下线，<strong><code>CLUSTER_NODE_FAIL</code>表示节点真正处于下线状态，类似哨兵集群的客观下线</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTER_NODE_PFAIL 4      <span class="comment">/* 疑似下线，需要根据其他节点的判断决定是否下线，类似主观下线 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTER_NODE_FAIL 8       <span class="comment">/* 节点处于下线状态，类似客观下线 */</span></span></span><br></pre></td></tr></table></figure>
<h4 id="疑似下线（PFAIL）"><a href="#疑似下线（PFAIL）" class="headerlink" title="疑似下线（PFAIL）"></a>疑似下线（PFAIL）</h4><p>在集群定时任务遍历集群中的节点进行检查时，遍历到的每个节点记为<code>node</code>，当前节点记为<code>myself</code>，检查的内容主要有以下几个方面：</p>
<p><strong>一、判断孤立主节点的个数</strong></p>
<p>如果当前节点<code>myself</code>是从节点，正在遍历的节点<code>node</code>是主节点，并且<code>node</code>节点不处于下线状态，会判断孤立节点的个数，满足以下三个条件时，认定<code>node</code>是孤立节点，孤立节点个数增1：</p>
<ol>
<li><code>node</code>的从节点中处于非下线状态的节点个数为0</li>
<li><code>node</code>负责的slot数量大于0，</li>
<li><code>node</code>节点处于CLUSTER_NODE_MIGRATE_TO状态</li>
</ol>
<p><strong>二、检查连接</strong></p>
<p>这一步主要检查和节点间的连接是否正常，有可能节点处于正常状态，但是连接有问题，此时需要释放连接，在下次执行定时任务时会进行重连，释放连接需要同时满足以下几个条件：</p>
<ol>
<li>与节点<code>node</code>之间的连接不为空，说明之前进行过连接</li>
<li>当前时间距离连接创建的时间超过了超时时间</li>
<li>距离向<code>node</code>发送PING消息的时间已经超过了超时时间的一半</li>
<li>距离收到<code>node</code>节点发送消息的时间超过了超时时间的一半</li>
</ol>
<p><strong>三、疑似下线判断</strong></p>
<p><code>ping_delay</code>记录了当前时间距离向<code>node</code>节点发送PING消息的时间，<code>data_delayd</code>记录了<code>node</code>节点向当前节点最近一次发送消息的时间，从ping_delay和data_delay中取较大的那个作为延迟时间。</p>
<p><strong>如果延迟时间大于超时时间，判断<code>node</code>是否已经处于<code>CLUSTER_NODE_PFAIL</code>或者<code>CLUSTER_NODE_FAIL</code>状态，如果都不处于，将节点状态置为<code>CLUSTER_NODE_PFAIL</code>，认为节点疑似下线。</strong></p>
<p>也就是说如果在规定的超时时间内，当前节点长时间未向<code>node</code>节点发送PING消息，或者长时间未收到<code>node</code>节点向当前节点发送的消息，当前节点就认为<code>node</code>疑似下线状态。</p>
<p>上述检查完成之后，<strong>会判断当前节点是否是从节点，如果不处于<code>CLUSTER_MODULE_FLAG_NO_FAILOVER</code>状态，调用<code>clusterHandleSlaveFailover</code>处理故障转移，不过需要注意此时只是将节点置为疑似下线，并不满足故障转移条件，需要等待节点被置为FAIL下线状态之后，再次执行集群定时任务进入到<code>clusterHandleSlaveFailover</code>函数中才可以开始处理故障转移。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">    orphaned_masters = <span class="number">0</span>;</span><br><span class="line">    max_slaves = <span class="number">0</span>;</span><br><span class="line">    this_slaves = <span class="number">0</span>;</span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    <span class="comment">// 遍历集群中的节点</span></span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取节点</span></span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line">        now = mstime(); <span class="comment">/* 当前时间 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;flags &amp;</span><br><span class="line">            (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果当前节点myself是从节点，正在遍历的节点node是主节点，并且node节点不处于下线状态 */</span></span><br><span class="line">        <span class="keyword">if</span> (nodeIsSlave(myself) &amp;&amp; nodeIsMaster(node) &amp;&amp; !nodeFailed(node)) &#123;</span><br><span class="line">            <span class="comment">// 获取不处于下线状态的从节点数量</span></span><br><span class="line">            <span class="keyword">int</span> okslaves = clusterCountNonFailingSlaves(node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果处于正常状态的从节点数量为0、node负责的slot数量大于0， 并且节点处于CLUSTER_NODE_MIGRATE_TO状态 */</span></span><br><span class="line">            <span class="keyword">if</span> (okslaves == <span class="number">0</span> &amp;&amp; node-&gt;numslots &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                node-&gt;flags &amp; CLUSTER_NODE_MIGRATE_TO)</span><br><span class="line">            &#123;</span><br><span class="line">                orphaned_masters++; <span class="comment">// 孤立主节点数量加1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大从节点数量</span></span><br><span class="line">            <span class="keyword">if</span> (okslaves &gt; max_slaves) max_slaves = okslaves;</span><br><span class="line">            <span class="comment">// 如果myself是从节点 并且myself是node的从节点</span></span><br><span class="line">            <span class="keyword">if</span> (nodeIsSlave(myself) &amp;&amp; myself-&gt;slaveof == node)</span><br><span class="line">                this_slaves = okslaves; <span class="comment">// 记录处于正常状态的从节点数量</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 这一步主要检查连接是否出现问题 */</span></span><br><span class="line">        <span class="keyword">mstime_t</span> ping_delay = now - node-&gt;ping_sent; <span class="comment">// 当前时间减去发送PING消息时间</span></span><br><span class="line">        <span class="keyword">mstime_t</span> data_delay = now - node-&gt;data_received; <span class="comment">// 当前时间减去收到node向当前节点发送消息的时间</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;link &amp;&amp; <span class="comment">/* 如果连接不为空 */</span></span><br><span class="line">            now - node-&gt;link-&gt;ctime &gt; </span><br><span class="line">            server.cluster_node_timeout &amp;&amp; <span class="comment">/* 距离连接创建的时间超过了设置的超时时间 */</span></span><br><span class="line">            node-&gt;ping_sent &amp;&amp; <span class="comment">/* 发送过PING消息 */</span></span><br><span class="line">            <span class="comment">/* 距离发送PING消息的时间已经超过了超时时间的一半 */</span></span><br><span class="line">            ping_delay &gt; server.cluster_node_timeout/<span class="number">2</span> &amp;&amp;</span><br><span class="line">            <span class="comment">/* 距离收到node节点发送消息的时间超过了超时时间的一半</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            data_delay &gt; server.cluster_node_timeout/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 断开连接，在下次执行定时任务时会重新连接 */</span></span><br><span class="line">            freeClusterLink(node-&gt;link);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果连接不为空、ping_sent为0（收到PONG消息后会将ping_sent置为0），并且当前时间减去收到node的PONG消息的时间大于超时时间的一半 */</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;link &amp;&amp;</span><br><span class="line">            node-&gt;ping_sent == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (now - node-&gt;pong_received) &gt; server.cluster_node_timeout/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 立即发送PING消息，保持连接</span></span><br><span class="line">            clusterSendPing(node-&gt;link, CLUSTERMSG_TYPE_PING);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.cluster-&gt;mf_end &amp;&amp; <span class="comment">// 手动执行故障转移时间限制不为0，表示正在执行手动故障转移</span></span><br><span class="line">            nodeIsMaster(myself) &amp;&amp; <span class="comment">// 如果myself是主节点</span></span><br><span class="line">            server.cluster-&gt;mf_slave == node &amp;&amp;  <span class="comment">// 如果node是myself从节点并且正在执行手动故障转移</span></span><br><span class="line">            node-&gt;link) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 发送PING消息，保持连接</span></span><br><span class="line">            clusterSendPing(node-&gt;link, CLUSTERMSG_TYPE_PING);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果没有活跃的PING消息. */</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;ping_sent == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 校验节点是否主观下线 */</span></span><br><span class="line">        <span class="comment">// ping_delay记录了当前时间距离向node节点发送PING消息的时间</span></span><br><span class="line">        <span class="comment">// data_delay记录了node节点向当前节点最近一次发送消息的时间</span></span><br><span class="line">        <span class="comment">// 从ping_delay和data_delay中取较大的那个作为延迟时间</span></span><br><span class="line">        <span class="keyword">mstime_t</span> node_delay = (ping_delay &lt; data_delay) ? ping_delay :</span><br><span class="line">                                                          data_delay;</span><br><span class="line">        <span class="comment">// 如果节点的延迟时间大于超时时间</span></span><br><span class="line">        <span class="keyword">if</span> (node_delay &gt; server.cluster_node_timeout) &#123;</span><br><span class="line">            <span class="comment">/* 如果不处于CLUSTER_NODE_PFAIL或者CLUSTER_NODE_FAIL状态*/</span></span><br><span class="line">            <span class="keyword">if</span> (!(node-&gt;flags &amp; (CLUSTER_NODE_PFAIL|CLUSTER_NODE_FAIL))) &#123;</span><br><span class="line">                serverLog(LL_DEBUG,<span class="string">"*** NODE %.40s possibly failing"</span>,</span><br><span class="line">                    node-&gt;name);</span><br><span class="line">                <span class="comment">// 将节点标记为故障状态CLUSTER_NODE_PFAIL，标记疑似下线</span></span><br><span class="line">                node-&gt;flags |= CLUSTER_NODE_PFAIL;</span><br><span class="line">                update_state = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是从节点</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsSlave(myself)) &#123;</span><br><span class="line">        clusterHandleManualFailover();</span><br><span class="line">        <span class="comment">// 如果不处于CLUSTER_MODULE_FLAG_NO_FAILOVER状态</span></span><br><span class="line">        <span class="keyword">if</span> (!(server.cluster_module_flags &amp; CLUSTER_MODULE_FLAG_NO_FAILOVER))</span><br><span class="line">            clusterHandleSlaveFailover(); <span class="comment">// 处理故障转移</span></span><br><span class="line">        <span class="keyword">if</span> (orphaned_masters &amp;&amp; max_slaves &gt;= <span class="number">2</span> &amp;&amp; this_slaves == max_slaves &amp;&amp;</span><br><span class="line">        server.cluster_allow_replica_migration)</span><br><span class="line">            clusterHandleSlaveMigration(max_slaves);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下线（FAIL）"><a href="#下线（FAIL）" class="headerlink" title="下线（FAIL）"></a>下线（FAIL）</h4><p>当前节点认为某个node下线时，会将node状态置为<code>CLUSTER_NODE_PFAIL</code>疑似下线状态，在定时向集群中的节点交换信息也就是发送PING消息时，消息体中记录了node的下线状态，其他节点在处理收到的PING消息时，<strong>会将认为node节点下线的那个节点加入到node的下线链表fail_reports中，并调用<code>markNodeAsFailingIfNeeded</code>函数判断是否有必要将节点置为下线FAIL状态</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterProcessGossipSection</span><span class="params">(clusterMsg *hdr, clusterLink *link)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> count = ntohs(hdr-&gt;count);</span><br><span class="line">    <span class="comment">// 获取clusterMsgDataGossip数据</span></span><br><span class="line">    clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr-&gt;data.ping.gossip;</span><br><span class="line">    <span class="comment">// 发送消息的节点</span></span><br><span class="line">    clusterNode *sender = link-&gt;node ? link-&gt;node : clusterLookupNode(hdr-&gt;sender);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(count--) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 根据nodename查找节点，node指向当前收到消息节点中维护的节点*/</span></span><br><span class="line">        node = clusterLookupNode(g-&gt;nodename);</span><br><span class="line">        <span class="comment">// 如果节点已知</span></span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            <span class="comment">/* 如果发送者是主节点 */</span></span><br><span class="line">            <span class="keyword">if</span> (sender &amp;&amp; nodeIsMaster(sender) &amp;&amp; node != myself) &#123;</span><br><span class="line">                <span class="comment">// 如果gossip节点是FAIL或者PFAIL状态</span></span><br><span class="line">                <span class="keyword">if</span> (flags &amp; (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &#123;</span><br><span class="line">                    <span class="comment">// 将sender加入到node节点的下线链表fail_reports中</span></span><br><span class="line">                    <span class="keyword">if</span> (clusterNodeAddFailureReport(node,sender)) &#123;</span><br><span class="line">                        serverLog(LL_VERBOSE,</span><br><span class="line">                            <span class="string">"Node %.40s reported node %.40s as not reachable."</span>,</span><br><span class="line">                            sender-&gt;name, node-&gt;name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 判断是否需要将节点置为下线</span></span><br><span class="line">                    markNodeAsFailingIfNeeded(node);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 校验sender是否在下线节点链表fail_reports中，如果在需要移除恢复在线状态</span></span><br><span class="line">                    <span class="keyword">if</span> (clusterNodeDelFailureReport(node,sender)) &#123;</span><br><span class="line">                        serverLog(LL_VERBOSE,</span><br><span class="line">                            <span class="string">"Node %.40s reported node %.40s is back online."</span>,</span><br><span class="line">                            sender-&gt;name, node-&gt;name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果节点未知</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 遍历下一个节点 */</span></span><br><span class="line">        g++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>markNodeAsFailingIfNeeded</strong></p>
<p>markNodeAsFailingIfNeeded用于判断是否有必要将某个节点标记为FAIL状态：</p>
<ol>
<li>计算quorum，为集群节点个数一半 + 1，记为<code>needed_quorum</code></li>
<li>如果节点已经被置为FAIL状态，直接返回即可</li>
<li>调用<code>clusterNodeFailureReportsCount</code>函数，获取节点下线链表<code>node-&gt;fail_reports</code>中元素的个数，<code>node-&gt;fail_reports</code>链表中记录了认为<code>node</code>下线的节点个数，节点个数记为<code>failures</code></li>
<li>如果当前节点是主节点，<code>failures</code>增1，表示当前节点也认为<code>node</code>需要置为下线状态</li>
<li>判断是否有过半的节点认同节点下线，也就是<code>failures</code>大于等于<code>needed_quorum</code>，如果没有过半的节点认同<code>node</code>需要下线，直接返回即可</li>
<li>如果<strong>有过半的节点认同<code>node</code>需要下线，此时取消节点的疑似下线标记PFAIL状态，将节点置为FAIL状态</strong></li>
<li>在集群中广播节点的下线消息，以便让其他节点知道该节点已经下线</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markNodeAsFailingIfNeeded</span><span class="params">(clusterNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> failures;</span><br><span class="line">    <span class="comment">// 计算quorum，为集群节点个数一半 + 1</span></span><br><span class="line">    <span class="keyword">int</span> needed_quorum = (server.cluster-&gt;size / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nodeTimedOut(node)) <span class="keyword">return</span>; <span class="comment">/* We can reach it. */</span></span><br><span class="line">    <span class="comment">// 如果节点已经处于下线状态</span></span><br><span class="line">    <span class="keyword">if</span> (nodeFailed(node)) <span class="keyword">return</span>; <span class="comment">/* Already FAILing. */</span></span><br><span class="line">    <span class="comment">// 从失败报告中获取认为节点已经下线的节点数量</span></span><br><span class="line">    failures = clusterNodeFailureReportsCount(node);</span><br><span class="line">    <span class="comment">/* 如果当前节点是主节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(myself)) failures++; <span class="comment">// 认定下线的节点个数+1</span></span><br><span class="line">    <span class="comment">// 如果没有过半的节点认同节点下线，返回即可</span></span><br><span class="line">    <span class="keyword">if</span> (failures &lt; needed_quorum) <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">        <span class="string">"Marking node %.40s as failing (quorum reached)."</span>, node-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 标记节点下线 */</span></span><br><span class="line">    <span class="comment">// 取消CLUSTER_NODE_PFAIL状态</span></span><br><span class="line">    node-&gt;flags &amp;= ~CLUSTER_NODE_PFAICLUSTER_NODE_PFAIL;</span><br><span class="line">    <span class="comment">// 设置为下线状态</span></span><br><span class="line">    node-&gt;flags |= CLUSTER_NODE_FAIL;</span><br><span class="line">    node-&gt;fail_time = mstime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 广播下线消息到集群中的节点,以便让其他节点知道该节点已经下线 */</span></span><br><span class="line">    clusterSendFail(node-&gt;name);</span><br><span class="line">    clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回下线报告链表中*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterNodeFailureReportsCount</span><span class="params">(clusterNode *node)</span> </span>&#123;</span><br><span class="line">    clusterNodeCleanupFailureReports(node);</span><br><span class="line">    <span class="comment">// 返回认为node下线的节点个数</span></span><br><span class="line">    <span class="keyword">return</span> listLength(node-&gt;fail_reports);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/下线.jpg" alt=""></p>
<h3 id="故障转移处理"><a href="#故障转移处理" class="headerlink" title="故障转移处理"></a>故障转移处理</h3><p><strong>clusterHandleSlaveFailover</strong></p>
<p>由上面的内容可知，节点客观下线时会被置为<code>CLUSTER_NODE_FAIL</code>状态，下次执行集群定时任务时，在故障转移处理函数<code>clusterHandleSlaveFailover</code>中，就可以根据状态来检查是否需要执行故障转移。</p>
<p>不过在看<code>clusterHandleSlaveFailover</code>函数之前，先看一下<code>clusterState</code>中和选举以及故障切换相关的变量定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mstime_t</span> failover_auth_time; <span class="comment">/* 发起选举的时间 */</span></span><br><span class="line">    <span class="keyword">int</span> failover_auth_count;    <span class="comment">/* 目前为止收到投票的数量 */</span></span><br><span class="line">    <span class="keyword">int</span> failover_auth_sent;     <span class="comment">/* 是否发起了投票，如果已经发起，值大于0 */</span></span><br><span class="line">    <span class="keyword">int</span> failover_auth_rank;     <span class="comment">/* 从节点排名 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> failover_auth_epoch; <span class="comment">/* 当前选举的纪元 */</span></span><br><span class="line">    <span class="keyword">int</span> cant_failover_reason;   <span class="comment">/* 从节点不能执行故障转移的原因 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> mf_end;            <span class="comment">/* 手动执行故障转移时间限制，如果未设置值为0 */</span></span><br><span class="line">    clusterNode *mf_slave;      <span class="comment">/* 执行手动故障切换的从节点 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<p><strong>clusterHandleSlaveFailover函数中的一些变量</strong></p>
<p><code>data_age</code>：<strong>记录从节点最近一次与主节点进行数据同步的时间</strong>。如果与主节点处于连接状态，用当前时间减去最近一次与master节点交互的时间，否则使用当前时间减去与master主从复制中断的时间。</p>
<p><code>auth_age</code>：<strong>当前时间减去发起选举的时间</strong>，也就是距离发起选举过去了多久，用于判断选举超时、是否重新发起选举使用。</p>
<p><code>needed_quorum</code>：<strong>quorum的数量，为集群中节点的数量的一半再加1</strong>。</p>
<p><code>auth_timeout</code>：<strong>等待投票超时时间。</strong></p>
<p><code>auth_retry_time</code>：<strong>等待重新发起选举进行投票的时间，也就是重试时间</strong>。</p>
<h4 id="发起选举"><a href="#发起选举" class="headerlink" title="发起选举"></a>发起选举</h4><p><strong>一、故障转移条件检查</strong></p>
<p>首先进行了一些条件检查，用于判断是否有必要执行故障转移，如果<strong>处于以下几个条件之一，将会跳出函数，结束故障转移处理</strong>：</p>
<ol>
<li><p><strong>当前节点<code>myself</code>是master节点</strong>，因为如果需要进行故障转移一般是master节点被标记为下线，需要从它所属的从节点中选举节点作为新的master节点，这个需要从节点发起选举，所以如果当前节点是主节点，不满足进行故障转移的条件。</p>
</li>
<li><p>当前节点<code>myself</code>所属的主节点为空</p>
</li>
<li><p><strong>当前节点<code>myself</code>所属主节点不处于客观下线状态并且不是手动进行故障转移，可以看到这里使用的是<code>CLUSTER_NODE_FAIL</code>状态来判断的</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nodeFailed(n) ((n)-&gt;flags &amp; CLUSTER_NODE_FAIL)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果开启了不允许从节点执行故障切换并且当前不是手动进行故障转移</p>
</li>
<li><p>当前节点<code>myself</code>所属主节点负责的slot数量为0</p>
</li>
</ol>
<p><strong>二、主从复制进度校验</strong></p>
<p><code>cluster_slave_validity_factor</code>设置了故障切换最大主从复制延迟时间因子，如果不为0需要校验主从复制延迟时间是否符合要求。</p>
<p>如果主从复制延迟时间<code>data_age</code>大于 <code>mater向从节点发送PING消息的周期 + 超时时间 * 故障切换主从复制延迟时间因子</code>并且不是手动执行故障切换，表示主从复制延迟过大，不能进行故障切换终止执行。</p>
<p><strong>三、是否需要重新发起选举</strong></p>
<p>如果距离上次发起选举的时间大于超时重试时间，表示可以重新发起投票。</p>
<ol>
<li><p><strong>设置本轮选举发起时间，并没有直接使用当前时间，而是使用了当前时间 + 500毫秒 + 随机值（0到500毫秒之间）进行了一个延迟，以便让上一次失败的消息尽快传播。</strong></p>
</li>
<li><p>重置获取的投票数量<code>failover_auth_count</code>和是否已经发起选举<code>failover_auth_sent</code>为0，等待下一次执行<code>clusterHandleSlaveFailover</code>函数时重新发起投票。</p>
</li>
<li><p>获取当前节点在所属主节点的所有从节点中的等级排名，再次更新发起选举时间，加上当前节点的rank * 1000，<strong>以便让等级越低（rank值越高）的节点，越晚发起选举，降低选举的优先级。</strong></p>
<blockquote>
<p>注意这里并没有恢复<code>CLUSTER_TODO_HANDLE_FAILOVER</code>状态，因为发起投票的入口是在集群定时任务<code>clusterCron</code>函数中，所以不需要恢复。</p>
</blockquote>
</li>
<li><p>如果是手动进行故障转移，不需要设置延迟时间，直接使用当前时间，rank设置为0，然后将状态置为<code>CLUSTER_TODO_HANDLE_FAILOVER</code>，在下一次执行<code>beforeSleep</code>函数时，重新进行故障转移。</p>
</li>
<li><p>向集群中广播消息并终止执行本次故障切换。</p>
</li>
</ol>
<p><strong>四、延迟发起选举</strong></p>
<ol>
<li>如果还未发起选举投票，节点等级有可能在变化，所以此时需要更新等级以及发起投票的延迟时间。</li>
<li>如果当前时间小于设置的选举发起时间，需要延迟发起选举，直接返回，等待下一次执行。</li>
<li>如果距离发起选举的时间大于超时时间，表示本次选举已超时，直接返回。</li>
</ol>
<p><strong>五、发起投票</strong></p>
<p>如果满足执行故障的条件，接下来需从节点想集群中的其他节点广播消息，发起投票，不过只有主节点才有投票权。<code>failover_auth_sent</code>为0表示还未发起投票，此时开始发起投票：</p>
<ol>
<li>更新节点当前的投票纪元（轮次）<code>currentEpoch</code>，对其进行增1操作</li>
<li>设置本次选举的投票纪元（轮次）<code>failover_auth_epoch</code>，与<code>currentEpoch</code>一致</li>
<li>向集群广播，<strong>发送CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息到其他节点进行投票</strong></li>
<li><code>failover_auth_sent</code>置为1 ，表示已经发起了投票</li>
<li>发起投票后，直接返回，等待其他节点的投票。</li>
</ol>
<p><strong>六、执行故障切换</strong></p>
<p>当某个节点获取到了集群中大多数节点的投票，即可进行故障切换，这里先不关注，在后面的章节会讲。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterHandleSlaveFailover</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主从复制延迟时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> data_age;</span><br><span class="line">    <span class="comment">// 当前时间减去发起选举的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> auth_age = mstime() - server.cluster-&gt;failover_auth_time;</span><br><span class="line">    <span class="comment">// 计算quorum的数量，为集群中节点的数量的一半再加1</span></span><br><span class="line">    <span class="keyword">int</span> needed_quorum = (server.cluster-&gt;size / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 是否手动执行故障转移</span></span><br><span class="line">    <span class="keyword">int</span> manual_failover = server.cluster-&gt;mf_end != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                          server.cluster-&gt;mf_can_start;</span><br><span class="line">    <span class="comment">// 等待投票超时时间，等待重试时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> auth_timeout, auth_retry_time;</span><br><span class="line">    <span class="comment">// 取消CLUSTER_TODO_HANDLE_FAILOVER状态</span></span><br><span class="line">    server.cluster-&gt;todo_before_sleep &amp;= ~CLUSTER_TODO_HANDLE_FAILOVER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待投票超时时间为集群中设置的超时时间的2倍</span></span><br><span class="line">    auth_timeout = server.cluster_node_timeout*<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 如果等待投票超时的时间小于2000毫秒，设置为2000毫秒，也就是超时时间最少为2000毫秒</span></span><br><span class="line">    <span class="keyword">if</span> (auth_timeout &lt; <span class="number">2000</span>) auth_timeout = <span class="number">2000</span>;</span><br><span class="line">    <span class="comment">// 等待重试时间为超时时间的2倍</span></span><br><span class="line">    auth_retry_time = auth_timeout*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 校验故障转移条件，处于以下条件之一不满足故障切换条件，跳出函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(myself) || <span class="comment">// myself是主节点</span></span><br><span class="line">        myself-&gt;slaveof == <span class="literal">NULL</span> || <span class="comment">// myself是从节点但是所属主节点为空</span></span><br><span class="line">        (!nodeFailed(myself-&gt;slaveof) &amp;&amp; !manual_failover) || <span class="comment">// 所属主节点不处于下线状态并且不是手动进行故障转移</span></span><br><span class="line">        (server.cluster_slave_no_failover &amp;&amp; !manual_failover) || <span class="comment">// 如果不允许从节点执行故障切换并且不是手动进行故障转移</span></span><br><span class="line">        myself-&gt;slaveof-&gt;numslots == <span class="number">0</span>) <span class="comment">// 所属主节点负责的slot数量为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 不进行故障切换 */</span></span><br><span class="line">        server.cluster-&gt;cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果主从复制状态为连接状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECTED) &#123;</span><br><span class="line">        <span class="comment">// 设置距离最近一次复制数据的时间，由于和master节点还处于连接状态，使用当前时间减去最近一次与master节点交互的时间</span></span><br><span class="line">        data_age = (<span class="keyword">mstime_t</span>)(server.unixtime - server.master-&gt;lastinteraction)</span><br><span class="line">                   * <span class="number">1000</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他状态时</span></span><br><span class="line">        <span class="comment">// 使用当前时间减去与master主从复制中断的时间</span></span><br><span class="line">        data_age = (<span class="keyword">mstime_t</span>)(server.unixtime - server.repl_down_since) * <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果data_age大于超时时间，减去超时时间 */</span></span><br><span class="line">    <span class="keyword">if</span> (data_age &gt; server.cluster_node_timeout)</span><br><span class="line">        data_age -= server.cluster_node_timeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cluster_slave_validity_factor设置了故障切换最大主从复制延迟时间因子，如果不为0需要校验主从复制延迟时间是否符合要求 */</span></span><br><span class="line">    <span class="comment">/* 如果主从复制延迟时间 大于(master向从节点发送PING消息的周期 + 超时时间 * 故障切换主从复制延迟时间因子) ，表示主从复制延迟过大，不能进行故障切换 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_slave_validity_factor &amp;&amp;</span><br><span class="line">        data_age &gt;</span><br><span class="line">        (((<span class="keyword">mstime_t</span>)server.repl_ping_slave_period * <span class="number">1000</span>) +</span><br><span class="line">         (server.cluster_node_timeout * server.cluster_slave_validity_factor)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果不是手动执行故障切换</span></span><br><span class="line">        <span class="keyword">if</span> (!manual_failover) &#123;</span><br><span class="line">            <span class="comment">// 设置不能执行故障切换的原因，主从复制进度不符合要求</span></span><br><span class="line">            clusterLogCantFailover(CLUSTER_CANT_FAILOVER_DATA_AGE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果距离上次发起选举的时间大于超时重试时间，表示可以重新发起投票 */</span></span><br><span class="line">    <span class="keyword">if</span> (auth_age &gt; auth_retry_time) &#123;</span><br><span class="line">        <span class="comment">// 设置本轮选举发起时间，使用了当前时间 + 500毫秒 + 随机值（0到500毫秒之间），以便让上一次失败的消息尽快传播</span></span><br><span class="line">        server.cluster-&gt;failover_auth_time = mstime() +</span><br><span class="line">            <span class="number">500</span> + </span><br><span class="line">            random() % <span class="number">500</span>; </span><br><span class="line">        <span class="comment">// 初始化获取的投票数量</span></span><br><span class="line">        server.cluster-&gt;failover_auth_count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化failover_auth_sent为0</span></span><br><span class="line">        server.cluster-&gt;failover_auth_sent = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取当前节点的等级</span></span><br><span class="line">        server.cluster-&gt;failover_auth_rank = clusterGetSlaveRank();</span><br><span class="line">        <span class="comment">// 再次更新发起选举时间，加上当前节点的rank * 1000，以便让等级越低的节点，越晚发起选举，降低选举的优先级</span></span><br><span class="line">        server.cluster-&gt;failover_auth_time +=</span><br><span class="line">            server.cluster-&gt;failover_auth_rank * <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">/* 如果是手动进行故障转移，不需要设置延迟 */</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster-&gt;mf_end) &#123;</span><br><span class="line">            <span class="comment">// 设置发起选举时间为当前时间</span></span><br><span class="line">            server.cluster-&gt;failover_auth_time = mstime();</span><br><span class="line">            <span class="comment">// rank设置为0，等级最高</span></span><br><span class="line">            server.cluster-&gt;failover_auth_rank = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 设置CLUSTER_TODO_HANDLE_FAILOVER状态</span></span><br><span class="line">              clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Start of election delayed for %lld milliseconds "</span></span><br><span class="line">            <span class="string">"(rank #%d, offset %lld)."</span>,</span><br><span class="line">            server.cluster-&gt;failover_auth_time - mstime(),</span><br><span class="line">            server.cluster-&gt;failover_auth_rank,</span><br><span class="line">            replicationGetSlaveOffset());</span><br><span class="line">        <span class="comment">/* 广播消息 */</span></span><br><span class="line">        clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;failover_auth_sent == <span class="number">0</span> &amp;&amp; <span class="comment">// 如果还未发起选举</span></span><br><span class="line">        server.cluster-&gt;mf_end == <span class="number">0</span>) <span class="comment">// 如果不是手动执行故障转移</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取节点等级，节点等级有可能在变化，需要更新等级</span></span><br><span class="line">        <span class="keyword">int</span> newrank = clusterGetSlaveRank();</span><br><span class="line">        <span class="comment">// 如果排名大于之前设置的等级</span></span><br><span class="line">        <span class="keyword">if</span> (newrank &gt; server.cluster-&gt;failover_auth_rank) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> added_delay =</span><br><span class="line">                (newrank - server.cluster-&gt;failover_auth_rank) * <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">// 更新发起选举时间</span></span><br><span class="line">            server.cluster-&gt;failover_auth_time += added_delay;</span><br><span class="line">            <span class="comment">// 更新节点等级</span></span><br><span class="line">            server.cluster-&gt;failover_auth_rank = newrank;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Replica rank updated to #%d, added %lld milliseconds of delay."</span>,</span><br><span class="line">                newrank, added_delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前时间小于设置的选举发起时间，需要延迟发起选举 */</span></span><br><span class="line">    <span class="keyword">if</span> (mstime() &lt; server.cluster-&gt;failover_auth_time) &#123;</span><br><span class="line">        <span class="comment">// 记录延迟发起选举日志</span></span><br><span class="line">        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_DELAY);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果距离发起选举的时间大于超时时间，表示已超时 */</span></span><br><span class="line">    <span class="keyword">if</span> (auth_age &gt; auth_timeout) &#123;</span><br><span class="line">        <span class="comment">// 记录选举已过期日志</span></span><br><span class="line">        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_EXPIRED);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果failover_auth_sent为0表示还未发起投票 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;failover_auth_sent == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 纪元加1</span></span><br><span class="line">        server.cluster-&gt;currentEpoch++;</span><br><span class="line">        <span class="comment">// 设置当前选举纪元failover_auth_epoch</span></span><br><span class="line">        server.cluster-&gt;failover_auth_epoch = server.cluster-&gt;currentEpoch;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Starting a failover election for epoch %llu."</span>,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;currentEpoch);</span><br><span class="line">        <span class="comment">// 广播发送CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，发起投票</span></span><br><span class="line">        clusterRequestFailoverAuth();</span><br><span class="line">        <span class="comment">// failover_auth_sent置为1 ，表示已经发起了投票</span></span><br><span class="line">        server.cluster-&gt;failover_auth_sent = <span class="number">1</span>;</span><br><span class="line">        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|</span><br><span class="line">                             CLUSTER_TODO_UPDATE_STATE|</span><br><span class="line">                             CLUSTER_TODO_FSYNC_CONFIG);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* Wait for replies. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 校验是否获取了大多数的投票，执行故障切换 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;failover_auth_count &gt;= needed_quorum) &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送FAILOVER_AUTH_REQUEST消息到每个节点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterRequestFailoverAuth</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    clusterMsg buf[<span class="number">1</span>];</span><br><span class="line">    clusterMsg *hdr = (clusterMsg*) buf;</span><br><span class="line">    <span class="keyword">uint32_t</span> totlen;</span><br><span class="line">    <span class="comment">// 设置消息头，发送CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息</span></span><br><span class="line">    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST);</span><br><span class="line">    <span class="comment">/* 如果是手动转移，设置CLUSTERMSG_FLAG0_FORCEACK标记 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;mf_end) hdr-&gt;mflags[<span class="number">0</span>] |= CLUSTERMSG_FLAG0_FORCEACK;</span><br><span class="line">    totlen = <span class="keyword">sizeof</span>(clusterMsg)-<span class="keyword">sizeof</span>(<span class="keyword">union</span> clusterMsgData);</span><br><span class="line">    hdr-&gt;totlen = htonl(totlen);</span><br><span class="line">    <span class="comment">// 发送广播</span></span><br><span class="line">    clusterBroadcastMessage(buf,totlen);</span><br></pre></td></tr></table></figure>
<p><img src="/images/故障处理.jpg" alt=""></p>
<h4 id="获取节点等级"><a href="#获取节点等级" class="headerlink" title="获取节点等级"></a>获取节点等级</h4><p>clusterGetSlaveRank用于计算当前节点的等级，遍历所属主节点的所有从节点，根据主从复制进度<code>repl_offset</code>计算，<code>repl_offset</code>值越大表示复制主节点的数据越多，所以等级越高，对应的<code>rank</code>值就越低。</p>
<p><strong>从节点在发起选举使用了<code>rank</code>的值作为延迟时间，值越低延迟时间越小，意味着选举优先级也就越高。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterGetSlaveRank</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> myoffset;</span><br><span class="line">    <span class="comment">// rank初始化为0</span></span><br><span class="line">    <span class="keyword">int</span> j, rank = <span class="number">0</span>;</span><br><span class="line">    clusterNode *master;</span><br><span class="line">    serverAssert(nodeIsSlave(myself));</span><br><span class="line">    <span class="comment">// 获取当前节点所属的主节点</span></span><br><span class="line">    master = myself-&gt;slaveof;</span><br><span class="line">    <span class="keyword">if</span> (master == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 返回0 */</span></span><br><span class="line">    <span class="comment">// 获取主从复制进度</span></span><br><span class="line">    myoffset = replicationGetSlaveOffset();</span><br><span class="line">    <span class="comment">// 变量master的所有从节点</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; master-&gt;numslaves; j++)</span><br><span class="line">        <span class="comment">// 如果不是当前节点、节点可以用来执行故障切换并且节点的复制进度大于当前节点的进度</span></span><br><span class="line">        <span class="keyword">if</span> (master-&gt;slaves[j] != myself &amp;&amp;</span><br><span class="line">            !nodeCantFailover(master-&gt;slaves[j]) &amp;&amp; </span><br><span class="line">            master-&gt;slaves[j]-&gt;repl_offset &gt; myoffset) rank++; <span class="comment">// 将当前节点的排名后移，等级越低</span></span><br><span class="line">    <span class="keyword">return</span> rank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主节点进行投票"><a href="#主节点进行投票" class="headerlink" title="主节点进行投票"></a>主节点进行投票</h3><p>当从节点认为主节点故障需要发起投票，重新选举主节点时，在集群中广播了<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code>消息，对应的处理在<code>clusterProcessPacket</code>函数中，里面会调用<code>clusterSendFailoverAuthIfNeeded</code>函数进行投票：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterProcessPacket</span><span class="params">(clusterLink *link)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* PING, PONG, MEET消息处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG ||</span><br><span class="line">        type == CLUSTERMSG_TYPE_MEET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST) &#123;<span class="comment">// 处理CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息</span></span><br><span class="line">        <span class="keyword">if</span> (!sender) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        <span class="comment">// 进行投票,sender为发送消息的节点，hdr为请求体</span></span><br><span class="line">        clusterSendFailoverAuthIfNeeded(sender,hdr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>clusterSendFailoverAuthIfNeeded</strong></p>
<p>clusterSendFailoverAuthIfNeeded函数用于进行投票，处理逻辑如下：</p>
<ol>
<li><strong>由于只有主节点才可以投票，如果当前节点不是主节点或者当前节点中负责slot的个数为0，当前节点没有权限投票，直接返回</strong>。</li>
<li>需要保证发起请求的投票轮次要等于或者大于当前节点中记录的轮次，所以如果请求的纪元（轮次）小于当前节点中记录的纪元（轮次） ，直接返回。</li>
<li>如果当前节点中记录的上次投票的纪元（轮次）等于当前投票纪元（轮次），表示当前节点已经投过票，直接返回。</li>
<li>如果发起请求的节点是主节点或者发起请求的节点所属的主节点为空，或者主节点不处于下线状态并且不是手动执行故障转移，直接返回。</li>
<li>如果当前时间减去节点投票时间<code>node-&gt;slaveof-&gt;voted_time</code>小于超时时间的2倍，直接返回。<strong><code>node-&gt;slaveof-&gt;voted_time</code>记录了当前节点的投票时间，在未超过2倍超时时间之前不进行投票。</strong></li>
<li>处理slot，需要保证当前节点中记录的slot的纪元小于等于请求纪元，如果不满足此条件，终止投票，直接返回。</li>
</ol>
<p>以上条件校验通过，<strong>表示当前节点可以投票给发送请求的节点，此时更新<code>lastVoteEpoch</code>，记录最近一次投票的纪元（轮次），更新投票时间<code>node-&gt;slaveof-&gt;voted_time</code>，然后向发起请求的节点回复<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterSendFailoverAuthIfNeeded</span><span class="params">(clusterNode *node, clusterMsg *request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发起请求的节点所属主节点</span></span><br><span class="line">    clusterNode *master = node-&gt;slaveof;</span><br><span class="line">    <span class="comment">// 从请求中获取投票纪元（轮次）</span></span><br><span class="line">    <span class="keyword">uint64_t</span> requestCurrentEpoch = ntohu64(request-&gt;currentEpoch);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">uint64_t</span> requestConfigEpoch = ntohu64(request-&gt;configEpoch);</span><br><span class="line">    <span class="comment">// 从请求中获取节点负责的slot</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *claimed_slots = request-&gt;myslots;</span><br><span class="line">    <span class="comment">// 是否是手动故障执行故障转移</span></span><br><span class="line">    <span class="keyword">int</span> force_ack = request-&gt;mflags[<span class="number">0</span>] &amp; CLUSTERMSG_FLAG0_FORCEACK;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前节点不是主节点或者当前节点中负责slot的个数为0，当前节点没有权限投票，直接返回*/</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsSlave(myself) || myself-&gt;numslots == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果请求的纪元（轮次）小于当前节点中记录的纪元（轮次） */</span></span><br><span class="line">    <span class="keyword">if</span> (requestCurrentEpoch &lt; server.cluster-&gt;currentEpoch) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Failover auth denied to %.40s: reqEpoch (%llu) &lt; curEpoch(%llu)"</span>,</span><br><span class="line">            node-&gt;name,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) requestCurrentEpoch,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;currentEpoch);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前节点中记录的上次投票的纪元等于当前纪元，表示当前节点已经投过票，直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;lastVoteEpoch == server.cluster-&gt;currentEpoch) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failover auth denied to %.40s: already voted for epoch %llu"</span>,</span><br><span class="line">                node-&gt;name,</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;currentEpoch);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果发起请求的节点是主节点或者发起请求的节点所属的主节点为空，或者主节点不处于下线状态并且不是手动执行故障转移，直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(node) || master == <span class="literal">NULL</span> ||</span><br><span class="line">        (!nodeFailed(master) &amp;&amp; !force_ack))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeIsMaster(node)) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"Failover auth denied to %.40s: it is a master node"</span>,</span><br><span class="line">                    node-&gt;name);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (master == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"Failover auth denied to %.40s: I don't know its master"</span>,</span><br><span class="line">                    node-&gt;name);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!nodeFailed(master)) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"Failover auth denied to %.40s: its master is up"</span>,</span><br><span class="line">                    node-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前时间减去投票时间小于超时时间的2倍，直接返回 */</span></span><br><span class="line">    <span class="comment">/* node-&gt;slaveof-&gt;voted_time记录了当前节点的投票时间，在未过2倍超时时间之前，不进行投票 */</span></span><br><span class="line">    <span class="keyword">if</span> (mstime() - node-&gt;slaveof-&gt;voted_time &lt; server.cluster_node_timeout * <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failover auth denied to %.40s: "</span></span><br><span class="line">                <span class="string">"can't vote about this master before %lld milliseconds"</span>,</span><br><span class="line">                node-&gt;name,</span><br><span class="line">                (<span class="keyword">long</span> <span class="keyword">long</span>) ((server.cluster_node_timeout*<span class="number">2</span>)-</span><br><span class="line">                             (mstime() - node-&gt;slaveof-&gt;voted_time)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 处理slot，需要保证当前节点中记录的slot的纪元小于等于请求纪元 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CLUSTER_SLOTS; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的slot不在发起请求节点负责的slot中，继续下一个</span></span><br><span class="line">        <span class="keyword">if</span> (bitmapTestBit(claimed_slots, j) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果当前节点不负责此slot或者slot中记录的纪元小于等于请求纪元，继续下一个</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster-&gt;slots[j] == <span class="literal">NULL</span> ||</span><br><span class="line">            server.cluster-&gt;slots[j]-&gt;configEpoch &lt;= requestConfigEpoch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failover auth denied to %.40s: "</span></span><br><span class="line">                <span class="string">"slot %d epoch (%llu) &gt; reqEpoch (%llu)"</span>,</span><br><span class="line">                node-&gt;name, j,</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;slots[j]-&gt;configEpoch,</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) requestConfigEpoch);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 走到这里表示可以投票给从节点 */</span></span><br><span class="line">    <span class="comment">/* 将当前节点的lastVoteEpoch设置为currentEpoch */</span></span><br><span class="line">    server.cluster-&gt;lastVoteEpoch = server.cluster-&gt;currentEpoch;</span><br><span class="line">    <span class="comment">/* 更新投票时间 */</span></span><br><span class="line">    node-&gt;slaveof-&gt;voted_time = mstime();</span><br><span class="line">    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_FSYNC_CONFIG);</span><br><span class="line">    <span class="comment">/* 发送CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息 */</span></span><br><span class="line">    clusterSendFailoverAuth(node);</span><br><span class="line">    serverLog(LL_WARNING, <span class="string">"Failover auth granted to %.40s for epoch %llu"</span>,</span><br><span class="line">        node-&gt;name, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) server.cluster-&gt;currentEpoch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息到指定节点. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterSendFailoverAuth</span><span class="params">(clusterNode *node)</span> </span>&#123;</span><br><span class="line">    clusterMsg buf[<span class="number">1</span>];</span><br><span class="line">    clusterMsg *hdr = (clusterMsg*) buf;</span><br><span class="line">    <span class="keyword">uint32_t</span> totlen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;link) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 设置请求体，发送CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息</span></span><br><span class="line">    clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK);</span><br><span class="line">    totlen = <span class="keyword">sizeof</span>(clusterMsg)-<span class="keyword">sizeof</span>(<span class="keyword">union</span> clusterMsgData);</span><br><span class="line">    hdr-&gt;totlen = htonl(totlen);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    clusterSendMessage(node-&gt;link,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,totlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="投票回复消息处理"><a href="#投票回复消息处理" class="headerlink" title="投票回复消息处理"></a>投票回复消息处理</h3><p>主节点对发起投票请求节点的回复消息<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>同样在消息处理函数<code>clusterProcessPacket</code>中，会对发送回复消息的节点进行验证：</p>
<ol>
<li>发送者是主节点</li>
<li>发送者负责的slot数量大于0</li>
<li>发送者记录的投票纪元（轮次）大于或等于当前节点发起故障转移投票的轮次</li>
</ol>
<p>同时满足以上三个条件时，<strong>表示发送者对当前节点进行了投票，更新当前节点记录的收到投票的个数，<code>failover_auth_count</code>加1，此时有可能获取了大多数节点的投票，先调用<code>clusterDoBeforeSleep</code>设置一个<code>CLUSTER_TODO_HANDLE_FAILOVER</code>标记，在周期执行的时间事件中会调用对状态进行判断决定是否执行故障转移。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterProcessPacket</span><span class="params">(clusterLink *link)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* PING, PONG, MEET: process config information. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG ||</span><br><span class="line">        type == CLUSTERMSG_TYPE_MEET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 省略其他else if </span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST) &#123; <span class="comment">// 处理CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息</span></span><br><span class="line">        <span class="keyword">if</span> (!sender) <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        clusterSendFailoverAuthIfNeeded(sender,hdr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK) &#123; <span class="comment">// 处理CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息</span></span><br><span class="line">        <span class="keyword">if</span> (!sender) <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        <span class="comment">/* 如果发送者是主节点并且负责的slot数量大于0，并且CurrentEpoch大于或等于当前节点的failover_auth_epoch*/</span></span><br><span class="line">        <span class="keyword">if</span> (nodeIsMaster(sender) &amp;&amp; sender-&gt;numslots &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            senderCurrentEpoch &gt;= server.cluster-&gt;failover_auth_epoch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 当前节点的failover_auth_count加1 */</span></span><br><span class="line">            server.cluster-&gt;failover_auth_count++;</span><br><span class="line">            <span class="comment">/* 有可能获取了大多数节点的投票，先设置一个CLUSTER_TODO_HANDLE_FAILOVER标记 */</span></span><br><span class="line">            clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 省略其他else if </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterDoBeforeSleep</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line">    server.cluster-&gt;todo_before_sleep |= flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/投票.jpg" alt=""></p>
<h3 id="等待处理故障转移"><a href="#等待处理故障转移" class="headerlink" title="等待处理故障转移"></a>等待处理故障转移</h3><p>从节点收到投票后，会添加<code>CLUSTER_TODO_HANDLE_FAILOVER</code>标记，接下来看下对<code>CLUSTER_TODO_HANDLE_FAILOVER</code>状态的处理。</p>
<p>在<code>beforeSleep</code>函数（server.c文件中），如果开启了集群，会调用<code>clusterBeforeSleep</code>函数，里面就包含了对<code>CLUSTER_TODO_HANDLE_FAILOVER</code>状态的处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">     <span class="comment">/* 如果开启了集群，调用clusterBeforeSleep函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) clusterBeforeSleep();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>beforeSleep</code>函数是在Redis事件循环<code>aeMain</code>方法中被调用的，详细内容可参考<a href="https://www.cnblogs.com/shanml/p/16188250.html" target="_blank" rel="noopener">事件驱动框架源码分析 </a>文章。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        <span class="comment">// 调用了aeProcessEvents处理事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>clusterBeforeSleep</strong></p>
<p>在clusterBeforeSleep函数中，如果节点带有<code>CLUSTER_TODO_HANDLE_FAILOVER</code>标记，会调用<code>clusterHandleSlaveFailover</code>函数进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterBeforeSleep</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CLUSTER_TODO_HANDLE_MANUALFAILOVER) &#123; <span class="comment">// 处理CLUSTER_TODO_HANDLE_FAILOVER</span></span><br><span class="line">        <span class="comment">// 手动执行故障转移</span></span><br><span class="line">        <span class="keyword">if</span>(nodeIsSlave(myself)) &#123;</span><br><span class="line">            clusterHandleManualFailover();</span><br><span class="line">            <span class="keyword">if</span> (!(server.cluster_module_flags &amp; CLUSTER_MODULE_FLAG_NO_FAILOVER))</span><br><span class="line">                clusterHandleSlaveFailover(); <span class="comment">// 故障转移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; CLUSTER_TODO_HANDLE_FAILOVER) &#123; <span class="comment">// 如果是CLUSTER_TODO_HANDLE_FAILOVER状态</span></span><br><span class="line">        <span class="comment">/* 处理故障转移 */</span></span><br><span class="line">        clusterHandleSlaveFailover();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="故障转移处理-1"><a href="#故障转移处理-1" class="headerlink" title="故障转移处理"></a>故障转移处理</h4><p><code>clusterHandleSlaveFailover</code>函数在上面我们已经见到过，这次我们来关注集群的故障转移处理。</p>
<p>如果当前节点获取了大多数的投票，也就是<code>failover_auth_count</code>（得到的投票数量）大于等于<code>needed_quorum</code>，<code>needed_quorum</code>数量为集群中节点个数的一半+1，即可执行故障转移，接下来会调用<code>clusterFailoverReplaceYourMaster</code>函数完成故障转移。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterHandleSlaveFailover</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主从复制延迟时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> data_age;</span><br><span class="line">    <span class="comment">// 当前时间减去发起选举的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> auth_age = mstime() - server.cluster-&gt;failover_auth_time;</span><br><span class="line">    <span class="comment">// 计算quorum的数量，为集群中节点的数量的一半再加1</span></span><br><span class="line">    <span class="keyword">int</span> needed_quorum = (server.cluster-&gt;size / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 校验是否获取了大多数的投票，failover_auth_count大于等于needed_quorum，needed_quorum数量为集群中节点个数的一半+1 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster-&gt;failover_auth_count &gt;= needed_quorum) &#123;</span><br><span class="line">        <span class="comment">/* 如果取得了大多数投票，从节点被选举为主节点*/</span></span><br><span class="line"></span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Failover election won: I'm the new master."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 更新configEpoch为选举纪元failover_auth_epoch */</span></span><br><span class="line">        <span class="keyword">if</span> (myself-&gt;configEpoch &lt; server.cluster-&gt;failover_auth_epoch) &#123;</span><br><span class="line">            myself-&gt;configEpoch = server.cluster-&gt;failover_auth_epoch;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"configEpoch set to %llu after successful failover"</span>,</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) myself-&gt;configEpoch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 负责master的slot */</span></span><br><span class="line">        clusterFailoverReplaceYourMaster();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行故障转移"><a href="#执行故障转移" class="headerlink" title="执行故障转移"></a>执行故障转移</h4><p><strong>clusterFailoverReplaceYourMaster</strong></p>
<p>如果从节点收到了集群中过半的投票，就可以成为新的master节点，并接手下线的master节点的slot，具体的处理在clusterFailoverReplaceYourMaster函数中，主要处理逻辑如下：</p>
<ol>
<li>将当前节点设为主节点</li>
<li>将下线的master节点负责的所有slots设置到新的主节点中</li>
<li>更新相关状态并保存设置</li>
<li>广播PONG消息到其他节点，通知其他节点当前节点成为了主节点</li>
<li>如果是手动进行故障转移，清除手动执行故障状态 </li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterFailoverReplaceYourMaster</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// 旧的主节点</span></span><br><span class="line">    clusterNode *oldmaster = myself-&gt;slaveof;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(myself) || oldmaster == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将当前节点设为主节点 */</span></span><br><span class="line">    clusterSetNodeAsMaster(myself);</span><br><span class="line">    replicationUnsetMaster();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将下线的master节点负责的所有slots设置到新的主节点中 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CLUSTER_SLOTS; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (clusterNodeGetSlotBit(oldmaster,j)) &#123;</span><br><span class="line">            clusterDelSlot(j);</span><br><span class="line">            clusterAddSlot(myself,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新状态并保存设置*/</span></span><br><span class="line">    clusterUpdateState();</span><br><span class="line">    clusterSaveConfigOrDie(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 广播PONG消息到其他节点，通知其他节点当前节点成为了主节点 */</span></span><br><span class="line">    clusterBroadcastPong(CLUSTER_BROADCAST_ALL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是手动进行故障转移，清除状态 */</span></span><br><span class="line">    resetManualFailover();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/故障切换.jpg" alt=""></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/15/【Redis】Redis Cluster初始化及PING消息的发送/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/15/【Redis】Redis Cluster初始化及PING消息的发送/" itemprop="url">【Redis】Redis Cluster初始化及PING消息的发送</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-15T23:00:00+08:00">
                2022-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Cluster消息类型定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTERMSG_TYPE_PING 0          <span class="comment">/* Ping消息类型，节点间进行通信交换信息的消息 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTERMSG_TYPE_PONG 1          <span class="comment">/* Pong消息类型 (Ping命令的回复) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTERMSG_TYPE_MEET 2          <span class="comment">/* Meet消息类型，表示节点加入集群 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLUSTERMSG_TYPE_FAIL 3          <span class="comment">/* FAIL消息类型，表示节点下线*/</span></span></span><br></pre></td></tr></table></figure>
<p>在Redis初始化服务initServer函数中，调用aeCreateTimeEvent注册了时间事件，周期性的执行serverCron函数，在serverCron中可以看到每隔100ms调用一次clusterCron函数，执行Redis Cluster定时任务：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">        serverPanic(<span class="string">"Can't create event loop timers."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serverCron</span><span class="params">(struct aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Redis Cluster 定时任务，每隔100ms调用一次 */</span></span><br><span class="line">    run_with_period(<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) clusterCron();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>clusterCron</strong></p>
<p><strong>clusterCron是集群相关的定时执行函数</strong>，每100ms执行一次：</p>
<ol>
<li>遍历集群中的所有节点，校验是否有连接中断的节点并进行重新连接<ul>
<li>如果节点是自身或者是没有地址的节点，跳过</li>
<li>如果节点处于握手状态并且已经超时，跳过</li>
<li>如果连接为空，调用connConnect进行连接，回调函数为<strong>clusterLinkConnectHandler</strong></li>
</ul>
</li>
<li>每执行10次clusterCron函数时随机选取五个节点，然后从这五个节点选出最早收到PONG回复的那个节点，也就是<strong>找出最久没有进行通信的那个节点，向其发送PING消息</strong>，clusterCron每100ms执行一次，执行10次是1000ms，也就是说<strong>每1秒选取一个节点调用clusterSendPing函数发送一次PING消息</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 校验是否有连接中断的节点并进行重新连接 */</span></span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    server.cluster-&gt;stats_pfail_nodes = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历集群中的所有节点</span></span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取集群节点</span></span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果节点是自身或者是没有地址的节点，跳过 */</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;flags &amp; (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;flags &amp; CLUSTER_NODE_PFAIL)</span><br><span class="line">            server.cluster-&gt;stats_pfail_nodes++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果节点处于握手状态并且已经超时 */</span></span><br><span class="line">        <span class="keyword">if</span> (nodeInHandshake(node) &amp;&amp; now - node-&gt;ctime &gt; handshake_timeout) &#123;</span><br><span class="line">            clusterDelNode(node);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;link == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建clusterLink</span></span><br><span class="line">            clusterLink *link = createClusterLink(node);</span><br><span class="line">            link-&gt;conn = server.tls_cluster ? connCreateTLS() : connCreateSocket();</span><br><span class="line">            connSetPrivateData(link-&gt;conn, link);</span><br><span class="line">            <span class="comment">// 建立连接，监听函数为clusterLinkConnectHandler</span></span><br><span class="line">            <span class="keyword">if</span> (connConnect(link-&gt;conn, node-&gt;ip, node-&gt;cport, NET_FIRST_BIND_ADDR,</span><br><span class="line">                        clusterLinkConnectHandler) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;ping_sent == <span class="number">0</span>) node-&gt;ping_sent = mstime();</span><br><span class="line">                serverLog(LL_DEBUG, <span class="string">"Unable to connect to "</span></span><br><span class="line">                    <span class="string">"Cluster Node [%s]:%d -&gt; %s"</span>, node-&gt;ip,</span><br><span class="line">                    node-&gt;cport, server.neterr);</span><br><span class="line"></span><br><span class="line">                freeClusterLink(link);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置link</span></span><br><span class="line">            node-&gt;link = link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 每执行10次clusterCron函数，发送一次PING消息 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(iteration % <span class="number">10</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 随机选取节点并找到最早收到pong消息的节点 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 随机选取节点</span></span><br><span class="line">            de = dictGetRandomKey(server.cluster-&gt;nodes);</span><br><span class="line">            <span class="comment">// 获取节点</span></span><br><span class="line">            clusterNode *<span class="keyword">this</span> = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果节点的连接已中断或者本次PING命令处于活跃状态 */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;link == <span class="literal">NULL</span> || <span class="keyword">this</span>-&gt;ping_sent != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;flags &amp; (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 查找最早收到PONG消息的那个节点</span></span><br><span class="line">            <span class="keyword">if</span> (min_pong_node == <span class="literal">NULL</span> || min_pong &gt; <span class="keyword">this</span>-&gt;pong_received) &#123;</span><br><span class="line">                min_pong_node = <span class="keyword">this</span>;</span><br><span class="line">                min_pong = <span class="keyword">this</span>-&gt;pong_received;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是最早收到PONG消息的节点</span></span><br><span class="line">        <span class="keyword">if</span> (min_pong_node) &#123;</span><br><span class="line">            serverLog(LL_DEBUG,<span class="string">"Pinging node %.40s"</span>, min_pong_node-&gt;name);</span><br><span class="line">            <span class="comment">// 发送PING消息</span></span><br><span class="line">            clusterSendPing(min_pong_node-&gt;link, CLUSTERMSG_TYPE_PING);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>clusterNode</strong></p>
<p>clusterNode是集群中节点对应的结构体，包含了以下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime; <span class="comment">/* 节点对象创建时间 */</span></span><br><span class="line">    <span class="keyword">char</span> name[CLUSTER_NAMELEN]; <span class="comment">/* 节点名称 */</span></span><br><span class="line">    <span class="keyword">int</span> flags;      <span class="comment">/* 节点标识 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch; <span class="comment">/* configEpoch */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[CLUSTER_SLOTS/<span class="number">8</span>]; <span class="comment">/* 节点负责的slots */</span></span><br><span class="line">    sds slots_info; <span class="comment">/* Slots信息 */</span></span><br><span class="line">    <span class="keyword">int</span> numslots;   <span class="comment">/* 节点负责的slots数量 */</span></span><br><span class="line">    <span class="keyword">int</span> numslaves;  <span class="comment">/* 从节点的数量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> **<span class="title">slaves</span>;</span> <span class="comment">/* 指向从节点的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">slaveof</span>;</span> <span class="comment">/* 指向主节点的指针 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ping_sent;      <span class="comment">/* 最近一次发送PING消息的时间 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> pong_received;  <span class="comment">/* 收到pong消息的时间 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> data_received;  <span class="comment">/* Unix time we received any data */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> fail_time;      <span class="comment">/* 标记FAIL状态的时间 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> voted_time;     <span class="comment">/* 最近一次投票的时间 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> repl_offset_time;  <span class="comment">/* 收到主从复制offset的时间*/</span></span><br><span class="line">    <span class="keyword">mstime_t</span> orphaned_time;     <span class="comment">/* Starting time of orphaned master condition */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> repl_offset;      <span class="comment">/* 节点主从复制offset */</span></span><br><span class="line">    <span class="keyword">char</span> ip[NET_IP_STR_LEN];  <span class="comment">/* IP */</span></span><br><span class="line">    <span class="keyword">int</span> port;                   <span class="comment">/* 客户端通信端口 */</span></span><br><span class="line">    <span class="keyword">int</span> pport;                  <span class="comment">/* 使用TLS协议的端口 */</span></span><br><span class="line">    <span class="keyword">int</span> cport;                  <span class="comment">/* 集群通信端口 */</span></span><br><span class="line">    clusterLink *link;          <span class="comment">/* TCP/IP连接相关信息 */</span></span><br><span class="line">    <span class="built_in">list</span> *fail_reports;         <span class="comment">/* List of nodes signaling this as failing */</span></span><br><span class="line">&#125; clusterNode;</span><br></pre></td></tr></table></figure>
<p><strong>clusterLinkConnectHandler</strong></p>
<p>clusterLinkConnectHandler是建立连接的监听函数，当连接建立时会调用clusterLinkConnectHandler进行处理，在clusterLinkConnectHandler函数中可以看到，又调用了connSetReadHandler注册了可读事件的监听，对应的回调函数为clusterReadHandler，当<strong>收到其他节点发送的通信消息时会调用clusterReadHandler函数处理</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterLinkConnectHandler</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    clusterLink *link = connGetPrivateData(conn);</span><br><span class="line">    clusterNode *node = link-&gt;node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 校验连接是否成功 */</span></span><br><span class="line">    <span class="keyword">if</span> (connGetState(conn) != CONN_STATE_CONNECTED) &#123;</span><br><span class="line">        serverLog(LL_VERBOSE, <span class="string">"Connection with Node %.40s at %s:%d failed: %s"</span>,</span><br><span class="line">                node-&gt;name, node-&gt;ip, node-&gt;cport,</span><br><span class="line">                connGetLastError(conn));</span><br><span class="line">        freeClusterLink(link);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册readHandler，监听函数为clusterReadHandler */</span></span><br><span class="line">    connSetReadHandler(conn, clusterReadHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集群间通信"><a href="#集群间通信" class="headerlink" title="集群间通信"></a>集群间通信</h2><h3 id="通信消息结构体定义"><a href="#通信消息结构体定义" class="headerlink" title="通信消息结构体定义"></a>通信消息结构体定义</h3><p><strong>clusterMsg</strong></p>
<p>集群间通信的消息对应的结构体为clusterMsg，里面包含了消息类型、发送消息节点的slots信息以及<strong>节点间通信的消息体clusterMsgData</strong>等信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> sig[<span class="number">4</span>];        <span class="comment">/*  "RCmb"签名 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> totlen;    <span class="comment">/* 消息总长度 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ver;       <span class="comment">/* 协议版本, 当前设置为1 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> port;      <span class="comment">/* 端口 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;      <span class="comment">/* 消息类型 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> sender[CLUSTER_NAMELEN]; <span class="comment">/* 发送消息节点的名称 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> myslots[CLUSTER_SLOTS/<span class="number">8</span>]; <span class="comment">/* 发送消息节点的slots信息 */</span></span><br><span class="line">    <span class="keyword">char</span> slaveof[CLUSTER_NAMELEN];</span><br><span class="line">    <span class="keyword">char</span> myip[NET_IP_STR_LEN];    <span class="comment">/* 发送消息节点的ip */</span></span><br><span class="line">    <span class="keyword">char</span> notused1[<span class="number">32</span>];  <span class="comment">/* 32字节的保留数据 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> pport;      <span class="comment">/* 使用TLS协议时的端口 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> cport;      <span class="comment">/* 发送消息节点的集群总线端口，也就是用于集群间通信的端口 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> flags;      <span class="comment">/* 发送消息节点的flags标识 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> state; <span class="comment">/* 发送消息节点的集群状态 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> mflags[<span class="number">3</span>]; <span class="comment">/* Message flags: CLUSTERMSG_FLAG[012]_... */</span></span><br><span class="line">    <span class="keyword">union</span> clusterMsgData data; <span class="comment">// 集群通信的实际消息</span></span><br><span class="line">&#125; clusterMsg;</span><br></pre></td></tr></table></figure>
<p><strong>clusterMsgData</strong></p>
<p>clusterMsgData里面<strong>存储了节点间进行通信的实际消息，不同消息类型对应不同的数据结构</strong>：</p>
<ol>
<li><strong>clusterMsgDataGossip</strong>：PING, MEET 和 PONG消息对应的数据结构</li>
<li>clusterMsgDataFail：FAIL消息对应的数据结构</li>
<li>clusterMsgDataPublish：PUBLISH消息对应的数据结构</li>
<li>clusterMsgDataUpdate：UPDATE消息对应的数据结构</li>
<li>clusterMsgModule：MODULE消息对应的数据结构</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> clusterMsgData &#123;</span><br><span class="line">    <span class="comment">/* PING, MEET and PONG消息对应的数据结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgDataGossip gossip[<span class="number">1</span>];</span><br><span class="line">    &#125; ping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FAIL消息对应的数据结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgDataFail about;</span><br><span class="line">    &#125; fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PUBLISH消息对应的数据结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgDataPublish msg;</span><br><span class="line">    &#125; publish;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* UPDATE消息对应的数据结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgDataUpdate nodecfg;</span><br><span class="line">    &#125; update;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MODULE消息对应的数据结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgModule msg;</span><br><span class="line">    &#125; <span class="keyword">module</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>clusterMsgDataGossip</strong></p>
<p>clusterMsgDataGossip是集群间发送PING、MEET 和 PONG消息对应的数据结构，里面包含以下信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> nodename[CLUSTER_NAMELEN]; <span class="comment">/* 节点名称 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ping_sent; <span class="comment">/* 发送PING命令的时间 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pong_received; <span class="comment">/* 收到PONG命令的时间 */</span></span><br><span class="line">    <span class="keyword">char</span> ip[NET_IP_STR_LEN];  <span class="comment">/* 节点的IP */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> port;              <span class="comment">/* 用于客户端通信的端口 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> cport;             <span class="comment">/* 集群间通信的端口 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> flags;             <span class="comment">/* 节点的flags标识 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> pport;             <span class="comment">/* 使用TLS协议时的端口 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> notused1;</span><br><span class="line">&#125; clusterMsgDataGossip;</span><br></pre></td></tr></table></figure>
<h3 id="PING消息的发送"><a href="#PING消息的发送" class="headerlink" title="PING消息的发送"></a>PING消息的发送</h3><p><strong>clusterSendPing</strong></p>
<p>clusterSendPing函数用于向指定节点发送PING消息，<strong>Ping消息中不仅包含当前节点的信息，也会随机选取一些其他的节点，将其他节点的信息封装在消息体中进行发送</strong>，随机选取节点的个数计算规则如下：</p>
<ul>
<li><code>wanted</code>：<strong>随机选取的节点个数</strong>，默认是集群中节点的数量除以10</li>
<li><code>freshnodes</code>：随机选取的节点个数的最大值，默认集群中节点的数量减2</li>
</ul>
<p>如果<code>wanted</code>小于3，那么将<code>wanted</code>置为3，也就是最少选取3个节点；</p>
<p>如果<code>wanted</code>大于<code>freshnodes</code>，将<code>wanted</code>置为<code>freshnodes</code>的值，也就是最大可以选取<code>freshnodes</code>个节点；</p>
<p>选取的节点个数<code>wanted</code>确定之后，处理逻辑如下：</p>
<ol>
<li><p><strong>调用clusterBuildMessageHdr函数构建消息头</strong></p>
</li>
<li><p>根据<code>wanted</code>的数量随机选取节点，处于以下几种情况的节点将被跳过</p>
<ul>
<li>FAIL下线状态的节点</li>
<li><p>处于握手状态的节点</p>
</li>
<li><p>没有地址信息的节点</p>
</li>
<li>失去连接的节点并且没有配置slots.</li>
</ul>
</li>
<li><p><strong>调用clusterSetGossipEntry函数将选取的节点信息加入到消息体中</strong></p>
</li>
<li><p><strong>调用clusterSendMessage函数发送消息</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterSendPing</span><span class="params">(clusterLink *link, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf; <span class="comment">/* 发送的消息数据*/</span></span><br><span class="line">    clusterMsg *hdr; <span class="comment">/* 节点间通信消息 */</span></span><br><span class="line">    <span class="keyword">int</span> gossipcount = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> wanted; <span class="comment">/* 选取的节点个数 */</span></span><br><span class="line">    <span class="keyword">int</span> totlen; <span class="comment">/* 总长度 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群中节点的数量 - 2</span></span><br><span class="line">    <span class="keyword">int</span> freshnodes = dictSize(server.cluster-&gt;nodes)<span class="number">-2</span>;</span><br><span class="line">    <span class="comment">// 集群中节点的数量除以10</span></span><br><span class="line">    wanted = <span class="built_in">floor</span>(dictSize(server.cluster-&gt;nodes)/<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 如果wanted小于3，则设置为3</span></span><br><span class="line">    <span class="keyword">if</span> (wanted &lt; <span class="number">3</span>) wanted = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 如果大于最大节点数，设置为freshnodes</span></span><br><span class="line">    <span class="keyword">if</span> (wanted &gt; freshnodes) wanted = freshnodes;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (totlen &lt; (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(clusterMsg)) totlen = <span class="keyword">sizeof</span>(clusterMsg);</span><br><span class="line">    buf = zcalloc(totlen); <span class="comment">// 分配空间</span></span><br><span class="line">    hdr = (clusterMsg*) buf;</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;node &amp;&amp; type == CLUSTERMSG_TYPE_PING)</span><br><span class="line">        link-&gt;node-&gt;ping_sent = mstime();<span class="comment">// 更新发送PING消息时间</span></span><br><span class="line">    <span class="comment">// 构建消息头</span></span><br><span class="line">    clusterBuildMessageHdr(hdr,type);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 计算 gossip  */</span></span><br><span class="line">    <span class="keyword">int</span> maxiterations = wanted*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(freshnodes &gt; <span class="number">0</span> &amp;&amp; gossipcount &lt; wanted &amp;&amp; maxiterations--) &#123;</span><br><span class="line">        <span class="comment">// 随机选取节点</span></span><br><span class="line">        dictEntry *de = dictGetRandomKey(server.cluster-&gt;nodes);</span><br><span class="line">        clusterNode *<span class="keyword">this</span> = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果是自身 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == myself) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果是FAIL状态，跳过 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;flags &amp; CLUSTER_NODE_PFAIL) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 以下节点跳过:</span></span><br><span class="line"><span class="comment">         * 1) 处于握手状态的节点.</span></span><br><span class="line"><span class="comment">         * 3) 没有地址信息的节点.</span></span><br><span class="line"><span class="comment">         * 4) 失去连接的节点并且没有配置slots.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;flags &amp; (CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_NOADDR) ||</span><br><span class="line">            (<span class="keyword">this</span>-&gt;link == <span class="literal">NULL</span> &amp;&amp; <span class="keyword">this</span>-&gt;numslots == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            freshnodes--; <span class="comment">/* Technically not correct, but saves CPU. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果节点已经添加 */</span></span><br><span class="line">        <span class="keyword">if</span> (clusterNodeIsInGossipSection(hdr,gossipcount,<span class="keyword">this</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 添加到消息体中 */</span></span><br><span class="line">        clusterSetGossipEntry(hdr,gossipcount,<span class="keyword">this</span>);</span><br><span class="line">        freshnodes--;</span><br><span class="line">        gossipcount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    totlen = <span class="keyword">sizeof</span>(clusterMsg)-<span class="keyword">sizeof</span>(<span class="keyword">union</span> clusterMsgData);</span><br><span class="line">    totlen += (<span class="keyword">sizeof</span>(clusterMsgDataGossip)*gossipcount);</span><br><span class="line">    hdr-&gt;count = htons(gossipcount);</span><br><span class="line">    hdr-&gt;totlen = htonl(totlen);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    clusterSendMessage(link,buf,totlen);</span><br><span class="line">    zfree(buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构建消息头"><a href="#构建消息头" class="headerlink" title="构建消息头"></a>构建消息头</h4><p><strong>clusterBuildMessageHdr</strong></p>
<p>clusterBuildMessageHdr函数用于构建消息头，设置了消息发送者的节点相关信息：</p>
<ol>
<li>设置了签名、消息类型、节点IP、端口等信息</li>
<li><strong>设置发送消息节点的slots信息，如果发送消息的节点是从节点，需要使用它对应的主节点的slots信息</strong></li>
<li>计算集群消息的总长度totlen，并设置到消息头中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterBuildMessageHdr</span><span class="params">(clusterMsg *hdr, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> offset;</span><br><span class="line">    clusterNode *master;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是从节点, 使用它对应的主节点的信息 */</span></span><br><span class="line">    master = (nodeIsSlave(myself) &amp;&amp; myself-&gt;slaveof) ?</span><br><span class="line">              myself-&gt;slaveof : myself;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(hdr,<span class="number">0</span>,<span class="keyword">sizeof</span>(*hdr));</span><br><span class="line">    hdr-&gt;ver = htons(CLUSTER_PROTO_VER);</span><br><span class="line">    <span class="comment">// 设置签名</span></span><br><span class="line">    hdr-&gt;sig[<span class="number">0</span>] = <span class="string">'R'</span>;</span><br><span class="line">    hdr-&gt;sig[<span class="number">1</span>] = <span class="string">'C'</span>;</span><br><span class="line">    hdr-&gt;sig[<span class="number">2</span>] = <span class="string">'m'</span>;</span><br><span class="line">    hdr-&gt;sig[<span class="number">3</span>] = <span class="string">'b'</span>;</span><br><span class="line">    <span class="comment">// 设置消息类型</span></span><br><span class="line">    hdr-&gt;type = htons(type);</span><br><span class="line">    <span class="built_in">memcpy</span>(hdr-&gt;sender,myself-&gt;name,CLUSTER_NAMELEN);</span><br><span class="line">    <span class="built_in">memset</span>(hdr-&gt;myip,<span class="number">0</span>,NET_IP_STR_LEN);</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_announce_ip) &#123;</span><br><span class="line">        <span class="comment">// 设置ip</span></span><br><span class="line">        <span class="built_in">strncpy</span>(hdr-&gt;myip,server.cluster_announce_ip,NET_IP_STR_LEN);</span><br><span class="line">        hdr-&gt;myip[NET_IP_STR_LEN<span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 处理端口 */</span></span><br><span class="line">    <span class="keyword">int</span> announced_port, announced_pport, announced_cport;</span><br><span class="line">    deriveAnnouncedPorts(&amp;announced_port, &amp;announced_pport, &amp;announced_cport);</span><br><span class="line">    <span class="comment">// 设置当前节点的slots信息</span></span><br><span class="line">    <span class="built_in">memcpy</span>(hdr-&gt;myslots,master-&gt;slots,<span class="keyword">sizeof</span>(hdr-&gt;myslots));</span><br><span class="line">    <span class="built_in">memset</span>(hdr-&gt;slaveof,<span class="number">0</span>,CLUSTER_NAMELEN);</span><br><span class="line">    <span class="keyword">if</span> (myself-&gt;slaveof != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">memcpy</span>(hdr-&gt;slaveof,myself-&gt;slaveof-&gt;name, CLUSTER_NAMELEN);</span><br><span class="line">    <span class="comment">// 设置端口</span></span><br><span class="line">    hdr-&gt;port = htons(announced_port);</span><br><span class="line">    hdr-&gt;pport = htons(announced_pport);</span><br><span class="line">    hdr-&gt;cport = htons(announced_cport);</span><br><span class="line">    <span class="comment">// 设置标识</span></span><br><span class="line">    hdr-&gt;flags = htons(myself-&gt;flags);</span><br><span class="line">    <span class="comment">// 设置集群状态</span></span><br><span class="line">    hdr-&gt;state = server.cluster-&gt;state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置currentEpoch和configEpoch */</span></span><br><span class="line">    hdr-&gt;currentEpoch = htonu64(server.cluster-&gt;currentEpoch);</span><br><span class="line">    hdr-&gt;configEpoch = htonu64(master-&gt;configEpoch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置主从复制的offset. */</span></span><br><span class="line">    <span class="keyword">if</span> (nodeIsSlave(myself))</span><br><span class="line">        offset = replicationGetSlaveOffset();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        offset = server.master_repl_offset;</span><br><span class="line">    hdr-&gt;offset = htonu64(offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodeIsMaster(myself) &amp;&amp; server.cluster-&gt;mf_end)</span><br><span class="line">        hdr-&gt;mflags[<span class="number">0</span>] |= CLUSTERMSG_FLAG0_PAUSED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算消息总长度 */</span></span><br><span class="line">    <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_FAIL) &#123;</span><br><span class="line">        totlen = <span class="keyword">sizeof</span>(clusterMsg)-<span class="keyword">sizeof</span>(<span class="keyword">union</span> clusterMsgData);</span><br><span class="line">        totlen += <span class="keyword">sizeof</span>(clusterMsgDataFail);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_UPDATE) &#123;</span><br><span class="line">        totlen = <span class="keyword">sizeof</span>(clusterMsg)-<span class="keyword">sizeof</span>(<span class="keyword">union</span> clusterMsgData);</span><br><span class="line">        totlen += <span class="keyword">sizeof</span>(clusterMsgDataUpdate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置消息总长度</span></span><br><span class="line">    hdr-&gt;totlen = htonl(totlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构建消息体"><a href="#构建消息体" class="headerlink" title="构建消息体"></a>构建消息体</h4><p><strong>clusterSetGossipEntry</strong></p>
<p>clusterSetGossipEntry函数用于构建消息体，将随机选取的其他节点信息加入到ping消息对应的数组hdr-&gt;data.ping.gossip[i]中，并设置节点的相关信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterSetGossipEntry</span><span class="params">(clusterMsg *hdr, <span class="keyword">int</span> i, clusterNode *n)</span> </span>&#123;</span><br><span class="line">    clusterMsgDataGossip *gossip;</span><br><span class="line">    gossip = &amp;(hdr-&gt;data.ping.gossip[i]);</span><br><span class="line">    <span class="built_in">memcpy</span>(gossip-&gt;nodename,n-&gt;name,CLUSTER_NAMELEN);</span><br><span class="line">    <span class="comment">// 设置PING消息发送时间</span></span><br><span class="line">    gossip-&gt;ping_sent = htonl(n-&gt;ping_sent/<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 设置收到PONG消息时间</span></span><br><span class="line">    gossip-&gt;pong_received = htonl(n-&gt;pong_received/<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 设置IP</span></span><br><span class="line">    <span class="built_in">memcpy</span>(gossip-&gt;ip,n-&gt;ip,<span class="keyword">sizeof</span>(n-&gt;ip));</span><br><span class="line">    <span class="comment">// 设置端口</span></span><br><span class="line">    gossip-&gt;port = htons(n-&gt;port);</span><br><span class="line">    <span class="comment">// 设置集群端口</span></span><br><span class="line">    gossip-&gt;cport = htons(n-&gt;cport);</span><br><span class="line">    <span class="comment">// 设置标识</span></span><br><span class="line">    gossip-&gt;flags = htons(n-&gt;flags);</span><br><span class="line">    gossip-&gt;pport = htons(n-&gt;pport);</span><br><span class="line">    gossip-&gt;notused1 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PING消息的处理"><a href="#PING消息的处理" class="headerlink" title="PING消息的处理"></a>PING消息的处理</h3><p><strong>clusterReadHandler</strong></p>
<p>由上面的clusterLinkConnectHandler函数可知，<strong>收到其他节点发送的通信消息时会调用clusterReadHandler函数处理</strong>，在clusterReadHandler函数中会开启while循环，不断读取数据，直到获取完整的数据（收到的数据长度rcvbuflen等于消息中设置数据总长度时），调用clusterProcessPacket函数处理收到的消息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterReadHandler</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    clusterMsg buf[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    clusterMsg *hdr;</span><br><span class="line">    clusterLink *link = connGetPrivateData(conn);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> readlen, rcvbuflen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123; </span><br><span class="line">        rcvbuflen = link-&gt;rcvbuf_len;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        nread = connRead(conn,buf,readlen);</span><br><span class="line">        <span class="comment">// 如果数据读取完毕</span></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span> &amp;&amp; (connGetState(conn) == CONN_STATE_CONNECTED)) <span class="keyword">return</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 如果已经获取完整数据（rcvbuflen等于消息中设置数据总长度），处理数据包 */</span></span><br><span class="line">        <span class="keyword">if</span> (rcvbuflen &gt;= <span class="number">8</span> &amp;&amp; rcvbuflen == ntohl(hdr-&gt;totlen)) &#123;</span><br><span class="line">            <span class="comment">// 处理消息</span></span><br><span class="line">            <span class="keyword">if</span> (clusterProcessPacket(link)) &#123; </span><br><span class="line">                <span class="keyword">if</span> (link-&gt;rcvbuf_alloc &gt; RCVBUF_INIT_LEN) &#123;</span><br><span class="line">                    zfree(link-&gt;rcvbuf);</span><br><span class="line">                    link-&gt;rcvbuf = zmalloc(link-&gt;rcvbuf_alloc = RCVBUF_INIT_LEN);</span><br><span class="line">                &#125;</span><br><span class="line">                link-&gt;rcvbuf_len = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>clusterProcessPacket</strong></p>
<p>clusterProcessPacket函数用于处理收到的通信消息，可以看到有许多if else分支，根据消息类型的不同，进行了不同的处理，这里先只关注PING消息的处理：</p>
<ol>
<li>如果消息类型是PING或者MEET，<strong>调用clusterSendPing函数发送PONG消息，传入的消息类型为CLUSTERMSG_TYPE_PONG，说明PING和PONG消息都是通过clusterSendPing函数实现的，PING和PONG消息的数据结构一致，那么回复的PONG消息中也会带上回复者的节点信息以及回复者随机选取的其他节点信息，以此达到节点间交换信息的目的</strong></li>
<li>如果是PING, PONG或者MEET消息，并且sender不为空，不为空表示发送消息的节点是当前节点已知的，<strong>调用clusterProcessGossipSection函数处理消息体中的Gossip数据</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clusterProcessPacket</span><span class="params">(clusterLink *link)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取发送的消息</span></span><br><span class="line">    clusterMsg *hdr = (clusterMsg*) link-&gt;rcvbuf;</span><br><span class="line">    <span class="comment">// 消息长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> totlen = ntohl(hdr-&gt;totlen);</span><br><span class="line">    <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type = ntohs(hdr-&gt;type);</span><br><span class="line">    <span class="keyword">mstime_t</span> now = mstime();</span><br><span class="line">    <span class="keyword">uint16_t</span> flags = ntohs(hdr-&gt;flags);</span><br><span class="line">    <span class="keyword">uint64_t</span> senderCurrentEpoch = <span class="number">0</span>, senderConfigEpoch = <span class="number">0</span>;</span><br><span class="line">    clusterNode *sender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 校验发送者是否是已知的节点 */</span></span><br><span class="line">    sender = clusterLookupNode(hdr-&gt;sender);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更是发送者收到数据的时间*/</span></span><br><span class="line">    <span class="keyword">if</span> (sender) sender-&gt;data_received = now;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* 如果是PING消息或者MEET消息 */</span></span><br><span class="line">    <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_MEET) &#123;</span><br><span class="line">        serverLog(LL_DEBUG,<span class="string">"Ping packet received: %p"</span>, (<span class="keyword">void</span>*)link-&gt;node);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (!sender &amp;&amp; type == CLUSTERMSG_TYPE_MEET)</span><br><span class="line">            clusterProcessGossipSection(hdr,link);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 发送PONG消息，这里传入的类型是CLUSTERMSG_TYPE_PONG */</span></span><br><span class="line">        clusterSendPing(link,CLUSTERMSG_TYPE_PONG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PING, PONG, MEET 消息 */</span></span><br><span class="line">    <span class="keyword">if</span> (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG ||</span><br><span class="line">        type == CLUSTERMSG_TYPE_MEET)</span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 处理消息体中的Gossip节点数据 */</span></span><br><span class="line">        <span class="keyword">if</span> (sender) clusterProcessGossipSection(hdr,link);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Received unknown packet type: %d"</span>, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>clusterProcessGossipSection</strong></p>
<p>clusterProcessGossipSection函数用于处理clusterMsg中的Gossip节点信息g，它从集群消息中获取Gossip节点数据，根据节点数量进行遍历：</p>
<ol>
<li><p>调用clusterLookupNode函数根据nodename从当前收到消息的节点的集群中查找Gossip节点，查找结果记为<code>node</code></p>
<ul>
<li>如果<code>node</code>如果不为空，说明可以从当前节点的集群中找到，Gossip节点针对当前节点是已知的，<strong>需要注意node指向的是当前收到消息节点中维护的相同nodename的节点，g指向当前正在遍历的gossip节点（sender发送的消息中携带gossip数组），注意两者的区别</strong></li>
<li>如果<code>node</code>如果为空，说明Gossip节点针对当前节点是未知的，之前不在当前节点维护的集群节点中</li>
</ul>
</li>
<li><p>如果<code>node</code>不为空，也就是当前收到消息这个节点的集群中已经存在<code>node</code>节点，进行如下处理：</p>
<p>（1）发送消息的节点<code>sender</code>是主节点时有以下两种情况：</p>
<ul>
<li>如果<code>node</code>是FAIL或者PFAIL状态，需要将<code>sender</code>加入到<code>node</code>节点的下线链表fail_reports中，表示sender认为node节点下线（clusterNodeAddFailureReport函数）</li>
<li>断是否有必要将<code>node</code>标记为下线状态（markNodeAsFailingIfNeeded函数）</li>
<li>如果<code>node</code>不是FAIL或者PFAIL状态，需要校验<code>node</code>是否已经在<code>sender</code>的下线节点链表fail_reports中，如果在需要从中移除</li>
</ul>
<p>（2）如果<code>node</code>节点不是FAIL、PFAIL、NOADDR状态，并且<code>node</code>的ip或者端口与<code>g</code>指向的gossip节点中的ip或者端口不一致，需要更新node中的ip和端口</p>
</li>
<li><p>如果<code>node</code>为空，说明之前不在当前节点维护的集群节点中，如果gossip节点不处于NOADDR状态并且不在nodes_black_list中，新建节点，加入到当前收到消息的节点维护的集群数据server.cluster中</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clusterProcessGossipSection</span><span class="params">(clusterMsg *hdr, clusterLink *link)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> count = ntohs(hdr-&gt;count);</span><br><span class="line">    <span class="comment">// 获取clusterMsgDataGossip数据</span></span><br><span class="line">    clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr-&gt;data.ping.gossip;</span><br><span class="line">    <span class="comment">// 发送消息的节点</span></span><br><span class="line">    clusterNode *sender = link-&gt;node ? link-&gt;node : clusterLookupNode(hdr-&gt;sender);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(count--) &#123;</span><br><span class="line">        <span class="comment">// 获取节点标识</span></span><br><span class="line">        <span class="keyword">uint16_t</span> flags = ntohs(g-&gt;flags);</span><br><span class="line">        clusterNode *node;</span><br><span class="line">        sds ci;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.verbosity == LL_DEBUG) &#123;</span><br><span class="line">            ci = representClusterNodeFlags(sdsempty(), flags);</span><br><span class="line">            serverLog(LL_DEBUG,<span class="string">"GOSSIP %.40s %s:%d@%d %s"</span>,</span><br><span class="line">                g-&gt;nodename,</span><br><span class="line">                g-&gt;ip,</span><br><span class="line">                ntohs(g-&gt;port),</span><br><span class="line">                ntohs(g-&gt;cport),</span><br><span class="line">                ci);</span><br><span class="line">            sdsfree(ci);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 根据nodename查找节点，node指向当前收到消息节点中维护的节点*/</span></span><br><span class="line">        node = clusterLookupNode(g-&gt;nodename);</span><br><span class="line">        <span class="comment">// 如果节点已知</span></span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            <span class="comment">/* 如果发送者是主节点 */</span></span><br><span class="line">            <span class="keyword">if</span> (sender &amp;&amp; nodeIsMaster(sender) &amp;&amp; node != myself) &#123;</span><br><span class="line">                <span class="comment">// 如果gossip节点是FAIL或者PFAIL状态</span></span><br><span class="line">                <span class="keyword">if</span> (flags &amp; (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &#123;</span><br><span class="line">                    <span class="comment">// 将sender加入到node节点的下线链表fail_reports中，表示sender认为node节点下线</span></span><br><span class="line">                    <span class="keyword">if</span> (clusterNodeAddFailureReport(node,sender)) &#123;</span><br><span class="line">                        serverLog(LL_VERBOSE,</span><br><span class="line">                            <span class="string">"Node %.40s reported node %.40s as not reachable."</span>,</span><br><span class="line">                            sender-&gt;name, node-&gt;name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 判断是否有必要将节点置为客观下线</span></span><br><span class="line">                    markNodeAsFailingIfNeeded(node);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 校验节点是否在下线节点链表fail_reports中，如果在需要移除恢复在线状态</span></span><br><span class="line">                    <span class="keyword">if</span> (clusterNodeDelFailureReport(node,sender)) &#123;</span><br><span class="line">                        serverLog(LL_VERBOSE,</span><br><span class="line">                            <span class="string">"Node %.40s reported node %.40s is back online."</span>,</span><br><span class="line">                            sender-&gt;name, node-&gt;name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果节点不是FAIL或者PFAIL状态，并且node中记录的ping发送时间为0，并且node不在fail_reports中*/</span></span><br><span class="line">            <span class="keyword">if</span> (!(flags &amp; (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &amp;&amp;</span><br><span class="line">                node-&gt;ping_sent == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                clusterNodeFailureReportsCount(node) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">mstime_t</span> pongtime = ntohl(g-&gt;pong_received);</span><br><span class="line">                pongtime *= <span class="number">1000</span>; <span class="comment">/* 转为毫秒 */</span></span><br><span class="line">                <span class="keyword">if</span> (pongtime &lt;= (server.mstime+<span class="number">500</span>) &amp;&amp;</span><br><span class="line">                    pongtime &gt; node-&gt;pong_received)</span><br><span class="line">                &#123;</span><br><span class="line">                    node-&gt;pong_received = pongtime; <span class="comment">// 更新收到pong消息时间</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果node节点不是FAIL、PFAIL、NOADDR状态，并且node的ip或者端口与g节点中的ip或者端口不一致，需要更新node中的ip和端口 */</span></span><br><span class="line">            <span class="comment">/* 需要注意node节点和g节点的区别，node节点是从当前收到消息节点中根据节点id查找到的节点，也就是接收者自己记录的节点信息 */</span></span><br><span class="line">            <span class="comment">/* g指向当前在遍历的那个gossip节点，也就是发送者带过来的节点信息 */</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;flags &amp; (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL) &amp;&amp;</span><br><span class="line">                !(flags &amp; CLUSTER_NODE_NOADDR) &amp;&amp;</span><br><span class="line">                !(flags &amp; (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &amp;&amp;</span><br><span class="line">                (strcasecmp(node-&gt;ip,g-&gt;ip) ||</span><br><span class="line">                 node-&gt;port != ntohs(g-&gt;port) ||</span><br><span class="line">                 node-&gt;cport != ntohs(g-&gt;cport)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;link) freeClusterLink(node-&gt;link);</span><br><span class="line">                <span class="comment">// 更新node节点中的端口、ip信息</span></span><br><span class="line">                <span class="built_in">memcpy</span>(node-&gt;ip,g-&gt;ip,NET_IP_STR_LEN);</span><br><span class="line">                node-&gt;port = ntohs(g-&gt;port);</span><br><span class="line">                node-&gt;pport = ntohs(g-&gt;pport);</span><br><span class="line">                node-&gt;cport = ntohs(g-&gt;cport);</span><br><span class="line">                node-&gt;flags &amp;= ~CLUSTER_NODE_NOADDR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果节点未知</span></span><br><span class="line">            <span class="comment">/* 如果节点不处于NOADDR状态并且不在nodes_black_list中 */</span></span><br><span class="line">            <span class="keyword">if</span> (sender &amp;&amp;</span><br><span class="line">                !(flags &amp; CLUSTER_NODE_NOADDR) &amp;&amp;</span><br><span class="line">                !clusterBlacklistExists(g-&gt;nodename))</span><br><span class="line">            &#123;</span><br><span class="line">                clusterNode *node;</span><br><span class="line">                <span class="comment">// 创建节点</span></span><br><span class="line">                node = createClusterNode(g-&gt;nodename, flags);</span><br><span class="line">                <span class="built_in">memcpy</span>(node-&gt;ip,g-&gt;ip,NET_IP_STR_LEN);</span><br><span class="line">                node-&gt;port = ntohs(g-&gt;port);</span><br><span class="line">                node-&gt;pport = ntohs(g-&gt;pport);</span><br><span class="line">                node-&gt;cport = ntohs(g-&gt;cport);</span><br><span class="line">                <span class="comment">// 加入到当前节点维护的集群server.cluster中</span></span><br><span class="line">                clusterAddNode(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 遍历下一个节点 */</span></span><br><span class="line">        g++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong><br><img src="/images/集群初始化.png" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a><br><a href="https://my.oschina.net/u/3474060/blog/952612" target="_blank" rel="noopener">zhaiguanjie-Redis源码剖析</a></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/11/【Redis】客观下线/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/11/【Redis】客观下线/" itemprop="url">【Redis】客观下线</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-11T23:00:00+08:00">
                2022-05-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在sentinelHandleRedisInstance函数中，如果是主节点，需要做如下处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelHandleRedisInstance</span><span class="params">(sentinelRedisInstance *ri)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是主节点</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER) &#123;</span><br><span class="line">        <span class="comment">// 检查是否主观下线</span></span><br><span class="line">        sentinelCheckObjectivelyDown(ri);</span><br><span class="line">        <span class="comment">// 是否需要开始故障切换</span></span><br><span class="line">        <span class="keyword">if</span> (sentinelStartFailoverIfNeeded(ri))</span><br><span class="line">            <span class="comment">// 获取其他哨兵实例对节点状态的判断</span></span><br><span class="line">            sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);</span><br><span class="line">        <span class="comment">// 故障切换状态机</span></span><br><span class="line">        sentinelFailoverStateMachine(ri);</span><br><span class="line">        <span class="comment">// 获取其他哨兵实例对节点状态的判断</span></span><br><span class="line">        sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>节点的状态定义</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRI_MASTER  (1&lt;&lt;0) <span class="comment">/* master主节点 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRI_SLAVE   (1&lt;&lt;1) <span class="comment">/* slave从节点 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRI_SENTINEL (1&lt;&lt;2) <span class="comment">/* 哨兵节点 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRI_S_DOWN (1&lt;&lt;3)   <span class="comment">/* 主观下线 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRI_O_DOWN (1&lt;&lt;4)   <span class="comment">/* 客观下线 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRI_MASTER_DOWN (1&lt;&lt;5) <span class="comment">/* 节点下线 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRI_FAILOVER_IN_PROGRESS (1&lt;&lt;6) <span class="comment">/* 正在执行master节点的故障切换</span></span></span><br><span class="line"><span class="meta"><span class="comment">换 */</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h3><p><strong>sentinelCheckObjectivelyDown</strong></p>
<p>sentinelCheckObjectivelyDown函数用于判断master节点是否客观下线：</p>
<ol>
<li><strong>首先确认主节点是否已经被哨兵标记为主观下线</strong>，如果已经主观下线，quorum的值置为1，表示当前已经有1个哨兵认为master主观下线，进行第2步</li>
<li>master-&gt;sentinels存储了监控当前master的其他哨兵节点，<strong>遍历其他哨兵节点，通过flag标识中是否有SRI_MASTER_DOWN状态判断其他哨兵对MASTER节点下线的判断，如果有则认为MASTER下线，对quorum数量加1</strong></li>
<li>遍历结束后<strong>判断quorum的数量是否大于master-&gt;quorum设置的数量，也就是是否有过半的哨兵认为主节点下线</strong>，如果是将odown置为1，认为主节点客观下线</li>
<li>根据odown的值判断主节点是否客观下线<ul>
<li>如果客观下线，确认master-&gt;flags是否有SRI_O_DOWN状态，如果没有，发布+odown客观下线事件并将master-&gt;flags置为SRI_O_DOWN状态</li>
<li>如果没有客观下线，校验master-&gt;flags是否有SRI_O_DOWN状态，如果有，需要发布-odown事件，取消master的客观下线标记（master-&gt;flags的SRI_O_DOWN状态取消）</li>
</ul>
</li>
</ol>
<p>可以看到，master节点客观下线需要根据其他哨兵实例对主节点的判断来共同决定，具体是通过其他哨兵实例的flag中是否有SRI_MASTER_DOWN状态来判断的，<strong>如果认为master下线的哨兵个数超过了master节点中的quorum设置，master节点将被认定为客观下线，发布+odown客观下线事件</strong>，关于SRI_MASTER_DOWN状态是在哪里设置的在后面会讲到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelCheckObjectivelyDown</span><span class="params">(sentinelRedisInstance *master)</span> </span>&#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> quorum = <span class="number">0</span>, odown = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断主节点是否被标记为主观下线SRI_S_DOWN</span></span><br><span class="line">    <span class="keyword">if</span> (master-&gt;flags &amp; SRI_S_DOWN) &#123;</span><br><span class="line">        <span class="comment">/* quorum初始化为1 */</span></span><br><span class="line">        quorum = <span class="number">1</span>; </span><br><span class="line">        <span class="comment">/* 遍历监听主节点的其他哨兵实例. */</span></span><br><span class="line">        di = dictGetIterator(master-&gt;sentinels);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取哨兵实例</span></span><br><span class="line">            sentinelRedisInstance *ri = dictGetVal(de);</span><br><span class="line">            <span class="comment">// 判断其他哨兵实例是否把master节点标记为下线</span></span><br><span class="line">            <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER_DOWN) quorum++;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        <span class="comment">// 如果大于master-&gt;quorum，也就是过半的哨兵认为主节点已经下线，标记客观下线</span></span><br><span class="line">        <span class="keyword">if</span> (quorum &gt;= master-&gt;quorum) odown = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果客观下线</span></span><br><span class="line">    <span class="keyword">if</span> (odown) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((master-&gt;flags &amp; SRI_O_DOWN) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 发布+odown客观下线事件</span></span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">"+odown"</span>,master,<span class="string">"%@ #quorum %d/%d"</span>,</span><br><span class="line">                quorum, master-&gt;quorum);</span><br><span class="line">            <span class="comment">// 将MASTER节点标记为SRI_O_DOWN</span></span><br><span class="line">            master-&gt;flags |= SRI_O_DOWN;</span><br><span class="line">            <span class="comment">// 标记客观下线的时间</span></span><br><span class="line">            master-&gt;o_down_since_time = mstime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非客观下线，判断master是否有客观下线标识</span></span><br><span class="line">        <span class="keyword">if</span> (master-&gt;flags &amp; SRI_O_DOWN) &#123;</span><br><span class="line">            <span class="comment">// 发布-odown事件</span></span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">"-odown"</span>,master,<span class="string">"%@"</span>);</span><br><span class="line">            <span class="comment">// 取消master的客观下线标识</span></span><br><span class="line">            master-&gt;flags &amp;= ~SRI_O_DOWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="是否需要执行故障切换"><a href="#是否需要执行故障切换" class="headerlink" title="是否需要执行故障切换"></a>是否需要执行故障切换</h3><p><strong>sentinelStartFailoverIfNeeded</strong></p>
<p>sentinelStartFailoverIfNeeded用于判断是否需要执行故障切换，可以开始故障切换的条件有三个：</p>
<ol>
<li><strong>master节点被认为客观下线（SRI_O_DOWN）</strong></li>
<li><strong>当前没有在进行故障切换</strong>（状态不是SRI_FAILOVER_IN_PROGRESS）</li>
<li>距离上次执行故障切换的时间，超过了故障切换超时时间设置的2倍，意味着<strong>上一次执行故障切换的时间已超时</strong>，可以重新进行故障切换</li>
</ol>
<p>同时满足以上三个条件，达到执行故障切换的标准，<strong>调用sentinelStartFailover函数</strong>，将故障切换的状态改为待执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sentinelStartFailoverIfNeeded</span><span class="params">(sentinelRedisInstance *master)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 如果MASTER不是客观下线，直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(master-&gt;flags &amp; SRI_O_DOWN)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前已经在执行故障切换直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (master-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断距离上次执行故障切换的时间，如果小于failover_timeout配置项的2倍，表示上次故障切换还未达到超时设置，所以本次不能执行*/</span></span><br><span class="line">    <span class="keyword">if</span> (mstime() - master-&gt;failover_start_time &lt;</span><br><span class="line">        master-&gt;failover_timeout*<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (master-&gt;failover_delay_logged != master-&gt;failover_start_time) &#123;</span><br><span class="line">            <span class="keyword">time_t</span> clock = (master-&gt;failover_start_time +</span><br><span class="line">                            master-&gt;failover_timeout*<span class="number">2</span>) / <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">char</span> ctimebuf[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">            ctime_r(&amp;clock,ctimebuf);</span><br><span class="line">            ctimebuf[<span class="number">24</span>] = <span class="string">'\0'</span>; <span class="comment">/* Remove newline. */</span></span><br><span class="line">            master-&gt;failover_delay_logged = master-&gt;failover_start_time;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Next failover delay: I will not start a failover before %s"</span>,</span><br><span class="line">                ctimebuf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始故障切换（只更改了故障切换状态）</span></span><br><span class="line">    sentinelStartFailover(master);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sentinelStartFailover"><a href="#sentinelStartFailover" class="headerlink" title="sentinelStartFailover"></a>sentinelStartFailover</h4><p>可以看到sentinelStartFailover函数<strong>并没有直接进行故障切换，而是更改了一些状态</strong>：</p>
<ol>
<li>将failover_state置为了<strong>SENTINEL_FAILOVER_STATE_WAIT_START</strong>等待开始执行状态</li>
<li>将master节点的flags设置为<strong>SRI_FAILOVER_IN_PROGRESS</strong>故障切换执行中状态</li>
<li><strong>将master的failover_epoch设置为当前哨兵的投票轮次current_epoch + 1 </strong>，在选举leader时会用到</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelStartFailover</span><span class="params">(sentinelRedisInstance *master)</span> </span>&#123;</span><br><span class="line">    serverAssert(master-&gt;flags &amp; SRI_MASTER);</span><br><span class="line">    <span class="comment">// 将状态更改为等待开始执行故障切换</span></span><br><span class="line">    master-&gt;failover_state = SENTINEL_FAILOVER_STATE_WAIT_START;</span><br><span class="line">    <span class="comment">// 设置为故障切换执行中状态</span></span><br><span class="line">    master-&gt;flags |= SRI_FAILOVER_IN_PROGRESS;</span><br><span class="line">    <span class="comment">// 设置failover_epoch故障切换轮次</span></span><br><span class="line">    master-&gt;failover_epoch = ++sentinel.current_epoch;</span><br><span class="line">    sentinelEvent(LL_WARNING,<span class="string">"+new-epoch"</span>,master,<span class="string">"%llu"</span>,</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) sentinel.current_epoch);</span><br><span class="line">    <span class="comment">// 发布事件</span></span><br><span class="line">    sentinelEvent(LL_WARNING,<span class="string">"+try-failover"</span>,master,<span class="string">"%@"</span>);</span><br><span class="line">    master-&gt;failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;</span><br><span class="line">    master-&gt;failover_state_change_time = mstime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取哨兵实例对主节点状态判断"><a href="#获取哨兵实例对主节点状态判断" class="headerlink" title="获取哨兵实例对主节点状态判断"></a>获取哨兵实例对主节点状态判断</h3><p>在sentinelHandleRedisInstance函数中，可以看到sentinelStartFailoverIfNeeded条件成立时以及函数的最后都调用了sentinelAskMasterStateToOtherSentinels，接下来就去看看sentinelAskMasterStateToOtherSentinels里面都做了什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER) &#123;</span><br><span class="line">    sentinelCheckObjectivelyDown(ri);</span><br><span class="line">    <span class="keyword">if</span> (sentinelStartFailoverIfNeeded(ri))</span><br><span class="line">        <span class="comment">// 获取其他哨兵实例对主节点的状态判断，这里传入的参数是SENTINEL_ASK_FORCED</span></span><br><span class="line">        sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);</span><br><span class="line">    sentinelFailoverStateMachine(ri);</span><br><span class="line">    <span class="comment">// 获取其他哨兵实例对主节点的状态判断，这里传入的参数是SENTINEL_NO_FLAGS</span></span><br><span class="line">    sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="is-master-down-by-addr命令发送"><a href="#is-master-down-by-addr命令发送" class="headerlink" title="is-master-down-by-addr命令发送"></a>is-master-down-by-addr命令发送</h4><p><strong>sentinelAskMasterStateToOtherSentinels</strong></p>
<p>sentinelAskMasterStateToOtherSentinels函数用于向其他哨兵实例发送is-master-down-by-addr命令获取其他哨兵实例对主节点状态的判断，它会遍历监听同一主节点的其他哨兵实例进行处理:</p>
<ol>
<li>获取每一个哨兵实例</li>
<li>计算距离每个哨兵实例上一次收到IS-MASTER-DOWN-BY-ADDR命令回复时间的间隔</li>
<li>如果距离上次收到回复的时间已经超过了SENTINEL_ASK_PERIOD周期的5倍，清空哨兵节点flag中的SRI_MASTER_DOWN状态和leader</li>
<li>如果master节点已经是下线状态SRI_S_DOWN，不需要进行处理，回到第一步处理下一个哨兵</li>
<li>如果哨兵节点用于发送命令的link连接处于未连接状态，不处理，回到第一步处理下一个哨兵</li>
<li>如果不是强制发送命令（入参的flag是SENTINEL_ASK_FORCED时），并且距离上次收到回复命令的时间还在SENTINEL_ASK_PERIOD周期内，不处理，回到第一步处理下一个哨兵</li>
<li>通过redisAsyncCommand函数发送发送is-master-down-by-addr命令，sentinelReceiveIsMasterDownReply为处理函数，redisAsyncCommand函数有如下参数：<ul>
<li>用于发送请求的连接：ri-&gt;link-&gt;cc</li>
<li><strong>收到命令返回结果时对应的处理函数：sentinelReceiveIsMasterDownReply</strong></li>
<li><strong>master节点的ip</strong>：announceSentinelAddr(master-&gt;addr)</li>
<li><strong>master节点端口</strong>：port</li>
<li><strong>当前哨兵的投票轮次</strong>：sentinel.current_epoch</li>
<li>实例ID：<strong>master-&gt;failover_state &gt; SENTINEL_FAILOVER_STATE_NONE时表示要执行故障切换，此时传入当前哨兵的myid，否则传入*</strong></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelAskMasterStateToOtherSentinels</span><span class="params">(sentinelRedisInstance *master, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="comment">// 遍历监听主节点的其他哨兵实例</span></span><br><span class="line">    di = dictGetIterator(master-&gt;sentinels);</span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取每一个哨兵实例</span></span><br><span class="line">        sentinelRedisInstance *ri = dictGetVal(de);</span><br><span class="line">        <span class="comment">// 计算距离上一次收到IS-MASTER-DOWN-BY-ADDR命令回复时间的间隔</span></span><br><span class="line">        <span class="keyword">mstime_t</span> elapsed = mstime() - ri-&gt;last_master_down_reply_time;</span><br><span class="line">        <span class="keyword">char</span> port[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果距离上次收到回复的时间已经超过了SENTINEL_ASK_PERIOD周期的5倍，清空相关设置 */</span></span><br><span class="line">        <span class="keyword">if</span> (elapsed &gt; SENTINEL_ASK_PERIOD*<span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">// 取消SRI_MASTER_DOWN状态</span></span><br><span class="line">            ri-&gt;flags &amp;= ~SRI_MASTER_DOWN;</span><br><span class="line">            sdsfree(ri-&gt;leader);</span><br><span class="line">            <span class="comment">// leader置为null</span></span><br><span class="line">            ri-&gt;leader = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果master已经是下线状态</span></span><br><span class="line">        <span class="keyword">if</span> ((master-&gt;flags &amp; SRI_S_DOWN) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果已经连接中断</span></span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果不是强制发送命令状态SENTINEL_ASK_FORCED，并且距离上次收到回复命令的时间还在SENTINEL_ASK_PERIOD周期内，不处理，回到第一步处理下一个哨兵</span></span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; SENTINEL_ASK_FORCED) &amp;&amp;</span><br><span class="line">            mstime() - ri-&gt;last_master_down_reply_time &lt; SENTINEL_ASK_PERIOD)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ll2string(port,<span class="keyword">sizeof</span>(port),master-&gt;addr-&gt;port);</span><br><span class="line">        <span class="comment">// 发送is-master-down-by-addr命令，sentinelReceiveIsMasterDownReply为处理函数</span></span><br><span class="line">        retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">                    sentinelReceiveIsMasterDownReply, ri,</span><br><span class="line">                    <span class="string">"%s is-master-down-by-addr %s %s %llu %s"</span>,</span><br><span class="line">                    sentinelInstanceMapCommand(ri,<span class="string">"SENTINEL"</span>),</span><br><span class="line">                    announceSentinelAddr(master-&gt;addr), port,</span><br><span class="line">                    sentinel.current_epoch,</span><br><span class="line">                    (master-&gt;failover_state &gt; SENTINEL_FAILOVER_STATE_NONE) ?</span><br><span class="line">                    sentinel.myid : <span class="string">"*"</span>);</span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="is-master-down-by-addr命令处理"><a href="#is-master-down-by-addr命令处理" class="headerlink" title="is-master-down-by-addr命令处理"></a>is-master-down-by-addr命令处理</h4><p><strong>sentinelCommand</strong></p>
<p>其他哨兵实例收到is-master-down-by-addr命令之后的处理逻辑在sentinelCommand函数中可以找到：</p>
<ol>
<li>根据请求传入的ip和端口信息获取主节点的sentinelRedisInstance实例对象（在发送is-master-down-by-addr命令的redisAsyncCommand函数中传入了主节点的ip和端口）</li>
<li>如果不是TILT模式，校验sentinelRedisInstance对象是否是主节点并且主节点被标记为主观下线，如果条件都成立表示主节点已经主观下线，将isdown置为1</li>
<li>判断请求参数中的runid是否不为*，如果不为*表示当前需要进行leader选举，<strong>调用sentinelVoteLeader选举哨兵Leader</strong></li>
<li>发送is-master-down-by-addr命令的回复，将对<strong>主节点主观下线的判断、选出的leader节点的runid、投票轮次leader_epoch返回给发送命令哨兵</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (c-&gt;argc == <span class="number">2</span> &amp;&amp; !strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"help"</span>)) &#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 省略其他else if...</span></span><br><span class="line"> <span class="comment">// 如果是is-master-down-by-addr命令</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"is-master-down-by-addr"</span>)) &#123;</span><br><span class="line">        <span class="comment">/* SENTINEL IS-MASTER-DOWN-BY-ADDR &lt;ip&gt; &lt;port&gt; &lt;current-epoch&gt; &lt;runid&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 参数说明:</span></span><br><span class="line"><span class="comment">         * ip和端口：哨兵检测的主节点的ip和端口</span></span><br><span class="line"><span class="comment">         * current-epoch：是故障切换中当前投票的轮次，每一个哨兵在一轮投票中只能投一次</span></span><br><span class="line"><span class="comment">         * runid：如果需要执行故障切换，传入的是哨兵的myid，否则传入的是 *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sentinelRedisInstance *ri;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> req_epoch;</span><br><span class="line">        <span class="keyword">uint64_t</span> leader_epoch = <span class="number">0</span>; <span class="comment">// 默认为0</span></span><br><span class="line">        <span class="keyword">char</span> *leader = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">long</span> port;</span><br><span class="line">        <span class="keyword">int</span> isdown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc != <span class="number">6</span>) <span class="keyword">goto</span> numargserr;</span><br><span class="line">        <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;port,<span class="literal">NULL</span>) != C_OK ||</span><br><span class="line">            getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">4</span>],&amp;req_epoch,<span class="literal">NULL</span>)</span><br><span class="line">                                                              != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 根据请求传入的ip和端口信息获取对应的哨兵实例，也就是监控的master节点</span></span><br><span class="line">        ri = getSentinelRedisInstanceByAddrAndRunID(sentinel.masters,</span><br><span class="line">            c-&gt;argv[<span class="number">2</span>]-&gt;ptr,port,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果不是TILT模式，校验是否是主节点并且主节点被标记为主观下线 */</span></span><br><span class="line">        <span class="keyword">if</span> (!sentinel.tilt &amp;&amp; ri &amp;&amp; (ri-&gt;flags &amp; SRI_S_DOWN) &amp;&amp;</span><br><span class="line">                                    (ri-&gt;flags &amp; SRI_MASTER))</span><br><span class="line">            isdown = <span class="number">1</span>;<span class="comment">// 确定主观下线</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果是主节点并且传入的runid不为*，调用sentinelVoteLeader选举Leader执行故障切换 */</span></span><br><span class="line">        <span class="keyword">if</span> (ri &amp;&amp; ri-&gt;flags &amp; SRI_MASTER &amp;&amp; strcasecmp(c-&gt;argv[<span class="number">5</span>]-&gt;ptr,<span class="string">"*"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 选举leader</span></span><br><span class="line">            leader = sentinelVoteLeader(ri,(<span class="keyword">uint64_t</span>)req_epoch,</span><br><span class="line">                                            c-&gt;argv[<span class="number">5</span>]-&gt;ptr,</span><br><span class="line">                                            &amp;leader_epoch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 发送回复包含三部分:</span></span><br><span class="line"><span class="comment">         * 下线状态, 选出的leader, leader的投票轮次leader_epoch */</span></span><br><span class="line">        addReplyArrayLen(c,<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 下线状态</span></span><br><span class="line">        addReply(c, isdown ? shared.cone : shared.czero);</span><br><span class="line">        <span class="comment">// leader不为空传入leader否则传入*</span></span><br><span class="line">        addReplyBulkCString(c, leader ? leader : <span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// 投票轮次</span></span><br><span class="line">        addReplyLongLong(c, (<span class="keyword">long</span> <span class="keyword">long</span>)leader_epoch);</span><br><span class="line">        <span class="keyword">if</span> (leader) sdsfree(leader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他else if...</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplySubcommandSyntaxError(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="is-master-down-by-addr回复处理"><a href="#is-master-down-by-addr回复处理" class="headerlink" title="is-master-down-by-addr回复处理"></a>is-master-down-by-addr回复处理</h4><p><strong>sentinelReceiveIsMasterDownReply</strong></p>
<p>在sentinelCommand中对命令处理之后发送了返回数据，数据里面包含主观下线的判断、leader的runid以及投票轮次leader_epoch，对返回数据的处理在sentinelReceiveIsMasterDownReply函数中：</p>
<ol>
<li>如果回复者也标记了节点主观下线，<strong>将哨兵实例的flags状态置为SRI_MASTER_DOWN下线状态，SRI_MASTER_DOWN状态就是在这里设置的</strong></li>
<li>如果返回的leader runid不是*，意味着哨兵实例对leader进行了投票，<strong>需要更新哨兵实例中的leader和leader_epoch</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的privdata指向回复is-master-down-by-addr命令的那个哨兵实例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelReceiveIsMasterDownReply</span><span class="params">(redisAsyncContext *c, <span class="keyword">void</span> *reply, <span class="keyword">void</span> *privdata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每个哨兵实例监控的master节点中，保存了其他监控该主节点的哨兵实例，这里的privdata就指向master节点存储的其他哨兵实例中回复了is-master-down-by-addr命令的那个哨兵实例</span></span><br><span class="line">    sentinelRedisInstance *ri = privdata;</span><br><span class="line">    instanceLink *link = c-&gt;data;</span><br><span class="line">    redisReply *r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reply || !link) <span class="keyword">return</span>;</span><br><span class="line">    link-&gt;pending_commands--;</span><br><span class="line">    r = reply;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; r-&gt;elements == <span class="number">3</span> &amp;&amp;</span><br><span class="line">        r-&gt;element[<span class="number">0</span>]-&gt;type == REDIS_REPLY_INTEGER &amp;&amp;</span><br><span class="line">        r-&gt;element[<span class="number">1</span>]-&gt;type == REDIS_REPLY_STRING &amp;&amp;</span><br><span class="line">        r-&gt;element[<span class="number">2</span>]-&gt;type == REDIS_REPLY_INTEGER)</span><br><span class="line">    &#123;</span><br><span class="line">        ri-&gt;last_master_down_reply_time = mstime();</span><br><span class="line">        <span class="comment">// 如果回复主观下线</span></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;element[<span class="number">0</span>]-&gt;integer == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 将回复命令的哨兵节点的flags状态改为SRI_MASTER_DOWN</span></span><br><span class="line">            ri-&gt;flags |= SRI_MASTER_DOWN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ri-&gt;flags &amp;= ~SRI_MASTER_DOWN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果runid不是*</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(r-&gt;element[<span class="number">1</span>]-&gt;str,<span class="string">"*"</span>)) &#123;</span><br><span class="line">            sdsfree(ri-&gt;leader);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)ri-&gt;leader_epoch != r-&gt;element[<span class="number">2</span>]-&gt;integer)</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"%s voted for %s %llu"</span>, ri-&gt;name,</span><br><span class="line">                    r-&gt;element[<span class="number">1</span>]-&gt;str,</span><br><span class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) r-&gt;element[<span class="number">2</span>]-&gt;integer);</span><br><span class="line">            <span class="comment">// 更新回复命令的哨兵存储的leader</span></span><br><span class="line">            ri-&gt;leader = sdsnew(r-&gt;element[<span class="number">1</span>]-&gt;str);</span><br><span class="line">            <span class="comment">// 更新投票轮次</span></span><br><span class="line">            ri-&gt;leader_epoch = r-&gt;element[<span class="number">2</span>]-&gt;integer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="故障切换状态机"><a href="#故障切换状态机" class="headerlink" title="故障切换状态机"></a>故障切换状态机</h3><p>在sentinelHandleRedisInstance函数中，判断是否需要执行故障切换之后，就会调用sentinelFailoverStateMachine函数进入故障切换状态机，根据<code>failover_state</code>故障切换状态调用不同的方法，我们先关注以下两种状态：</p>
<ol>
<li><p><strong>SENTINEL_FAILOVER_STATE_WAIT_START</strong>：等待执行状态，表示需要执行故障切换但还未开始，在sentinelStartFailoverIfNeeded函数中可以看到如果需要执行故障切换，会调用sentinelStartFailover函数将状态置为SENTINEL_FAILOVER_STATE_WAIT_START，对应的处理函数为<strong>sentinelFailoverWaitStart</strong>，sentinelFailoverWaitStart中会判断是当前哨兵节点是否是执行故障切换的leader，如果是将状态改为<strong>SENTINEL_FAILOVER_STATE_SELECT_SLAVE。</strong></p>
</li>
<li><p><strong>SENTINEL_FAILOVER_STATE_SELECT_SLAVE</strong>：从SLAVE节点中选举Master节点的状态，处于这个状态意味着需要从Master的从节点中选举出可以替代Master节点的从节点，进行故障切换，对应的处理函数为<strong>sentinelFailoverSelectSlave</strong>。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelFailoverStateMachine</span><span class="params">(sentinelRedisInstance *ri)</span> </span>&#123;</span><br><span class="line">    serverAssert(ri-&gt;flags &amp; SRI_MASTER);</span><br><span class="line">    <span class="comment">// 如果已经在故障切换执行中，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!(ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 状态机</span></span><br><span class="line">    <span class="keyword">switch</span>(ri-&gt;failover_state) &#123;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_WAIT_START:<span class="comment">// 等待执行</span></span><br><span class="line">            sentinelFailoverWaitStart(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_SELECT_SLAVE: <span class="comment">// 选举master节点</span></span><br><span class="line">            sentinelFailoverSelectSlave(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE:</span><br><span class="line">            sentinelFailoverSendSlaveOfNoOne(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_WAIT_PROMOTION:</span><br><span class="line">            sentinelFailoverWaitPromotion(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_RECONF_SLAVES:</span><br><span class="line">            sentinelFailoverReconfNextSlave(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>sentinelFailoverWaitStart</strong></p>
<p>sentinelFailoverWaitStart函数的处理逻辑如下：</p>
<ol>
<li>调用sentinelGetLeader获取执行故障切换的leader</li>
<li>对比当前哨兵是与获取到执行故障切换leader的myid是否一致，<strong>判断当前哨兵是否是执行故障切换的leader</strong></li>
<li>如果当前哨兵不是故障切换leader, 并且不是强制执行状态SRI_FORCE_FAILOVER，当前哨兵不能执行故障切换</li>
<li>如果当前哨兵是故障切换的leader节点，将故障切换状态改为<strong>SENTINEL_FAILOVER_STATE_SELECT_SLAVE状态，在下一次执行故障切换状态机时会从slave节点选出master节点进行故障切换</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelFailoverWaitStart</span><span class="params">(sentinelRedisInstance *ri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *leader;</span><br><span class="line">    <span class="keyword">int</span> isleader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取执行故障切换的leader */</span></span><br><span class="line">    leader = sentinelGetLeader(ri, ri-&gt;failover_epoch);</span><br><span class="line">    <span class="comment">// leader不为空并且与当前哨兵的myid一致</span></span><br><span class="line">    isleader = leader &amp;&amp; strcasecmp(leader,sentinel.myid) == <span class="number">0</span>;</span><br><span class="line">    sdsfree(leader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前哨兵不是leader, 并且不是强制执行状态SRI_FORCE_FAILOVER，当前哨兵不能执行故障切换 */</span></span><br><span class="line">    <span class="keyword">if</span> (!isleader &amp;&amp; !(ri-&gt;flags &amp; SRI_FORCE_FAILOVER)) &#123;</span><br><span class="line">        <span class="keyword">int</span> election_timeout = SENTINEL_ELECTION_TIMEOUT;</span><br><span class="line">        <span class="keyword">if</span> (election_timeout &gt; ri-&gt;failover_timeout)</span><br><span class="line">            election_timeout = ri-&gt;failover_timeout;</span><br><span class="line">        <span class="comment">/* 在超时时终止故障切换 */</span></span><br><span class="line">        <span class="keyword">if</span> (mstime() - ri-&gt;failover_start_time &gt; election_timeout) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">"-failover-abort-not-elected"</span>,ri,<span class="string">"%@"</span>);</span><br><span class="line">            sentinelAbortFailover(ri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sentinelEvent(LL_WARNING,<span class="string">"+elected-leader"</span>,ri,<span class="string">"%@"</span>);</span><br><span class="line">    <span class="keyword">if</span> (sentinel.simfailure_flags &amp; SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION)</span><br><span class="line">        sentinelSimFailureCrash();</span><br><span class="line">    <span class="comment">// 更改为SENTINEL_FAILOVER_STATE_SELECT_SLAVE状态，在下一次执行故障切换状态机时会从slave节点选出master节点</span></span><br><span class="line">    ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_SELECT_SLAVE;</span><br><span class="line">    ri-&gt;failover_state_change_time = mstime();</span><br><span class="line">    sentinelEvent(LL_WARNING,<span class="string">"+failover-state-select-slave"</span>,ri,<span class="string">"%@"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><p><strong>sentinelGetLeader</strong></p>
<p>sentinelGetLeader函数用于从<strong>指定的投票轮次epoch中获取Leader节点</strong>，成为一个Leader节点需要获取大多数的投票，处理逻辑如下：</p>
<ol>
<li>创建了一个counters字典，里面记录了每个哨兵得到的投票数，其中key为哨兵实例的id<ul>
<li>counters的数据来源：遍历master-&gt;sentinels获取其他哨兵实例，<strong>判断哨兵实例记录的leader是否为空并且投票轮次与当前指定的epoch一致</strong>，如果一致加入counters中并将投票数增加一票</li>
</ul>
</li>
<li>从counters中获取投票数最多的哨兵实例记为winner，最大投票数记为max_votes</li>
<li>判断winner是否为空<ul>
<li>如果不为空，在master节点中记录的leader节点和winner节点中，选出纪元（投票轮次）最新的节点记为myvote</li>
<li>如果为空，在master节点中记录的leader节点和当前哨兵实例中，选出纪元（投票轮次）最新的节点记为myvote</li>
</ul>
</li>
<li>经过上一步之后，如果myvote不为空并且leader_epoch与调用sentinelGetLeader函数时指定的epoch一致，当前哨兵给myvote增加一票，然后判断myvote得到的投票数是否大于max_votes，如果是将winner获胜者更新为myvote</li>
<li>到这里，<strong>winner中记录了本轮投票的获胜者</strong>，也就是得到票数最多的那个，max_votes记录了获得投票数，能否成为leader还需满足以下两个条件，，<strong>保证选举出的leader得到了过半哨兵的投票</strong>：<ul>
<li>条件一：得到的投票数max_votes大于voters_quorum，voters_quorum为哨兵实例个数的一半+1，也就是需要有过半的哨兵实例</li>
<li>条件二：得到的投票数max_votes大于master-&gt;quorum，这个值是在 sentinel.conf 配置文件中设置的，一般设置为哨兵总数的一半+1</li>
</ul>
</li>
<li>选举结束，返回winner中记录的实例id作为leader</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sentinelGetLeader</span><span class="params">(sentinelRedisInstance *master, <span class="keyword">uint64_t</span> epoch)</span> </span>&#123;</span><br><span class="line">    dict *counters;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> voters = <span class="number">0</span>, voters_quorum;</span><br><span class="line">    <span class="keyword">char</span> *myvote;</span><br><span class="line">    <span class="keyword">char</span> *winner = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> leader_epoch;</span><br><span class="line">    <span class="keyword">uint64_t</span> max_votes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    serverAssert(master-&gt;flags &amp; (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS));</span><br><span class="line">    <span class="comment">// 创建字典</span></span><br><span class="line">    counters = dictCreate(&amp;leaderVotesDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 获取所有的哨兵实例个数包含当前哨兵</span></span><br><span class="line">    voters = dictSize(master-&gt;sentinels)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历哨兵实例 */</span></span><br><span class="line">    di = dictGetIterator(master-&gt;sentinels);</span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取每一个哨兵节点</span></span><br><span class="line">        sentinelRedisInstance *ri = dictGetVal(de);</span><br><span class="line">        <span class="comment">// 如果某个哨兵实例的leader不为空并且leader的轮次等于指定的轮次</span></span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;leader != <span class="literal">NULL</span> &amp;&amp; ri-&gt;leader_epoch == sentinel.current_epoch)</span><br><span class="line">            sentinelLeaderIncr(counters,ri-&gt;leader); <span class="comment">// ri-&gt;leader的投票数加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">    di = dictGetIterator(counters);</span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取投票数</span></span><br><span class="line">        <span class="keyword">uint64_t</span> votes = dictGetUnsignedIntegerVal(de);</span><br><span class="line">        <span class="comment">// 获取投票数最多的节点的runid，记录在winner中</span></span><br><span class="line">        <span class="keyword">if</span> (votes &gt; max_votes) &#123;</span><br><span class="line">            max_votes = votes;</span><br><span class="line">            winner = dictGetKey(de);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果winner不为空，在master节点和winner节点中获取epoch投票轮次最新的当做当前节点的投票者*/</span></span><br><span class="line">    <span class="comment">/* 如果winner为空，在master节点和当前哨兵节点中选取epoch投票轮次最新的节点*/</span></span><br><span class="line">    <span class="keyword">if</span> (winner)</span><br><span class="line">        myvote = sentinelVoteLeader(master,epoch,winner,&amp;leader_epoch);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        myvote = sentinelVoteLeader(master,epoch,sentinel.myid,&amp;leader_epoch);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (myvote &amp;&amp; leader_epoch == epoch) &#123;</span><br><span class="line">        <span class="comment">// 为myvote增加一票</span></span><br><span class="line">        <span class="keyword">uint64_t</span> votes = sentinelLeaderIncr(counters,myvote);</span><br><span class="line">        <span class="comment">// 如果超过了max_votes</span></span><br><span class="line">        <span class="keyword">if</span> (votes &gt; max_votes) &#123;</span><br><span class="line">            max_votes = votes; <span class="comment">// 更新max_votes</span></span><br><span class="line">            winner = myvote; <span class="comment">// 更新winner</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// voters_quorum，为哨兵实例个数的一半+1</span></span><br><span class="line">    voters_quorum = voters/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果投票数量max_votes小于quorum，说明未达到过半的投票数</span></span><br><span class="line">    <span class="keyword">if</span> (winner &amp;&amp; (max_votes &lt; voters_quorum || max_votes &lt; master-&gt;quorum))</span><br><span class="line">        winner = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    winner = winner ? sdsnew(winner) : <span class="literal">NULL</span>;</span><br><span class="line">    sdsfree(myvote);</span><br><span class="line">    dictRelease(counters);</span><br><span class="line">    <span class="comment">// 返回获胜的节点，也就是leader节点</span></span><br><span class="line">    <span class="keyword">return</span> winner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h4><p><strong>sentinelVoteLeader</strong></p>
<p>sentinelVoteLeader函数入参中可以看到传入了master节点，和<strong>候选节点的ID<code>req_runid</code>以及候选节点的投票纪元（轮次）<code>req_epoch</code></strong>。master节点中记录了<strong>当前哨兵节点选举的执行故障切换的leader节点</strong>，在master-&gt;leader中保存。sentinelVoteLeader就用于在这两个节点中选出获胜的那个节点：</p>
<ol>
<li>如果候选节点的req_epoch大于当前sentinel实例的epoch，将当前哨兵实例的current_epoch置为请求轮次req_epoch</li>
<li>如果master节点记录的leader_epoch小于候选节点的req_epoch，并且当前实例的轮次小于等于候选节点轮次，将master节点中的leader改为候选节点</li>
<li>返回master节点中记录的leader</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sentinelVoteLeader</span><span class="params">(sentinelRedisInstance *master, <span class="keyword">uint64_t</span> req_epoch, <span class="keyword">char</span> *req_runid, <span class="keyword">uint64_t</span> *leader_epoch)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果请求的轮次req_epoch大于当前sentinel实例的轮次</span></span><br><span class="line">    <span class="keyword">if</span> (req_epoch &gt; sentinel.current_epoch) &#123;</span><br><span class="line">        <span class="comment">// 将哨兵实例的current_epoch置为请求轮次</span></span><br><span class="line">        sentinel.current_epoch = req_epoch;</span><br><span class="line">        sentinelFlushConfig();</span><br><span class="line">        sentinelEvent(LL_WARNING,<span class="string">"+new-epoch"</span>,master,<span class="string">"%llu"</span>,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) sentinel.current_epoch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果master节点记录的轮次leader_epoch小于请求轮次，并且当前实例的轮次小于等于请求轮次</span></span><br><span class="line">    <span class="keyword">if</span> (master-&gt;leader_epoch &lt; req_epoch &amp;&amp; sentinel.current_epoch &lt;= req_epoch)</span><br><span class="line">    &#123;</span><br><span class="line">        sdsfree(master-&gt;leader);</span><br><span class="line">        <span class="comment">// 将leader置为传入的runid</span></span><br><span class="line">        master-&gt;leader = sdsnew(req_runid);</span><br><span class="line">        <span class="comment">// 更改master的leader_epoch</span></span><br><span class="line">        master-&gt;leader_epoch = sentinel.current_epoch;</span><br><span class="line">        sentinelFlushConfig();</span><br><span class="line">        sentinelEvent(LL_WARNING,<span class="string">"+vote-for-leader"</span>,master,<span class="string">"%s %llu"</span>,</span><br><span class="line">            master-&gt;leader, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) master-&gt;leader_epoch);</span><br><span class="line">        <span class="keyword">if</span> (strcasecmp(master-&gt;leader,sentinel.myid))</span><br><span class="line">            master-&gt;failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *leader_epoch = master-&gt;leader_epoch;</span><br><span class="line">    <span class="keyword">return</span> master-&gt;leader ? sdsnew(master-&gt;leader) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong><br><img src="/images/客观下线.png" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/03/【Redis】哨兵初始化和主观下线/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/03/【Redis】哨兵初始化和主观下线/" itemprop="url">【Redis】哨兵初始化和主观下线</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-03T17:00:00+08:00">
                2022-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在的redis启动函数main（server.c文件）中，对哨兵模式进行了检查，如果是哨兵模式，将调用initSentinelConfig和initSentinel进行初始化，initServer函数中会注册哨兵的时间事件，最后调用sentinelIsRunning运行哨兵实例，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查哨兵模式</span></span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv);</span><br><span class="line">    initServerConfig();</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">        initSentinelConfig(); <span class="comment">// 初始化哨兵配置</span></span><br><span class="line">        initSentinel(); <span class="comment">// 初始化哨兵</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="comment">// 初始化服务</span></span><br><span class="line">    initServer();</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode) &#123; <span class="comment">// 非哨兵模式</span></span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ACLLoadUsersAtStartup();</span><br><span class="line">        InitServerLast();</span><br><span class="line">        <span class="comment">// 运行哨兵实例</span></span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">        <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"STATUS=Ready to accept connections\n"</span>);</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">    aeMain(server.el);</span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哨兵初始化"><a href="#哨兵初始化" class="headerlink" title="哨兵初始化"></a>哨兵初始化</h2><h3 id="哨兵模式校验"><a href="#哨兵模式校验" class="headerlink" title="哨兵模式校验"></a>哨兵模式校验</h3><p><strong>checkForSentinelMode</strong></p>
<p>checkForSentinelMode函数在server.c文件中，用于校验是否是哨兵模式，可以看到有两种方式校验哨兵模式：</p>
<ol>
<li>直接执行<code>redis-sentinel</code>命令</li>
<li>执行<code>redis-server</code>命令，命令参数中带有<code>–sentinel</code>参数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkForSentinelMode</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// 直接执行redis-sentinel</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-sentinel"</span>) != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[j],<span class="string">"--sentinel"</span>)) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 执行的命令参数中，是否有–sentinel</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化配置项"><a href="#初始化配置项" class="headerlink" title="初始化配置项"></a>初始化配置项</h3><p><strong>initSentinelConfig</strong></p>
<p>initSentinelConfig函数在sentinel.c文件中，用于初始化哨兵配置：</p>
<ol>
<li>将哨兵实例的端口号设置为<code>REDIS_SENTINEL_PORT</code>，默认值26379</li>
<li>将<code>protected_mode</code>设置为0，表示允许外部链接哨兵实例，而不是只能通过127.0.0.1本地连接 server</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SENTINEL_PORT 26379</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSentinelConfig</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    server.port = REDIS_SENTINEL_PORT; <span class="comment">/* 设置默认端口 */</span></span><br><span class="line">    server.protected_mode = <span class="number">0</span>; <span class="comment">/* 允许外部链接哨兵实例 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>initSentinel</strong></p>
<p>在看initSentinel函数之前，首先看下Redis中哨兵sentinel对象对应的结构体sentinelState：</p>
<ul>
<li>current_epoch：<strong>当前纪元，投票选举Leader时使用，纪元可以理解为投票的轮次</strong></li>
<li>masters：<strong>监控的master节点哈希表</strong>，Key为master节点名称， value为master节点对应sentinelRedisInstance实例的指针 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> myid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>]; <span class="comment">/* sentinel ID */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> current_epoch;         <span class="comment">/* 当前的纪元（投票轮次）*/</span></span><br><span class="line">    dict *masters;      <span class="comment">/* 监控的master节点哈希表，Key为master节点名称, value为master节点对应的实例对象的指针 */</span></span><br><span class="line">    <span class="keyword">int</span> tilt;           <span class="comment">/*  TILT模式 */</span></span><br><span class="line">    <span class="keyword">int</span> running_scripts;    </span><br><span class="line">    <span class="keyword">mstime_t</span> tilt_start_time;  </span><br><span class="line">    <span class="keyword">mstime_t</span> previous_time;         </span><br><span class="line">    <span class="built_in">list</span> *scripts_queue;           </span><br><span class="line">    <span class="keyword">char</span> *announce_ip;  </span><br><span class="line">    <span class="keyword">int</span> announce_port;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> simfailure_flags; </span><br><span class="line">    <span class="keyword">int</span> deny_scripts_reconfig; </span><br><span class="line">    <span class="keyword">char</span> *sentinel_auth_pass;    </span><br><span class="line">    <span class="keyword">char</span> *sentinel_auth_user;   </span><br><span class="line">    <span class="keyword">int</span> resolve_hostnames;       </span><br><span class="line">    <span class="keyword">int</span> announce_hostnames;      </span><br><span class="line">&#125; sentinel;</span><br></pre></td></tr></table></figure>
<p><strong>sentinelRedisInstance</strong>是一个通用的结构体，在sentinel.c文件中定义，它既可以表示主节点，也可以表示从节点或者其他哨兵实例，从中选选出了一些主要的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flags;      <span class="comment">/* 一些状态标识 */</span></span><br><span class="line">    <span class="keyword">char</span> *name;     <span class="comment">/* Master name from the point of view of this sentinel. */</span></span><br><span class="line">    <span class="keyword">char</span> *runid;    <span class="comment">/* 实例的运行ID */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> config_epoch;  <span class="comment">/* 配置的纪元. */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> s_down_since_time; <span class="comment">/* 主观下线时长 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> o_down_since_time; <span class="comment">/* 客观下线时长 */</span></span><br><span class="line">    dict *sentinels;    <span class="comment">/* 监控同一主节点的其他哨兵实例 */</span></span><br><span class="line">    dict *slaves;       <span class="comment">/* slave节点（从节点） */</span></span><br><span class="line">    <span class="comment">/* 故障切换 */</span></span><br><span class="line">    <span class="keyword">char</span> *leader;       <span class="comment">/* 如果是master节点，保存了需要执行故障切换的哨兵leader的runid,如果是一个哨兵，保存的是这个哨兵投票选举的leader*/</span></span><br><span class="line">    <span class="keyword">uint64_t</span> leader_epoch; <span class="comment">/* leader纪元 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> failover_epoch; </span><br><span class="line">    <span class="keyword">int</span> failover_state; <span class="comment">/* 故障切换状态 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125; sentinelRedisInstance;</span><br></pre></td></tr></table></figure>
<p>initSentinel函数同样在sentinel.c文件中，用于初始化哨兵，由于哨兵实例与普通Redis实例不一样，所以需要替换Redis中的命令，添加哨兵实例命令，哨兵实例使用的命令在sentinelcmds中定义：</p>
<ol>
<li>将server.commands和server.orig_commands保存的常规Redis命令清除</li>
<li>遍历sentinelcmds哨兵实例专用命令，将命令添加到server.commands和server.orig_commands中</li>
<li>初始化sentinel实例中的数据项</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哨兵实例下的命令</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">sentinelcmds</span>[] = &#123;</span></span><br><span class="line">    &#123;<span class="string">"ping"</span>,pingCommand,<span class="number">1</span>,<span class="string">"fast @connection"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"sentinel"</span>,sentinelCommand,<span class="number">-2</span>,<span class="string">"admin"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"subscribe"</span>,subscribeCommand,<span class="number">-2</span>,<span class="string">"pub-sub"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"unsubscribe"</span>,unsubscribeCommand,<span class="number">-1</span>,<span class="string">"pub-sub"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"psubscribe"</span>,psubscribeCommand,<span class="number">-2</span>,<span class="string">"pub-sub"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"punsubscribe"</span>,punsubscribeCommand,<span class="number">-1</span>,<span class="string">"pub-sub"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"publish"</span>,sentinelPublishCommand,<span class="number">3</span>,<span class="string">"pub-sub fast"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"info"</span>,sentinelInfoCommand,<span class="number">-1</span>,<span class="string">"random @dangerous"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"role"</span>,sentinelRoleCommand,<span class="number">1</span>,<span class="string">"fast read-only @dangerous"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"client"</span>,clientCommand,<span class="number">-2</span>,<span class="string">"admin random @connection"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"shutdown"</span>,shutdownCommand,<span class="number">-1</span>,<span class="string">"admin"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"auth"</span>,authCommand,<span class="number">-2</span>,<span class="string">"no-auth fast @connection"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"hello"</span>,helloCommand,<span class="number">-1</span>,<span class="string">"no-auth fast @connection"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"acl"</span>,aclCommand,<span class="number">-2</span>,<span class="string">"admin"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"command"</span>,commandCommand,<span class="number">-1</span>, <span class="string">"random @connection"</span>, <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化哨兵 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSentinel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将常规的Redis命令移除，增加哨兵实例专用的命令 */</span></span><br><span class="line">    dictEmpty(server.commands,<span class="literal">NULL</span>);</span><br><span class="line">    dictEmpty(server.orig_commands,<span class="literal">NULL</span>);</span><br><span class="line">    ACLClearCommandID();</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(sentinelcmds)/<span class="keyword">sizeof</span>(sentinelcmds[<span class="number">0</span>]); j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> retval;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span> = <span class="title">sentinelcmds</span>+<span class="title">j</span>;</span></span><br><span class="line">        cmd-&gt;id = ACLGetCommandID(cmd-&gt;name);</span><br><span class="line">        <span class="comment">// 添加到server.commands</span></span><br><span class="line">        retval = dictAdd(server.commands, sdsnew(cmd-&gt;name), cmd);</span><br><span class="line">        serverAssert(retval == DICT_OK);</span><br><span class="line">        <span class="comment">// 添加到server.orig_commands</span></span><br><span class="line">        retval = dictAdd(server.orig_commands, sdsnew(cmd-&gt;name), cmd);</span><br><span class="line">        serverAssert(retval == DICT_OK);</span><br><span class="line">        <span class="keyword">if</span> (populateCommandTableParseFlags(cmd,cmd-&gt;sflags) == C_ERR)</span><br><span class="line">            serverPanic(<span class="string">"Unsupported command flag"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化其他数据项 */</span></span><br><span class="line">    <span class="comment">// current_epoch初始化为0</span></span><br><span class="line">    sentinel.current_epoch = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 监控的master节点实例对象</span></span><br><span class="line">    sentinel.masters = dictCreate(&amp;instancesDictType,<span class="literal">NULL</span>);</span><br><span class="line">    sentinel.tilt = <span class="number">0</span>;</span><br><span class="line">    sentinel.tilt_start_time = <span class="number">0</span>;</span><br><span class="line">    sentinel.previous_time = mstime();</span><br><span class="line">    sentinel.running_scripts = <span class="number">0</span>;</span><br><span class="line">    sentinel.scripts_queue = listCreate();</span><br><span class="line">    sentinel.announce_ip = <span class="literal">NULL</span>;</span><br><span class="line">    sentinel.announce_port = <span class="number">0</span>;</span><br><span class="line">    sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;</span><br><span class="line">    sentinel.deny_scripts_reconfig = SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG;</span><br><span class="line">    sentinel.sentinel_auth_pass = <span class="literal">NULL</span>;</span><br><span class="line">    sentinel.sentinel_auth_user = <span class="literal">NULL</span>;</span><br><span class="line">    sentinel.resolve_hostnames = SENTINEL_DEFAULT_RESOLVE_HOSTNAMES;</span><br><span class="line">    sentinel.announce_hostnames = SENTINEL_DEFAULT_ANNOUNCE_HOSTNAMES;</span><br><span class="line">    <span class="built_in">memset</span>(sentinel.myid,<span class="number">0</span>,<span class="keyword">sizeof</span>(sentinel.myid));</span><br><span class="line">    server.sentinel_config = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动哨兵实例"><a href="#启动哨兵实例" class="headerlink" title="启动哨兵实例"></a>启动哨兵实例</h2><p><strong>sentinelIsRunning</strong></p>
<p>sentinelIsRunning函数在sentinel.c文件中，用于启动哨兵实例：</p>
<ol>
<li>校验是否设置了哨兵实例的ID，如果未设置，将随机生成一个ID</li>
<li>调用sentinelGenerateInitialMonitorEvents向监控的主节点发送+monitor事件</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelIsRunning</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 校验myid是否为0 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CONFIG_RUN_ID_SIZE; j++)</span><br><span class="line">        <span class="keyword">if</span> (sentinel.myid[j] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">        <span class="comment">/* 随机生成ID */</span></span><br><span class="line">        getRandomHexChars(sentinel.myid,CONFIG_RUN_ID_SIZE);</span><br><span class="line">        sentinelFlushConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Sentinel ID is %s"</span>, sentinel.myid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向监控的主节点发送+monitor事件 */</span></span><br><span class="line">    sentinelGenerateInitialMonitorEvents();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向监控的主节点发布事件 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelGenerateInitialMonitorEvents</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="comment">// 获取监控的主节点</span></span><br><span class="line">    di = dictGetIterator(sentinel.masters);</span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sentinelRedisInstance *ri = dictGetVal(de);</span><br><span class="line">        <span class="comment">// 向主节点发送监控事件</span></span><br><span class="line">        sentinelEvent(LL_WARNING,<span class="string">"+monitor"</span>,ri,<span class="string">"%@ quorum %d"</span>,ri-&gt;quorum);</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哨兵时间事件"><a href="#哨兵时间事件" class="headerlink" title="哨兵时间事件"></a>哨兵时间事件</h2><p>在initServer函数中，调用aeCreateTimeEvent注册了时间事件，周期性的执行serverCron函数，serverCron函数中通过server.sentinel_mode判断是否是哨兵模式，如果是哨兵模式，调用sentinelTimer执行哨兵事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">        serverPanic(<span class="string">"Can't create event loop timers."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serverCron</span><span class="params">(struct aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是哨兵模式，调用sentinelTimer执行哨兵事件</span></span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) sentinelTimer();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>sentinelTimer</strong></p>
<p>sentinelTimer在sentinel.c文件中，sentinelTimer函数会周期性的执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelTimer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    sentinelCheckTiltCondition();</span><br><span class="line">    <span class="comment">// 处理RedisInstances，传入的参数是当前哨兵实例维护的主节点的哈希表，里面记录当前节点监听的主节点</span></span><br><span class="line">    sentinelHandleDictOfRedisInstances(sentinel.masters);</span><br><span class="line">    sentinelRunPendingScripts();</span><br><span class="line">    sentinelCollectTerminatedScripts();</span><br><span class="line">    sentinelKillTimedoutScripts();</span><br><span class="line">    <span class="comment">// 调整sentinelTimer的执行频率</span></span><br><span class="line">    server.hz = CONFIG_DEFAULT_HZ + rand() % CONFIG_DEFAULT_HZ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>sentinelHandleDictOfRedisInstances</strong></p>
<p>sentinelHandleDictOfRedisInstances函数中会对传入的当前哨兵实例监听的主节点哈希表进行遍历：</p>
<ol>
<li>获取哈希表中的每一个节点，节点类型是sentinelRedisInstance</li>
<li><strong>调用sentinelHandleRedisInstance检测哨兵监听节点的状态</strong></li>
<li>如果sentinelHandleRedisInstance是主节点，由于主节点里面保存了监听该主节点的其他哨兵实例以及从节点，所以递归调用sentinelHandleDictOfRedisInstances对其他的节点进行检测</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sentinelHandleDictOfRedisInstances */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelHandleDictOfRedisInstances</span><span class="params">(dict *instances)</span> </span>&#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    sentinelRedisInstance *switch_to_promoted = <span class="literal">NULL</span>;</span><br><span class="line">    di = dictGetIterator(instances);</span><br><span class="line">    <span class="comment">// 遍历所有的sentinelRedisInstance实例</span></span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取每一个sentinelRedisInstance</span></span><br><span class="line">        sentinelRedisInstance *ri = dictGetVal(de);</span><br><span class="line">        <span class="comment">// 调用sentinelHandleRedisInstance检测哨兵监听节点的状态</span></span><br><span class="line">        sentinelHandleRedisInstance(ri);</span><br><span class="line">        <span class="comment">// 如果是sentinelRedisInstance是主节点，主节点里面保存了监听该主节点的其他哨兵实例以及从节点</span></span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER) &#123;</span><br><span class="line">            <span class="comment">// 递归调用，处理从节点</span></span><br><span class="line">            sentinelHandleDictOfRedisInstances(ri-&gt;slaves);</span><br><span class="line">            <span class="comment">// 递归调用，处理其他哨兵实例</span></span><br><span class="line">            sentinelHandleDictOfRedisInstances(ri-&gt;sentinels);</span><br><span class="line">            <span class="keyword">if</span> (ri-&gt;failover_state == SENTINEL_FAILOVER_STATE_UPDATE_CONFIG) &#123;</span><br><span class="line">                switch_to_promoted = ri;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (switch_to_promoted)</span><br><span class="line">        sentinelFailoverSwitchToPromotedSlave(switch_to_promoted);</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="检测哨兵监听的节点状态"><a href="#检测哨兵监听的节点状态" class="headerlink" title="检测哨兵监听的节点状态"></a>检测哨兵监听的节点状态</h3><p><strong>sentinelHandleRedisInstance</strong></p>
<p>sentinelHandleRedisInstance函数对传入的sentinelRedisInstance实例，进行状态检测，主要处理逻辑如下：</p>
<ol>
<li>调用sentinelReconnectInstance对实例的连接状态进行判断，如果<strong>连接中断尝试重新与实例建立连接 </strong></li>
<li>调用sentinelSendPeriodicCommands<strong>向实例发送PING INFO等命令</strong></li>
<li>sentinelCheckSubjectivelyDown判断<strong>实例是否主观下线</strong></li>
<li>如果实例是master节点，调用sentinelCheckObjectivelyDown判断<strong>是否客观下线、是否需要执行故障切换</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Perform scheduled operations for the specified Redis instance. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelHandleRedisInstance</span><span class="params">(sentinelRedisInstance *ri)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果监听的节点连接中断，尝试重新建立连接 </span></span><br><span class="line">    sentinelReconnectInstance(ri);</span><br><span class="line">    <span class="comment">// 发送PING INFO等命令</span></span><br><span class="line">    sentinelSendPeriodicCommands(ri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否是TILT模式</span></span><br><span class="line">    <span class="keyword">if</span> (sentinel.tilt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mstime()-sentinel.tilt_start_time &lt; SENTINEL_TILT_PERIOD) <span class="keyword">return</span>;</span><br><span class="line">        sentinel.tilt = <span class="number">0</span>;</span><br><span class="line">        sentinelEvent(LL_WARNING,<span class="string">"-tilt"</span>,<span class="literal">NULL</span>,<span class="string">"#tilt mode exited"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断主观下线</span></span><br><span class="line">    sentinelCheckSubjectivelyDown(ri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Masters and slaves */</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是master节点</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER) &#123;</span><br><span class="line">        <span class="comment">// 判断客观下线</span></span><br><span class="line">        sentinelCheckObjectivelyDown(ri);</span><br><span class="line">        <span class="comment">// 是否需要启动故障切换</span></span><br><span class="line">        <span class="keyword">if</span> (sentinelStartFailoverIfNeeded(ri))</span><br><span class="line">            sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);</span><br><span class="line">        <span class="comment">// 执行故障切换</span></span><br><span class="line">        sentinelFailoverStateMachine(ri);</span><br><span class="line">        <span class="comment">// 获取其他哨兵实例对master节点状态的判断</span></span><br><span class="line">        sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重新连接"><a href="#重新连接" class="headerlink" title="重新连接"></a>重新连接</h4><p><strong>sentinelReconnectInstance</strong></p>
<p>sentinelReconnectInstance函数用于检测实例的连接状态，如果中断进行重连，主要处理逻辑如下：</p>
<ol>
<li><p>检测连接是否中断，如果未中断直接返回</p>
</li>
<li><p>检查端口是否为0,0被认为是不合法的端口</p>
</li>
<li><p>从sentinelRedisInstance实例中获取instanceLink，instanceLink的定义在sentinel.c文件中，<strong>里面记录了哨兵和主节点的两个连接，分别为用于发送命令的连接cc和用于发送Pub/Sub消息的连接pc</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">instanceLink</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> refcount;         </span><br><span class="line">    <span class="keyword">int</span> disconnected;      </span><br><span class="line">    <span class="keyword">int</span> pending_commands;  </span><br><span class="line">    redisAsyncContext *cc; <span class="comment">/* 用于发送命令的连接 */</span></span><br><span class="line">    redisAsyncContext *pc; <span class="comment">/* 用于发送Pub/Sub消息的连接 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> cc_conn_time; <span class="comment">/* cc 连接时间 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> pc_conn_time; <span class="comment">/* pc 连接时间 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> pc_last_activity; </span><br><span class="line">    <span class="keyword">mstime_t</span> last_avail_time; <span class="comment">/* 上一次收到实例回复PING命令（需要被认定为合法）的时间 */</span>  </span><br><span class="line">    <span class="keyword">mstime_t</span> act_ping_time; <span class="comment">/* 当收到PONG消息的时候会设置为0，在下次发送PING命令时设置为当前时间 */</span>  </span><br><span class="line">    <span class="keyword">mstime_t</span> last_ping_time;  <span class="comment">/* 上次发送PING命令时间，在出现故障时可以通过判断发送时间避免多次发送PING命令 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> last_pong_time;  <span class="comment">/* 上次收到PONG消息的时间 */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> last_reconn_time;  <span class="comment">/* 上次执行重连的时间 */</span></span><br><span class="line">&#125; instanceLink;</span><br></pre></td></tr></table></figure>
</li>
<li><p>校验距离上次重连时间是否小于PING的检测周期SENTINEL_PING_PERIOD，如果小于说明距离上次重连时间过近，直接返回即可</p>
<p>SENTINEL_PING_PERIOD在server.c中定义，默认1000毫秒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SENTINEL_PING_PERIOD 1000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对用于发送命令的连接判断，如果连接为NULL，调用redisAsyncConnectBind函数进行重连</p>
</li>
<li><p>对用于处理发送 Pub/Sub 消息的连接进行判断，如果连接为NULL，调用redisAsyncConnectBind函数进行重连</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelReconnectInstance</span><span class="params">(sentinelRedisInstance *ri)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查连接是否中断</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;addr-&gt;port == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">/* 检查端口是否为0,0被认为是不合法的端口 */</span></span><br><span class="line">    <span class="comment">// 获取instanceLink</span></span><br><span class="line">    instanceLink *link = ri-&gt;link;</span><br><span class="line">    <span class="keyword">mstime_t</span> now = mstime();</span><br><span class="line">    <span class="comment">// 校验距离上次重连时间是否小于哨兵PING的周期设置</span></span><br><span class="line">    <span class="keyword">if</span> (now - ri-&gt;link-&gt;last_reconn_time &lt; SENTINEL_PING_PERIOD) <span class="keyword">return</span>;</span><br><span class="line">    ri-&gt;link-&gt;last_reconn_time = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 处理用于发送命令的连接 */</span></span><br><span class="line">    <span class="keyword">if</span> (link-&gt;cc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 进行连接</span></span><br><span class="line">        link-&gt;cc = redisAsyncConnectBind(ri-&gt;addr-&gt;ip,ri-&gt;addr-&gt;port,NET_FIRST_BIND_ADDR);</span><br><span class="line">        <span class="keyword">if</span> (link-&gt;cc &amp;&amp; !link-&gt;cc-&gt;err) anetCloexec(link-&gt;cc-&gt;c.fd);</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理用于发送 Pub/Sub 消息的连接 */</span></span><br><span class="line">    <span class="keyword">if</span> ((ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) &amp;&amp; link-&gt;pc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        link-&gt;pc = redisAsyncConnectBind(ri-&gt;addr-&gt;ip,ri-&gt;addr-&gt;port,NET_FIRST_BIND_ADDR);</span><br><span class="line">        <span class="keyword">if</span> (link-&gt;pc &amp;&amp; !link-&gt;pc-&gt;err) anetCloexec(link-&gt;pc-&gt;c.fd);</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;cc &amp;&amp; (ri-&gt;flags &amp; SRI_SENTINEL || link-&gt;pc))</span><br><span class="line">        link-&gt;disconnected = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发送命令"><a href="#发送命令" class="headerlink" title="发送命令"></a>发送命令</h4><p><strong>sentinelSendPeriodicCommands</strong></p>
<p>sentinelSendPeriodicCommands用于向实例发送命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelSendPeriodicCommands</span><span class="params">(sentinelRedisInstance *ri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> now = mstime();</span><br><span class="line">    <span class="keyword">mstime_t</span> info_period, ping_period;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 向主节点和从节点发送INFO命令 */</span></span><br><span class="line">    <span class="keyword">if</span> ((ri-&gt;flags &amp; SRI_SENTINEL) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (ri-&gt;info_refresh == <span class="number">0</span> ||</span><br><span class="line">        (now - ri-&gt;info_refresh) &gt; info_period))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送INFO命令</span></span><br><span class="line">        retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">            sentinelInfoReplyCallback, ri, <span class="string">"%s"</span>,</span><br><span class="line">            sentinelInstanceMapCommand(ri,<span class="string">"INFO"</span>));</span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((now - ri-&gt;link-&gt;last_pong_time) &gt; ping_period &amp;&amp;</span><br><span class="line">               (now - ri-&gt;link-&gt;last_ping_time) &gt; ping_period/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 向实例发送PING命令</span></span><br><span class="line">        sentinelSendPing(ri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PUBLISH hello messages to all the three kinds of instances. */</span></span><br><span class="line">    <span class="keyword">if</span> ((now - ri-&gt;last_pub_time) &gt; SENTINEL_PUBLISH_PERIOD) &#123;</span><br><span class="line">        <span class="comment">// 发送PUBLISH命令</span></span><br><span class="line">        sentinelSendHello(ri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h4><p><strong>sentinelCheckSubjectivelyDown</strong></p>
<p>sentinelCheckSubjectivelyDown函数用于判断是否主观下线。</p>
<p><strong>标记主观下线的两个条件</strong></p>
<ul>
<li><strong>距离上次发送PING命令的时长超过了down_after_period的值</strong>，down_after_period的值在sentinel.conf 配置文件中配置，对应的配置项为down-after-milliseconds ，默认值30s</li>
<li>哨兵认为实例是主节点（ri-&gt;flags &amp; SRI_MASTE），但是实例向哨兵返回的角色是从节点（ri-&gt;role_reported == SRI_SLAVE） 并且当前时间-实例报告消息的时间role_reported_time大于down_after_period加上SENTINEL_INFO_PERIOD乘以2的时间 ，SENTINEL_INFO_PERIOD 是发送INFO命令的时间间隔，也就是说<strong>实例上次成功向哨兵报告角色的时间，已经超过了限定时间（down_after_period加上SENTINEL_INFO_PERIOD*2）</strong></li>
</ul>
<p><strong>满足以上两个条件之一哨兵将会把sentinelRedisInstance判断为主观下线，flag标记会添加SRI_S_DOWN状态。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelCheckSubjectivelyDown</span><span class="params">(sentinelRedisInstance *ri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> elapsed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果act_ping_time不为0</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;act_ping_time)</span><br><span class="line">        elapsed = mstime() - ri-&gt;link-&gt;act_ping_time; <span class="comment">// 计算距离上次发送PING命令的间隔时间</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected) <span class="comment">// 如果连接断开</span></span><br><span class="line">        elapsed = mstime() - ri-&gt;link-&gt;last_avail_time; <span class="comment">// 计算距离最近一次收到PING命令回复的间隔时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;cc &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;cc_conn_time) &gt;</span><br><span class="line">        SENTINEL_MIN_LINK_RECONNECT_PERIOD &amp;&amp;</span><br><span class="line">        ri-&gt;link-&gt;act_ping_time != <span class="number">0</span> &amp;&amp; </span><br><span class="line">        (mstime() - ri-&gt;link-&gt;act_ping_time) &gt; (ri-&gt;down_after_period/<span class="number">2</span>) &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;last_pong_time) &gt; (ri-&gt;down_after_period/<span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;cc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;pc &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;pc_conn_time) &gt;</span><br><span class="line">         SENTINEL_MIN_LINK_RECONNECT_PERIOD &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;pc_last_activity) &gt; (SENTINEL_PUBLISH_PERIOD*<span class="number">3</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;pc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 标记主观下线的两个条件（或的关系）</span></span><br><span class="line"><span class="comment">     * 1) 距离上次发送PING命令的时长超过了down_after_period</span></span><br><span class="line"><span class="comment">     * 2) 哨兵认为实例是主节点（ri-&gt;flags &amp; SRI_MASTE），但是实例向哨兵返回的角色是从节点（ri-&gt;role_reported == SRI_SLAVE） 并且当前时间-实例返回消息的时间大于down_after_period加上SENTINEL_INFO_PERIOD*2的时间 */</span></span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt; ri-&gt;down_after_period ||</span><br><span class="line">        (ri-&gt;flags &amp; SRI_MASTER &amp;&amp;</span><br><span class="line">         ri-&gt;role_reported == SRI_SLAVE &amp;&amp;</span><br><span class="line">         mstime() - ri-&gt;role_reported_time &gt;</span><br><span class="line">          (ri-&gt;down_after_period+SENTINEL_INFO_PERIOD*<span class="number">2</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 主观下线 */</span></span><br><span class="line">        <span class="keyword">if</span> ((ri-&gt;flags &amp; SRI_S_DOWN) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 发送+sdown事件</span></span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">"+sdown"</span>,ri,<span class="string">"%@"</span>);</span><br><span class="line">            ri-&gt;s_down_since_time = mstime();</span><br><span class="line">            ri-&gt;flags |= SRI_S_DOWN; <span class="comment">// 更改状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Is subjectively up */</span></span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_S_DOWN) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">"-sdown"</span>,ri,<span class="string">"%@"</span>);</span><br><span class="line">            ri-&gt;flags &amp;= ~(SRI_S_DOWN|SRI_SCRIPT_KILL_SENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h4><p>如果是主节点，将会调用sentinelCheckObjectivelyDown函数判断客观下线，之后调用sentinelStartFailoverIfNeeded判断是否需要执行故障切换。</p>
<p><strong>总结</strong></p>
<p><a href="/images/主观下线总结.png"></a></p>
<p><strong>参考</strong></p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/30/【Redis】事件驱动框架（多线程）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/30/【Redis】事件驱动框架（多线程）/" itemprop="url">【Redis】事件驱动源码分析（多线程）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-30T11:00:00+08:00">
                2022-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="IO线程初始化"><a href="#IO线程初始化" class="headerlink" title="IO线程初始化"></a>IO线程初始化</h2><p>Redis在6.0版本中引入了多线程，提高IO请求处理效率。</p>
<p>在Redis Server启动函数main（server.c文件）中初始化服务之后，又调用了InitServerLast函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 初始化服务</span></span><br><span class="line">    initServer();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// InitServerLast</span></span><br><span class="line">    InitServerLast();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 事件循环</span></span><br><span class="line">    aeMain(server.el);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>InitServerLast函数在server.c文件中，它调用了initThreadedIO函数对IO线程初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitServerLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bioInit();</span><br><span class="line">    <span class="comment">// 初始化IO线程</span></span><br><span class="line">    initThreadedIO();</span><br><span class="line">    set_jemalloc_bg_thread(server.jemalloc_bg_thread);</span><br><span class="line">    server.initial_memory_usage = zmalloc_used_memory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>initThreadedIO</strong></p>
<p>initThreadedIO的实现在networking.c文件中：</p>
<ol>
<li>初始化全局变量 server.io_threads_active线程活跃状态为0，表示未激活IO多线程</li>
<li>对server.io_threads_num的值进行判断，io_threads_num表示设置的IO线程数量<ul>
<li>如果线程数设置为1，表示不开启多线程直接返回即可</li>
<li>如果线程数超过了IO_THREADS_MAX_NUM设置的最大值（128），则报错并停止redis服务</li>
</ul>
</li>
<li>根据线程数的设置创建线程<ul>
<li>初始化io_threads_list[i]，<strong>io_threads_list是一个数组，数组中的每一个元素是一个list，里面存储每个线程要处理的客户端列表</strong>，<strong>下标为0的元素也就是io_threads_lis[0]存储的是主线程要处理的客户端列表</strong>，这里先调用listCreate创建列表，为io_threads_list[i]初始化</li>
<li>初始化io_threads_pending[i]为0，<strong>io_threads_pending数组存储每个线程等待处理的客户端个数</strong></li>
<li>调用pthread_create创建线程，并传入了<strong>线程的运行函数IOThreadMain</strong>，之后将线程保存在io_threads中，<strong>io_threads数组存储了创建的线程描述符</strong></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    server.io_threads_active = <span class="number">0</span>; <span class="comment">/* 初始化线程活跃状态为0，表示未激活IO多线程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果IO线程数为1，直接返回即可 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 如果IO线程数超过了最大限制，打印错误，停止redis服务 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num &gt; IO_THREADS_MAX_NUM) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Fatal: too many I/O threads configured. "</span></span><br><span class="line">                             <span class="string">"The maximum number is %d."</span>, IO_THREADS_MAX_NUM);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据线程数设置创建线程 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; server.io_threads_num; i++) &#123;</span><br><span class="line">        <span class="comment">/* 创建List */</span></span><br><span class="line">        io_threads_list[i] = listCreate();</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">/* 下标为0的存储的是主线程 */</span></span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        pthread_mutex_init(&amp;io_threads_mutex[i],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 初始化待处理的客户端数量为0</span></span><br><span class="line">        setIOPendingCount(i, <span class="number">0</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[i]); <span class="comment">/* Thread will be stopped. */</span></span><br><span class="line">        <span class="comment">// 创建线程, 线程的运行函数为IOThreadMain</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;tid,<span class="literal">NULL</span>,IOThreadMain,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)i) != <span class="number">0</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Fatal: Can't initialize IO thread."</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将创建的线程加入io_threads线程组中*/</span></span><br><span class="line">        io_threads[i] = tid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setIOPendingCount在networking.c文件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setIOPendingCount</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置io_threads_pending[i]的值为count</span></span><br><span class="line">    atomicSetWithSync(io_threads_pending[i], count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>io_threads_list</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* io_threads_list存储每个线程要处理的客户端 */</span></span><br><span class="line"><span class="built_in">list</span> *io_threads_list[IO_THREADS_MAX_NUM];</span><br></pre></td></tr></table></figure>
<p><strong>io_threads</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存储创建的线程*/</span></span><br><span class="line"><span class="keyword">pthread_t</span> io_threads[IO_THREADS_MAX_NUM];</span><br></pre></td></tr></table></figure>
<p><strong>io_threads_pending</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存储每个线程要等待处理的客户端个数 */</span></span><br><span class="line">redisAtomic <span class="keyword">unsigned</span> <span class="keyword">long</span> io_threads_pending[IO_THREADS_MAX_NUM];</span><br></pre></td></tr></table></figure>
<p><strong>IO_THREADS_MAX_NUM定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_THREADS_MAX_NUM 128</span></span><br></pre></td></tr></table></figure>
<p><strong>初始化流程图</strong></p>
<p><img src="/images/redisio线程初始化.jpg" alt=""></p>
<h3 id="IO线程运行函数"><a href="#IO线程运行函数" class="headerlink" title="IO线程运行函数"></a>IO线程运行函数</h3><p>IO线程运行函数IOThreadMain在networking.c文件中，函数的入参传入的是线程id，它开启了一个while(1)循环，主要处理逻辑如下：</p>
<ol>
<li>从io_threads_list数组中获取当前线程id要处理的客户端列表，放入到列表迭代器li中</li>
<li>遍历迭代器，获取每一个待处理的客户端client，根据io_threads_op线程的操作状态判断读写状态<ul>
<li>如果是写状态，调用调用writeToClient处理</li>
<li>如果是读状态，调用readQueryFromClient处理</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">IOThreadMain</span><span class="params">(<span class="keyword">void</span> *myid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* myid是线程ID，从0开始，到 server.iothreads_num-1，0号线程存储的是主线程 */</span></span><br><span class="line">    <span class="keyword">long</span> id = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)myid;</span><br><span class="line">    <span class="keyword">char</span> thdname[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(thdname, <span class="keyword">sizeof</span>(thdname), <span class="string">"io_thd_%ld"</span>, id);</span><br><span class="line">    redis_set_thread_title(thdname);</span><br><span class="line">    redisSetCpuAffinity(server.server_cpulist);</span><br><span class="line">    makeThreadKillable();</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getIOPendingCount(id) != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Give the main thread a chance to stop this thread. */</span></span><br><span class="line">        <span class="keyword">if</span> (getIOPendingCount(id) == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;io_threads_mutex[id]);</span><br><span class="line">            pthread_mutex_unlock(&amp;io_threads_mutex[id]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        serverAssert(getIOPendingCount(id) != <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        listIter li;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        <span class="comment">// 获取每一个IO线程要处理的客户端，将其放入到迭代器li，这里的id指的线程id</span></span><br><span class="line">        listRewind(io_threads_list[id],&amp;li);</span><br><span class="line">        <span class="comment">// 遍历列表</span></span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            <span class="comment">// 获取每一个待处理的客户端</span></span><br><span class="line">            client *c = listNodeValue(ln);</span><br><span class="line">            <span class="comment">// 如果是写事件</span></span><br><span class="line">            <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                <span class="comment">// 调用writeToClient处理</span></span><br><span class="line">                writeToClient(c,<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_READ) &#123;</span><br><span class="line">                <span class="comment">// 如果是读事件，调用readQueryFromClient</span></span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverPanic(<span class="string">"io_threads_op value is unknown"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        listEmpty(io_threads_list[id]);</span><br><span class="line">        <span class="comment">// 处理完毕后，io_threads_pending数组中对应的数量设置为0，表示所有客户端已处理完毕</span></span><br><span class="line">        setIOPendingCount(id, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>io_threads_list数组中存储了每一个线程要处理的客户端列表，在线程运行函数IOThreadMain中，获取待处理的客户端列表，遍历每一个客户端，根据读写类型调用不同的方法进行处理，接下来就去看下Redis在何时将待处理的客户端加入到io_threads_list列表中的。</p>
<h2 id="延迟读写操作"><a href="#延迟读写操作" class="headerlink" title="延迟读写操作"></a>延迟读写操作</h2><p>Redis在处理客户端读事件和写事件时会根据一定条件推迟客户端的读取操作或者往客户端写数据操作，将待处理的读客户端和待处理的写客户端分别加入到全局变量server的clients_pending_read和clients_pending_write列表中，全局变量server对应的结构体为redisServer：</p>
<p>全局变量server定义，在server.c文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 全局变量server */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span></span><br></pre></td></tr></table></figure>
<p>redisServer的结构体定义在server.h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span> *clients_pending_write; <span class="comment">/* list类型，记录延迟写回数据的客户端 */</span></span><br><span class="line">    <span class="built_in">list</span> *clients_pending_read;  <span class="comment">/* list类型，记录延迟读取数据的客户端*/</span></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="推迟客户端读操作"><a href="#推迟客户端读操作" class="headerlink" title="推迟客户端读操作"></a>推迟客户端读操作</h3><p><strong>readQueryFromClient</strong></p>
<p>readQueryFromClient主要处理从客户端读取数据，在networking.c中实现，里面调用了postponeClientRead函数判断是否需要推迟客户端的读取操作 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    client *c = connGetPrivateData(conn);</span><br><span class="line">    <span class="keyword">int</span> nread, readlen;</span><br><span class="line">    <span class="keyword">size_t</span> qblen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断是否需要推迟客户端的读取操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (postponeClientRead(c)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 处理数据执行命令</span></span><br><span class="line">    processInputBuffer(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>postponeClientRead</strong></p>
<p>postponeClientRead函数用于判断是否延迟从客户端读取数据，包含四个条件：</p>
<ol>
<li>server.io_threads_active为1，表示激活了IO多线程</li>
<li>server.io_threads_do_reads为1，表示IO多线程可以延迟执行客户端的读取操作，在配置文件中定义，可以通过修改配置文件来开启延迟读取客户端数据</li>
<li>ProcessingEventsWhileBlocked值为0，processEventsWhileBlokced函数在执行时会将ProcessingEventsWhileBlocked的值置为1，执行完毕后置为0，Redis在读取RDB或者AOF文件时会调用processEventsWhileBlokced函数，<strong>为了避免读取RDB或AOF文件时阻塞无法及时处理请求，processEventsWhileBlokced函数在执行时不能推迟客户端数据读取。</strong></li>
<li>客户端的现有标识不能有CLIENT_MASTER、CLIENT_SLAVE、CLIENT_PENDING_READ、CLIENT_BLOCKED等状态<ul>
<li>CLIENT_MASTER、CLIENT_SLAVE表示是用于主从复制的客户端</li>
<li>CLIENT_PENDING_READ表示客户端本身已经是推迟读取状态</li>
<li>CLIENT_BLOCKED表示客户端是阻塞状态</li>
</ul>
</li>
</ol>
<p><strong>满足以上四个条件时将推迟从客户端读取数据，会将客户端标识置为CLIENT_PENDING_READ延迟读状态，并将待读取数据的客户端client加入到server.clients_pending_read中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">postponeClientRead</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_active &amp;&amp;</span><br><span class="line">        server.io_threads_do_reads &amp;&amp;</span><br><span class="line">        !ProcessingEventsWhileBlocked &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ|CLIENT_BLOCKED))) </span><br><span class="line">    &#123;</span><br><span class="line">        c-&gt;flags |= CLIENT_PENDING_READ;</span><br><span class="line">        <span class="comment">// 将客户端加入到clients_pending_read链表中</span></span><br><span class="line">        listAddNodeHead(server.clients_pending_read,c);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="推迟客户端写操作"><a href="#推迟客户端写操作" class="headerlink" title="推迟客户端写操作"></a>推迟客户端写操作</h3><p>在往客户端写数据的addReply（networking.c）函数中，调用了prepareClientToWrite判断是否准备往客户端写数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addReply</span><span class="params">(client *c, robj *obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用prepareClientToWrite往客户端写数据</span></span><br><span class="line">    <span class="keyword">if</span> (prepareClientToWrite(c) != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(obj)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != C_OK)</span><br><span class="line">            _addReplyProtoToList(c,obj-&gt;ptr,sdslen(obj-&gt;ptr));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">size_t</span> len = ll2string(buf,<span class="keyword">sizeof</span>(buf),(<span class="keyword">long</span>)obj-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,buf,len) != C_OK)</span><br><span class="line">            _addReplyProtoToList(c,buf,len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Wrong obj-&gt;encoding in addReply()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>prepareClientToWrite</strong></p>
<p>prepareClientToWrite（networking.c）中，首先对客户端标识状态进行了一系列的判断，然后调用了clientHasPendingReplies函数判断输出缓冲区是否有还有数据等待写回到客户端，如果没有，判断客户端的标识是否是CLIENT_PENDING_READ已延迟读，如果不是CLIENT_PENDING_READ状态，调用clientInstallWriteHandler处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prepareClientToWrite</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_LUA|CLIENT_MODULE)) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER_FORCE_REPLY)) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c-&gt;conn) <span class="keyword">return</span> C_ERR; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 如果缓冲区的数据都已写回到客户端并且客户端标识不是推迟读状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!clientHasPendingReplies(c) &amp;&amp; !(c-&gt;flags &amp; CLIENT_PENDING_READ))</span><br><span class="line">            clientInstallWriteHandler(c);<span class="comment">// 调用clientInstallWriteHandler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>clientInstallWriteHandler</strong></p>
<p>clientInstallWriteHandler（networking.c）函数中<strong>对是否推迟客户端写操作进行了判断</strong>：</p>
<ol>
<li>客户端标识不是CLIENT_PENDING_WRITE，对应条件为!(c-&gt;flags &amp; CLIENT_PENDING_WRITE)，表示客户端本身不是推迟写状态</li>
<li>客户端未在进行主从复制（对应条件为c-&gt;replstate == REPL_STATE_NONE） 或者 客户端是主从复制的从节点，但全量复制的 RDB 文件已经传输完成，客户端可以接收请求（对应条件 !c-&gt;repl_put_online_on_ack)）</li>
</ol>
<p><strong>满足以上两个条件时将推迟客户端写操作，将客户端的标识置为延迟写CLIENT_PENDING_WRITE状态，并将客户端加入到待写回的列表server.clients_pending_write中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientInstallWriteHandler</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 如果客户端的标识不是推迟写状态，并且客户端未在进行主从复制或者客户端是主从复制的从节点并能接收请求 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_PENDING_WRITE) &amp;&amp;</span><br><span class="line">        (c-&gt;replstate == REPL_STATE_NONE ||</span><br><span class="line">         (c-&gt;replstate == SLAVE_STATE_ONLINE &amp;&amp; !c-&gt;repl_put_online_on_ack)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 将客户端的标识置为延迟写 */</span></span><br><span class="line">        c-&gt;flags |= CLIENT_PENDING_WRITE;</span><br><span class="line">        <span class="comment">// 将客户端加入到待写回的列表clients_pending_write中</span></span><br><span class="line">        listAddNodeHead(server.clients_pending_write,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO线程的分配"><a href="#IO线程的分配" class="headerlink" title="IO线程的分配"></a>IO线程的分配</h2><p>上面我们已经知道了IO线程的初始化、IO线程的运行函数IOThreadMain主要处理逻辑，以及延迟读写的客户端是何时分别加入到server全局变量的clients_pending_read和clients_pending_write中的，接下来去看下时何时为客户端分配线程。</p>
<p>在aeProcessEvents处理事件的函数中，等待事件产生之前，调用了beforeSleep（networking.c）方法，beforeSleep中又调用了<strong>handleClientsWithPendingReadsUsingThreads为延迟读取操作的客户端分配线程</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    UNUSED(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">    handleBlockedClientsTimeout();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用了handleClientsWithPendingReadsUsingThreads为延迟读客户端分配线程 */</span></span><br><span class="line">    handleClientsWithPendingReadsUsingThreads();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 调用了handleClientsWithPendingWritesUsingThreads为延迟写客户端分配线程 */</span></span><br><span class="line">    handleClientsWithPendingWritesUsingThreads();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="延迟读操作的客户端分配线程"><a href="#延迟读操作的客户端分配线程" class="headerlink" title="延迟读操作的客户端分配线程"></a>延迟读操作的客户端分配线程</h3><p><strong>handleClientsWithPendingReadsUsingThreads</strong></p>
<p>handleClientsWithPendingReadsUsingThreads（networking.c）主要逻辑如下：</p>
<ol>
<li><p>从server.clients_pending_read获取延迟读取操作的客户端，将其加入到迭代列表</p>
</li>
<li><p>遍历延迟读操作的客户端列表，获取每一个待处理的客户端client，item_id表示每个客户端的序号，从0开始，每处理一个客户端就增1，用序号对线程数server.io_threads_num取模，得到一个target_id，客户端会被加入到io_threads_list[target_id]对应的列表中，<strong>也就是使用取模的方式轮询为每一个客户端分配对应线程，然后将客户端加入到该线程待处理的客户端列表中，此时客户端已分配到线程，在线程的运行函数IOThreadMain会调用readQueryFromClient处理客户端数据，需要注意多线程只是从客户端数据读取数据解析命令，并不会执行命令</strong>,在processInputBuffer中可以看到在IO多线程下只会将flags状态标记为CLIENT_PENDING_COMMAND，不会执行processCommandAndResetClient函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">processInputBuffer</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(c-&gt;qb_pos &lt; sdslen(c-&gt;querybuf)) &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">0</span>) &#123;</span><br><span class="line">            resetClient(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 在IO多线程情况下不能在这里执行命令，所以在这里将client标记为CLIENT_PENDING_COMMAND然后返回，等待主线程同步执行命令 */</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PENDING_READ) &#123;</span><br><span class="line">                c-&gt;flags |= CLIENT_PENDING_COMMAND;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 准备执行命令 */</span></span><br><span class="line">            <span class="keyword">if</span> (processCommandAndResetClient(c) == C_ERR) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将io_threads_op线程操作状态置为读操作</p>
</li>
<li><p>遍历线程数，获取每一个线程要处理的客户端个数，将其设置到线程对应的io_threads_pending[j]中，<strong>io_threads_pending数组中记录了每个线程等待处理的客户端个数</strong></p>
</li>
<li><p>获取io_threads_list[0]中待处理的客户端列表，io_threads_list[0]存储的是主线程的数据，<strong>因为当前执行handleClientsWithPendingReadsUsingThreads函数的线程正是主线程，所以让主线程来处理io_threads_list[0]中存放的待处理客户端</strong></p>
</li>
<li><p>主线程遍历io_threads_list[0]中每一个待处理的客户端，调用readQueryFromClient处理，从客户端读取数据</p>
</li>
<li><p>主线程开启一个while(1)循环等待其他IO线程处理完毕，结束条件是pending为0，pending记录了所有线程要处理的客户端数量总和，<strong>在前面IOThreadMain函数中可以看到线程在处理完毕之后会将对应io_threads_pending数组中记录的个数置为0，当pending为0表示所有的线程都已将各自复制的客户端数据处理完毕</strong></p>
</li>
<li><p>主线程开启while循环<strong>准备执行客户端命令（注意这里才开始执行命令，多线程只负责解析不负责执行）</strong>，循环条件是server.clients_pending_read列表的长度不为0，主线程需要保证客户端的请求顺序，所从clients_pending_read列表中的第一个元素开始向后遍历：</p>
<p>（1）调用listNodeValue获取列表中的元素，也就是待处理的客户端client</p>
<p>（2）调用listDelNode将获取到的元素从列表删除，因为在第7步中，<strong>主线程已经等待其他所有的线程执行完毕，此时所有的线程已经将各自负责的客户端数据处理完成</strong>，所以可以将客户端从server.clients_pending_read中移除</p>
<p>（3）<strong>调用processPendingCommandsAndResetClient函数判断客户端标识是否是CLIENT_PENDING_COMMAND状态，CLIENT_PENDING_COMMAND状态表示客户端的请求命令已经被IO线程解析（processInputBuffer方法中可以看到状态被标记为CLIENT_PENDING_COMMAND），可以开始执行命令，接着调用processCommandAndResetClient函数执行客户端发送的请求命令</strong></p>
<p>（4）<strong>由于客户端输入缓冲区可能有其他的命令未读取，这里调用processInputBuffer处理输入缓冲区数据继续解析命令并执行</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWithPendingReadsUsingThreads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!server.io_threads_active || !server.io_threads_do_reads) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> processed = listLength(server.clients_pending_read);</span><br><span class="line">    <span class="keyword">if</span> (processed == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="comment">// 获取待读取的客户端列表clients_pending_read加入到迭代链表中</span></span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    <span class="keyword">int</span> item_id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历待读取的客户端</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        <span class="comment">// 获取客户端</span></span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="comment">// 根据线程数取模，轮询分配线程</span></span><br><span class="line">        <span class="keyword">int</span> target_id = item_id % server.io_threads_num;</span><br><span class="line">        <span class="comment">// 分配线程，加入到线程对应的io_threads_list</span></span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将线程的操作状态置为读操作*/</span></span><br><span class="line">    io_threads_op = IO_THREADS_OP_READ;</span><br><span class="line">    <span class="comment">// 遍历线程数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++) &#123;</span><br><span class="line">        <span class="comment">// 获取每个线程待处理客户端的个数</span></span><br><span class="line">        <span class="keyword">int</span> count = listLength(io_threads_list[j]);</span><br><span class="line">        <span class="comment">// 将待处理客户端的个数设置到线程对应的io_threads_pending[j]中，io_threads_pending数组中记录了每个线程要处理的客户端个数</span></span><br><span class="line">        setIOPendingCount(j, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取io_threads_list[0]中待处理的客户端列表，io_threads_list[0]存储的是主线程的数据*/</span></span><br><span class="line">     <span class="comment">/* handleClientsWithPendingReadsUsingThreads函数的执行者刚好就是主线程，所以让主线程处理io_threads_list[0]中的数据*/</span></span><br><span class="line">    listRewind(io_threads_list[<span class="number">0</span>],&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="comment">// 调用readQueryFromClient</span></span><br><span class="line">        readQueryFromClient(c-&gt;conn);</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(io_threads_list[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待其他线程处理完毕 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pending = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">            <span class="comment">// 获取每一个客户端处理的客户端个数</span></span><br><span class="line">            pending += getIOPendingCount(j);</span><br><span class="line">        <span class="comment">// 如果为0表示所有线程对应的客户端都处理完毕</span></span><br><span class="line">        <span class="keyword">if</span> (pending == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再次判断server.clients_pending_read是否有待处理的客户端*/</span></span><br><span class="line">    <span class="keyword">while</span>(listLength(server.clients_pending_read)) &#123;</span><br><span class="line">        <span class="comment">// 获取列表第一个元素</span></span><br><span class="line">        ln = listFirst(server.clients_pending_read);</span><br><span class="line">        <span class="comment">// 获取客户端</span></span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_READ;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        listDelNode(server.clients_pending_read,ln);</span><br><span class="line"></span><br><span class="line">        serverAssert(!(c-&gt;flags &amp; CLIENT_BLOCKED));</span><br><span class="line">        <span class="comment">// processPendingCommandsAndResetClient函数中会判断客户端标识是否是CLIENT_PENDING_COMMAND状态，如果是调用processCommandAndResetClient函数处理请求命令</span></span><br><span class="line">        <span class="keyword">if</span> (processPendingCommandsAndResetClient(c) == C_ERR) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于客户端输入缓冲区可能有其他的命令未读取，这里解析命令并执行</span></span><br><span class="line">        processInputBuffer(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_PENDING_WRITE) &amp;&amp; clientHasPendingReplies(c))</span><br><span class="line">            clientInstallWriteHandler(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update processed count on server */</span></span><br><span class="line">    server.stat_io_reads_processed += processed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>processPendingCommandsAndResetClient</strong></p>
<p>processPendingCommandsAndResetClient函数在networking.c中，它先判断客户端标识是否是CLIENT_PENDING_COMMAND状态，CLIENT_PENDING_COMMAND状态表示客户端的请求命令已经被IO线程解析，可以被执行，所以如果处于CLIENT_PENDING_COMMAND状态，接下来会调用processCommandAndResetClient函数处理客户端命令，具体是调用processCommand函数执行命令的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*processPendingCommandsAndResetClient函数（networking.c中） */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processPendingCommandsAndResetClient</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断客户端标识是否是CLIENT_PENDING_COMMAND</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PENDING_COMMAND) &#123;</span><br><span class="line">        <span class="comment">// 取消CLIENT_PENDING_COMMAND状态</span></span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_COMMAND;</span><br><span class="line">        <span class="comment">// 调用processCommandAndResetClient执行命令</span></span><br><span class="line">        <span class="keyword">if</span> (processCommandAndResetClient(c) == C_ERR) &#123;</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* processCommandAndResetClient函数（networking.c中） */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommandAndResetClient</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> deadclient = <span class="number">0</span>;</span><br><span class="line">    client *old_client = server.current_client;</span><br><span class="line">    server.current_client = c;</span><br><span class="line">    <span class="comment">// 调用processCommand执行命令</span></span><br><span class="line">    <span class="keyword">if</span> (processCommand(c) == C_OK) &#123;</span><br><span class="line">        commandProcessed(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.current_client == <span class="literal">NULL</span>) deadclient = <span class="number">1</span>;</span><br><span class="line">    server.current_client = old_client;</span><br><span class="line">    <span class="keyword">return</span> deadclient ? C_ERR : C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>processCommand</strong></p>
<p>processCommand函数在server.c文件中，它调用了addReply函数将需要返回给客户端的数据先写入缓冲区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">"quit"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 调用addReply函数将需要返回给客户端的数据先写入缓冲区</span></span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">        c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据读取的整体过程如下，<strong>IO多线程只是负责从客户端读取数据解析命令，执行命令的过程仍然是单线程的</strong>：</p>
<p><img src="/images/redis数据读取过程.jpg" alt=""></p>
<h3 id="延迟写操作的客户端分配线程"><a href="#延迟写操作的客户端分配线程" class="headerlink" title="延迟写操作的客户端分配线程"></a>延迟写操作的客户端分配线程</h3><p><strong>handleClientsWithPendingWritesUsingThreads</strong></p>
<p>延迟写操作的客户端分配线程在handleClientsWithPendingWritesUsingThreads中实现（networking.c），处理逻辑与handleClientsWithPendingReadsUsingThreads类似：</p>
<ol>
<li><p>从server.clients_pending_write获取延迟写操作的客户端，将其加入到迭代列表</p>
</li>
<li><p>遍历延迟写操作的客户端列表，获取每一个待处理的客户端client，<strong>使用取模的方式轮询为每一个客户端分配线程，然后将客户端加入到该线程待处理的客户端列表中，此时客户端已分配到线程，在线程的运行函数IOThreadMain会处待写回数据的客户端</strong></p>
</li>
<li><p>将io_threads_op线程操作状态置为写操作</p>
</li>
<li><p>遍历线程数，获取每一个线程要处理的客户端个数，将其设置到线程对应的io_threads_pending[j]中，<strong>io_threads_pending数组中记录了每个线程等待处理的客户端个数</strong></p>
</li>
<li><p>获取io_threads_list[0]中待处理的客户端列表，io_threads_list[0]存储的是主线程的数据，<strong>因为当前执行handleClientsWithPendingWritesUsingThreads函数的线程正是主线程，所以让主线程来处理io_threads_list[0]中存放的待处理客户端</strong></p>
</li>
<li><p>主线程遍历io_threads_list[0]中每一个待处理的客户端，调用writeToClient往客户端写数据</p>
</li>
<li><p>主线程开启一个while(1)循环等待其他IO线程处理完毕</p>
</li>
<li><p>主线程开启while循环，循环条件是server.clients_pending_write列表的长度不为0，遍历clients_pending_write中待处理的写客户端：</p>
<p>（1）调用listNodeValue获取待处理的客户端client</p>
<p>（2）<strong>判断缓冲区数据是否全部写回到客户端，如果未全部写回调用connSetWriteHandler向内核注册写事件监听，回调函数为sendReplyToClient，待事件循环流程再次执行时，注册的可写事件会通过回调函数sendReplyToClient 处理，把缓冲区中的数据写回客户端。</strong></p>
</li>
<li><p>调用listEmpty函数清空server.clients_pending_write列表</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWithPendingWritesUsingThreads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = listLength(server.clients_pending_write);</span><br><span class="line">    <span class="keyword">if</span> (processed == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span> || stopThreadedIOIfNeeded()) &#123;</span><br><span class="line">        <span class="keyword">return</span> handleClientsWithPendingWrites();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!server.io_threads_active) startThreadedIO();</span><br><span class="line"></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="comment">// 获取待写回客户端列表clients_pending_write加入到迭代链表中</span></span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="keyword">int</span> item_id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历待写的客户端</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP) &#123;</span><br><span class="line">            listDelNode(server.clients_pending_write, ln);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据线程数取模，轮询分配线程</span></span><br><span class="line">        <span class="keyword">int</span> target_id = item_id % server.io_threads_num;</span><br><span class="line">         <span class="comment">// 分配线程，加入到对应线程的io_threads_list</span></span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将io_threads_op线程操作状态置为写操作 */</span></span><br><span class="line">    io_threads_op = IO_THREADS_OP_WRITE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = listLength(io_threads_list[j]);</span><br><span class="line">        <span class="comment">// 设置每个线程需要处理的客户端个数</span></span><br><span class="line">        setIOPendingCount(j, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取io_threads_list[0]中待处理的客户端列表，io_threads_list[0]存储的是主线程的数据*/</span></span><br><span class="line">    <span class="comment">/* handleClientsWithPendingWritesUsingThreads函数的执行者刚好就是主线程，所以让主线程处理io_threads_list[0]中的数据*/</span></span><br><span class="line">    listRewind(io_threads_list[<span class="number">0</span>],&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="comment">// 调用writeToClient往客户写数据</span></span><br><span class="line">        writeToClient(c,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(io_threads_list[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待其他线程处理完毕 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pending = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">            pending += getIOPendingCount(j);</span><br><span class="line">        <span class="keyword">if</span> (pending == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 再次获取server.clients_pending_read所有待写的客户端*/</span></span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果缓冲区数据未全部写回调用connSetWriteHandler注册可写事件，回调函数为sendReplyToClient*/</span></span><br><span class="line">        <span class="keyword">if</span> (clientHasPendingReplies(c) &amp;&amp;</span><br><span class="line">                connSetWriteHandler(c-&gt;conn, sendReplyToClient) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空clients_pending_write</span></span><br><span class="line">    listEmpty(server.clients_pending_write);</span><br><span class="line"></span><br><span class="line">    server.stat_io_writes_processed += processed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>connSetWriteHandler</strong></p>
<p>connSetWriteHandler函数在connection.c文件中，它通过set_write_handler注册了写handler，set_write_handler对应的是connSocketSetWriteHandler函数，<strong>所以connSetWriteHandler会被映射为connSocketSetWriteHandler，connSocketSetWriteHandler函数调用了aeCreateFileEvent向内核中注册可写事件监听，上面可知回调函数为sendReplyToClient</strong> ，等事件循环流程再次执行时，handleClientsWithPendingWritesUsingThreads 函数注册的可写事件会通过回调函数sendReplyToClient 处理，把缓冲区中的数据写回客户端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ConnectionType CT_Socket = &#123;</span><br><span class="line">    .ae_handler = connSocketEventHandler,</span><br><span class="line">    .close = connSocketClose,</span><br><span class="line">    .write = connSocketWrite,</span><br><span class="line">    .read = connSocketRead,</span><br><span class="line">    .accept = connSocketAccept,</span><br><span class="line">    .connect = connSocketConnect,</span><br><span class="line">    .set_write_handler = connSocketSetWriteHandler, <span class="comment">// set_write_handler对应connSocketSetWriteHandler函数</span></span><br><span class="line">    .set_read_handler = connSocketSetReadHandler,</span><br><span class="line">    .get_last_error = connSocketGetLastError,</span><br><span class="line">    .blocking_connect = connSocketBlockingConnect,</span><br><span class="line">    .sync_write = connSocketSyncWrite,</span><br><span class="line">    .sync_read = connSocketSyncRead,</span><br><span class="line">    .sync_readline = connSocketSyncReadLine,</span><br><span class="line">    .get_type = connSocketGetType</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * connSetWriteHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">connSetWriteHandler</span><span class="params">(connection *conn, ConnectionCallbackFunc func)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册写handler, set_write_handler对应的是connSocketSetWriteHandler函数</span></span><br><span class="line">    <span class="keyword">return</span> conn-&gt;type-&gt;set_write_handler(conn, func, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * connSocketSetWriteHandler注册写事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">connSocketSetWriteHandler</span><span class="params">(connection *conn, ConnectionCallbackFunc func, <span class="keyword">int</span> barrier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (func == conn-&gt;write_handler) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    conn-&gt;write_handler = func;</span><br><span class="line">    <span class="keyword">if</span> (barrier)</span><br><span class="line">        conn-&gt;flags |= CONN_FLAG_WRITE_BARRIER;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        conn-&gt;flags &amp;= ~CONN_FLAG_WRITE_BARRIER;</span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;write_handler)</span><br><span class="line">        aeDeleteFileEvent(server.el,conn-&gt;fd,AE_WRITABLE);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,conn-&gt;fd,AE_WRITABLE, <span class="comment">// 向内核注册写事件</span></span><br><span class="line">                    conn-&gt;type-&gt;ae_handler,conn) == AE_ERR) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong><br><img src="/images/redis事件驱动框架多线程总结.png" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/25/【Redis】事件驱动框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/25/【Redis】事件驱动框架/" itemprop="url">【Redis】事件驱动源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-25T22:00:00+08:00">
                2022-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="aeEventLoop初始化"><a href="#aeEventLoop初始化" class="headerlink" title="aeEventLoop初始化"></a>aeEventLoop初始化</h2><p>在server.c文件的initServer函数中，对aeEventLoop进行了初始化：</p>
<ol>
<li>调用aeCreateEventLoop函数创建aeEventLoop结构体，对aeEventLoop结构体中的变量进行了初始化，之后<strong>调用了aeApiCreate函数创建epoll实例</strong></li>
<li>调用aeCreateFileEvent函数向内核注册监听事件，由参数可知，<strong>注册的是对TCP文件描述符的可读事件监听，回调函数是acceptTcpHandler，当内核监听到TCP文件描述符有可读事件时，Redis将调用acceptTcpHandler函数对事件进行处理</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建aeEventLoop结构体</span></span><br><span class="line">      server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);</span><br><span class="line">      <span class="keyword">if</span> (server.el == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">"Failed creating the event loop. Error message: '%s'"</span>,</span><br><span class="line">                  strerror(errno));</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略其他代码...</span></span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">          <span class="comment">// 注册监听事件，server.ipfd是TCP文件描述符，AE_READABLE可读事件，acceptTcpHandler事件处理回调函数</span></span><br><span class="line">          <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">                  acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">          &#123;</span><br><span class="line">              serverPanic(</span><br><span class="line">                      <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略其他代码...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在aeCreateEventLoop函数调用时，传入的最大文件描述符个数为客户端最大连接数+宏定义CONFIG_FDSET_INCR的大小，CONFIG_FDSET_INCR的定义在server.h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FDSET_INCR (CONFIG_MIN_RESERVED_FDS+96)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MIN_RESERVED_FDS 32</span></span><br></pre></td></tr></table></figure>
<h3 id="aeEventLoop结构体创建"><a href="#aeEventLoop结构体创建" class="headerlink" title="aeEventLoop结构体创建"></a>aeEventLoop结构体创建</h3><p>aeEventLoop结构体定义，在ae.h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* 记录最大的文件描述符 */</span></span><br><span class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* 最大文件描述符个数 */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     </span><br><span class="line">    aeFileEvent *events; <span class="comment">/* IO事件集合，记录了每个文件描述符产生事件时的回调函数 */</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">/* 记录已触发的事件 */</span></span><br><span class="line">    aeTimeEvent *timeEventHead; <span class="comment">/* 时间事件 */</span></span><br><span class="line">    <span class="keyword">int</span> stop;</span><br><span class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* IO多路复用API接口相关数据 */</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep;<span class="comment">/* 进入事件循环流程前的执行函数 */</span></span><br><span class="line">    aeBeforeSleepProc *aftersleep;<span class="comment">/* 退出事件循环流程后的执行函数 */</span></span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure>
<p><strong>aeCreateEventLoop</strong></p>
<p>aeEventLoop结构体创建在aeCreateEventLoop函数中（ae.c文件）：</p>
<ol>
<li>分配aeEventLoop结构体所需内存</li>
<li>分配aeEventLoop结构体中其他变量所需内存</li>
<li><strong>调用aeApiCreate函数创建epoll实例</strong></li>
<li>对IO事件集合events的mask掩码初始化为AE_NONE，表示当前没有事件监听</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// aeEventLoop结构体</span></span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 分配eventLoop内存</span></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">// 分配IO事件内存</span></span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;aftersleep = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 创建poll实例</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE; <span class="comment">// 初始化为空事件</span></span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建epoll实例"><a href="#创建epoll实例" class="headerlink" title="创建epoll实例"></a>创建epoll实例</h4><p>aeApiState结构体定义，在ae_epoll.c中：</p>
<ul>
<li><p><strong>epfd：创建的epoll实例文件描述符</strong></p>
</li>
<li><p><strong>events：记录文件描述符产生的事件</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeApiState</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> epfd; <span class="comment">// epoll实例文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span> <span class="comment">// 记录就绪的事件</span></span><br><span class="line">&#125; aeApiState;</span><br></pre></td></tr></table></figure>
<p><strong>aeApiCreate</strong></p>
<p>epoll实例的的创建在aeApiCreate函数（ae_epoll.c文件）中，处理逻辑如下：</p>
<ol>
<li><p>为aeApiState结构体分配内存空间</p>
</li>
<li><p>为aeApiState中的events分配内存空间，events数组个数为eventLoop中的最大文件描述个数</p>
</li>
<li><p><strong>调用epoll_create函数创建epoll实例，将返回的epoll文件描述符保存在epfd中</strong></p>
</li>
<li>将eventLoop的apidata指向创建的aeApiState，之后就可以通过eventLoop获取到epoll实例并且注册监听事件了</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 为epoll事件分配内存</span></span><br><span class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(struct epoll_event)*eventLoop-&gt;setsize);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// epoll_create创建epoll实例，返回文件描述符，保存在state的epfd中</span></span><br><span class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); </span><br><span class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        zfree(state-&gt;events);</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将aeApiState设置到eventLoop的apidata</span></span><br><span class="line">    eventLoop-&gt;apidata = state;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h3><p>IO 事件的数据结构是 aeFileEvent 结构体，在ae.c中定义：</p>
<ul>
<li><p><strong>mask：事件类型掩码</strong>，共有READABLE、WRITABLE、BARRIER三种事件，分别为可读事件、可写事件和屏障事件</p>
</li>
<li><p><strong>rfileProc：写事件回调函数</strong></p>
</li>
<li><p><strong>wfileProc：读事件回调函数</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mask; <span class="comment">/* 事件类型掩码 READABLE|WRITABLE|BARRIER  */</span></span><br><span class="line">    aeFileProc *rfileProc;  <span class="comment">/* 写事件回调函数  */</span></span><br><span class="line">    aeFileProc *wfileProc;  <span class="comment">/* 读事件回调函数  */</span></span><br><span class="line">    <span class="keyword">void</span> *clientData; <span class="comment">/* 客户端数据 */</span></span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure>
<p><strong>aeCreateFileEvent</strong></p>
<p>aeCreateFileEvent函数在ae.c文件中，主要处理逻辑如下：</p>
<ol>
<li>根据传入的文件描述符，在eventLoop中获取对应的IO事件aeFileEvent fe</li>
<li><strong>调用aeApiAddEvent方法注册要监听的事件</strong></li>
<li>设置读写事件的回调函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</span></span></span><br><span class="line"><span class="function"><span class="params">        aeFileProc *proc, <span class="keyword">void</span> *clientData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据传入的文件描述符获取对应的IO事件</span></span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line">    <span class="comment">// 注册要监听的事件，让内核可以监听到当前文件描述符上的IO事件</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc; <span class="comment">// 设置写事件的回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc; <span class="comment">// 设置读事件的回调函数</span></span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd)</span><br><span class="line">        eventLoop-&gt;maxfd = fd;</span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>aeApiAddEvent</strong></p>
<p>aeApiAddEvent用于注册事件（ae_epoll.c文件中）：</p>
<ol>
<li>从eventLoop获取aeApiState，因为aeApiState中的epfd记录了epoll实例</li>
<li>创建了epoll_event类型的变量ee，用于记录操作类型、要监听的文件描述符以及事件类型，在调用函数时使用</li>
<li>根据掩码mask判断操作类型，如果文件描述符还未设置监听事件mask掩码为AE_NONE, 类型设置为添加，否则设置为修改，操作类型有如下三种：<ul>
<li>EPOLL_CTL_ADD：用于向epoll添加监听事件</li>
<li>EPOLL_CTL_MOD：用于修改已经注册过的监听事件</li>
<li>EPOLL_CTL_ADD：用于删除监听事件</li>
</ul>
</li>
<li>将redis的可读、可写事件类型转换为epoll的类型，读事件类型为EPOLLIN，写事件为EPOLLOUT，并设置到ee的events中</li>
<li><strong>调用epoll_ctl函数添加文件描述符的监听事件</strong>，参数分别为epoll实例、操作类型、要监听的文件描述符、epoll_event类型变量ee</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取aeApiState</span></span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="comment">// 创建epoll_event类型的变量ee，添加监听事件的时候使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span> = &#123;</span><span class="number">0</span>&#125;; <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    <span class="comment">/* 如果fd文件描述符还未设置监听事件, 类型设置为添加，否则设置为修改，简言之就是根据掩码判断是添加还是修改监听事件 */</span></span><br><span class="line">    <span class="keyword">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</span><br><span class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    mask |= eventLoop-&gt;events[fd].mask; </span><br><span class="line">    <span class="comment">// 如果是可读事件，转换为epoll的读事件监听类型EPOLLIN，并设置到ee的events中</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="comment">// 如果是可写事件，转换为epoll的写事件监听类型EPOLLOUT，并设置到ee的events中</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    <span class="comment">// 记录要监听的文件描述符</span></span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="comment">// 调用epoll_ctl函数向epoll添加监听事件，参数分别为epoll实例、操作类型、要监听的文件描述符、epoll_event类型变量ee</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>Redis在启动时，调用aeCreateEventLoop创建aeEventLoop结构体和epoll实例，之后调用aeCreateFileEvent函数向内核注册TCP文件描述符的监听事件，当有客户端连接Redis服务时，TCP文件描述符产生可读事件，通过epoll可以获取产生事件的文件描述符，Redis就可以对连接请求进行处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.el是eventLoop</span></span><br><span class="line"><span class="comment">// server.ipfd[j]是监听端口的文件描述符</span></span><br><span class="line"><span class="comment">// AE_READABLE是读事件</span></span><br><span class="line"><span class="comment">// acceptTcpHandler是事件产生时的回调函数</span></span><br><span class="line">aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>aeMain函数在ae.c文件中，里面是一个while循环，它的处理逻辑如下：</p>
<ol>
<li>通过eventLoop的stop判断是否处于停止状态，如果非停止状态进入第2步</li>
<li>判断eventLoop的beforesleep是否为空，如果不为空，调用beforesleep函数</li>
<li><strong>调用了aeProcessEvents函数处理IO事件</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        <span class="comment">// 调用了aeProcessEvents处理事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>aeProcessEvents</strong></p>
<p>aeProcessEvents函数在ae.c文件中，处理逻辑如下：</p>
<ol>
<li><strong>调用aeApiPoll函数等待就绪的事件，如果有事件产生，返回就绪的文件描述符个数，aeApiPoll函数中对就绪文件描述符处理时将其放在了fired中</strong></li>
<li><strong>for循环中处理就绪的事件，通过fired可以获取到每一个产生事件的文件描述符fd，根据文件描述符fd可以在eventLoop的events中获取对应的事件aeFileEvent，aeFileEvent中记录了事件的回调函数，之后根据事件类型，调用对应的回调函数，调用回调函数的入参分别为eventLoop、文件描述符、aeFileEvent的clientData、事件类型掩码</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果没有事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果有IO事件或者时间事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略代码...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待事件，返回就绪文件描述符的数量</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* After sleep callback. */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理就绪的事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="comment">// aeApiPoll中已将就绪的事件放在了fired中,通过fired可以获取到产生事件的文件描述符fd</span></span><br><span class="line">            <span class="comment">// 根据文件描述符fd获取对应的事件aeFileEvent,aeFileEvent中记录了事件的回调函数</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="comment">// 获取文件描述符</span></span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 判断屏障 */</span></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 处理可读事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="comment">// 如果是可读事件，调用可读事件的回调函数，参数分别为eventLoop、文件描述符、aeFileEvent的clientData、事件类型掩码</span></span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 处理可写事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    <span class="comment">// 如果是写事件，调用写事件的回调函数，参数分别为eventLoop、文件描述符、aeFileEvent的clientData、事件类型掩码</span></span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">             * after the writable one. */</span></span><br><span class="line">            <span class="keyword">if</span> (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果有时间事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>aeApiPoll</strong></p>
<p>aeApiPoll处理就绪的事件：</p>
<ol>
<li><p><strong>调用IO多路复用epoll_wait函数等待事件的产生，epoll_wait函数需要传入epoll实例、记录就绪事件集合的epoll_event，这两个参数分别在aeApiState的epfd和events中</strong>，当监听的文件描述符有事件产生时，epoll_wait返回就绪的文件描述符个数</p>
</li>
<li><p>对epoll_wait返回的就绪事件进行处理，<strong>事件记录在events变量中，遍历每一个就绪的事件，将事件对应的文件描述符设置在eventLoop的fire中，后续通过fire对事件进行处理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, struct timeval *tvp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取aeApiState，aeApiState记录了epoll实例，events记录了产生的事件</span></span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="keyword">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 等待事件的产生，epoll_wait返回就绪的文件描述符个数，就绪的事件记录在state-&gt;events中</span></span><br><span class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="comment">// 处理返回的就绪事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 获取每一个就绪的事件</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">e</span> = <span class="title">state</span>-&gt;<span class="title">events</span>+<span class="title">j</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="comment">// 将就绪事件的文件描述符设置到已触发的事件fired的fd中</span></span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            <span class="comment">// 设置事件类型掩码</span></span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="处理客户端连接"><a href="#处理客户端连接" class="headerlink" title="处理客户端连接"></a>处理客户端连接</h3><p><strong>acceptTcpHandler</strong></p>
<p>由上面的调用可知，Redis在启动时，注册了AE_READABLE读事件，回调函数为acceptTcpHandler（network.c文件中）用于处理客户端连接，当有客户端与Redis连接时，epoll返回就绪的文件描述符，Redis在处理就绪的事件时调用acceptTcpHandler进行处理：</p>
<ol>
<li>调用anetTcpAccept建立连接，并返回已连接的套接字文件描述符cfd</li>
<li>调用acceptCommonHandler（network.c文件中）函数，它又调用了createClient函数，<strong>在createClient函数中调用了aeCreateFileEvent，向内核注册已连接套接字的可读监听事件</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cport, cfd, max = MAX_ACCEPTS_PER_CALL;</span><br><span class="line">    <span class="keyword">char</span> cip[NET_IP_STR_LEN];</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line">    UNUSED(privdata);</span><br><span class="line">    <span class="keyword">while</span>(max--) &#123;</span><br><span class="line">        <span class="comment">// 建立连接，返回已连接的套接字文件描述符cfd</span></span><br><span class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</span><br><span class="line">        <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"Accepting client connection: %s"</span>, server.neterr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_VERBOSE,<span class="string">"Accepted %s:%d"</span>, cip, cport);</span><br><span class="line">        <span class="comment">// 调用acceptCommonHandler处理连接，这里传入的文件描述符为已连接的套接字</span></span><br><span class="line">        acceptCommonHandler(cfd,<span class="number">0</span>,cip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptCommonHandler</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags, <span class="keyword">char</span> *ip)</span> </span>&#123;</span><br><span class="line">    client *c;</span><br><span class="line">    <span class="comment">// 调用createClient</span></span><br><span class="line">    <span class="keyword">if</span> ((c = createClient(fd)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Error registering fd event for the new client: %s (fd=%d)"</span>,</span><br><span class="line">            strerror(errno),fd);</span><br><span class="line">        close(fd); <span class="comment">/* May be already closed, just ignore errors */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>createClient</strong></p>
<p>createClient函数中调用了aeCreateFileEvent方法向内核中注册可读事件，上文可知传入的描述符是已连接套接字cfd，回调函数为readQueryFromClient，<strong>此时事件驱动框架增加了对客户端已连接套接字的监听，当客户端有数据发送到服务端时，Redis调用readQueryFromClient函数处理读事件：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,fd);</span><br><span class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</span><br><span class="line">        <span class="comment">// 注册已连接套接字的可读事件，回调函数为readQueryFromClient</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</span><br><span class="line">            readQueryFromClient, c) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            zfree(c);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="处理读事件"><a href="#处理读事件" class="headerlink" title="处理读事件"></a>处理读事件</h3><p><strong>readQueryFromClient</strong></p>
<p>readQueryFromClient函数在network.c文件中，是可读事件的回调函数，用于处理已连接套接字上的读事件，处理逻辑如下：</p>
<ol>
<li>从已连接的套接字中读取客户端的请求数据到输入缓冲区</li>
<li>调用processInputBufferAndReplicate函数处理输入缓冲区的数据</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aeProcessEvents中调用回调函数时，传入的参数分别为aeEventLoop、已连接套接字的文件描述符、aeFileEvent的clientData私有数据、事件类型掩码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    client *c = (client*) privdata;</span><br><span class="line">    <span class="keyword">int</span> nread, readlen;</span><br><span class="line">    <span class="keyword">size_t</span> qblen;</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line"></span><br><span class="line">    readlen = PROTO_IOBUF_LEN;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></span><br><span class="line">        &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> remaining = (<span class="keyword">size_t</span>)(c-&gt;bulklen+<span class="number">2</span>)-sdslen(c-&gt;querybuf);</span><br><span class="line">        <span class="keyword">if</span> (remaining &gt; <span class="number">0</span> &amp;&amp; remaining &lt; readlen) readlen = remaining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;</span><br><span class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);</span><br><span class="line">    <span class="comment">// 从已连接的套接字中读取客户端的请求数据到输入缓冲区</span></span><br><span class="line">    nread = read(fd, c-&gt;querybuf+qblen, readlen);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_VERBOSE, <span class="string">"Reading from client: %s"</span>,strerror(errno));</span><br><span class="line">            freeClient(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        serverLog(LL_VERBOSE, <span class="string">"Client closed connection"</span>);</span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) &#123;</span><br><span class="line">        c-&gt;pending_querybuf = sdscatlen(c-&gt;pending_querybuf,</span><br><span class="line">                                        c-&gt;querybuf+qblen,nread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 处理输入缓冲区数据 */</span></span><br><span class="line">    processInputBufferAndReplicate(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理写事件"><a href="#处理写事件" class="headerlink" title="处理写事件"></a>处理写事件</h3><p>在aeMain调用aeProcessEvents之前，先调用了beforeSleep方法，beforeSleep中又调用了handleClientsWithPendingWrites，它会将Redis Server缓冲区的数据写回到客户端：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle writes with pending output buffers. */</span></span><br><span class="line">    handleClientsWithPendingWrites();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;.</span><br></pre></td></tr></table></figure></p>
<p><strong>handleClientsWithPendingWrites</strong></p>
<p><strong>Redis Server收到客户端的请求命令后，需要处理请求，然后将要返回的数据写回到客户端，写回到客户端的逻辑在handleClientsWithPendingWrites函数中</strong>，处理逻辑如下：</p>
<ol>
<li>获取待写回数据的客户端列表</li>
<li>遍历每一个待写回数据的客户端，调用writeToClient方法将缓冲区的数据写到客户端socket中，<strong>然后调用clientHasPendingReplies方法判断数据是否全部写回，如果为否，则调用aeCreateFileEvent向内核注册客户端文件描述符的可写事件监听，交由回调函数sendReplyToClient处理</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWithPendingWrites</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="keyword">int</span> processed = listLength(server.clients_pending_write);</span><br><span class="line">    <span class="comment">// 获取待写回数据的客户端列表</span></span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="comment">// 遍历每一个待写回数据的客户端</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;</span><br><span class="line">        listDelNode(server.clients_pending_write,ln);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PROTECTED) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将缓冲区的数据写到客户端socket中 */</span></span><br><span class="line">        <span class="keyword">if</span> (writeToClient(c-&gt;fd,c,<span class="number">0</span>) == C_ERR) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果数据未全部写回到客户端 */</span></span><br><span class="line">        <span class="keyword">if</span> (clientHasPendingReplies(c)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ae_flags = AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (server.aof_state == AOF_ON &amp;&amp;</span><br><span class="line">                server.aof_fsync == AOF_FSYNC_ALWAYS)</span><br><span class="line">            &#123;</span><br><span class="line">                ae_flags |= AE_BARRIER;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用aeCreateFileEvent方法，向内核注册客户端文件描述符的可写事件监听，交由回调函数sendReplyToClient处理</span></span><br><span class="line">            <span class="keyword">if</span> (aeCreateFileEvent(server.el, c-&gt;fd, ae_flags,</span><br><span class="line">                sendReplyToClient, c) == AE_ERR)</span><br><span class="line">            &#123;</span><br><span class="line">                    freeClientAsync(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>clientHasPendingReplies</strong></p>
<p>有时由于网络原因或者其他原因，可能只发出去了部分数据，客户端如果一直未从缓冲区读取数据，在缓冲区已满的情况，服务端将无法往客户端发送数据，所以调用clientHasPendingReplies函数判断数据是否写回完毕，如果未写回完毕交由事件循环驱动处理，提高处理效率。</p>
</blockquote>
<p><strong>整体流程图</strong><br><img src="/images/redis事件驱动流程.jpg" alt=""></p>
<p><strong>总结</strong><br><img src="/images/redis事件驱动总结.jpg" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a></p>
<p><a href="https://my.oschina.net/u/4350001/blog/3676193" target="_blank" rel="noopener">【osc_avxkth26】Redis 网络通信模块源码分析（3）</a></p>
<p><a href="https://www.cnblogs.com/jeakeven/p/4902332.html" target="_blank" rel="noopener">网络通信 –&gt; epoll用法</a></p>
<p><strong>Redis版本：redis-5.0.8</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/19/【Spring】AOP实现原理（三）：创建代理（基于注解）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/19/【Spring】AOP实现原理（三）：创建代理（基于注解）/" itemprop="url">【Spring】AOP实现原理（三）：创建代理（基于注解）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-19T21:00:00+08:00">
                2022-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="AbstractAutoProxyCreator"><a href="#AbstractAutoProxyCreator" class="headerlink" title="AbstractAutoProxyCreator"></a>AbstractAutoProxyCreator</h1><p>在AbstractAutoProxyCreator的wrapIfNecessary方法中，调用getAdvicesAndAdvisorsForBean方法获取到所有的Advisor之后，就可以创建代理对象了，创建的具体过程在createProxy方法中：</p>
<ol>
<li>创建代理工厂ProxyFactory</li>
<li>调用buildAdvisors构建Advisor，<strong>入参是getAdvicesAndAdvisorsForBean获取到的Advice和Advisor，里面又调用了AdvisorAdapterRegistry的wrap方法判断Advice是否是Advisor类型，这一步主要是对通知Advice进行校验，如果通知不是Advisor类型将其包装为Advisor</strong></li>
<li>通过代理工厂ProxyFactory生成代理对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有必要生成代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Advices和Advisors</span></span><br><span class="line">        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">            <span class="comment">// 创建代理，specificInterceptors就是获取到的Advices和Advisors</span></span><br><span class="line">            Object proxy = createProxy(</span><br><span class="line">                    bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">            <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 @Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">            AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.创建代理工厂</span></span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">                proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.构建Advisor</span></span><br><span class="line">        Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">        <span class="comment">// 设置Advisor</span></span><br><span class="line">        proxyFactory.addAdvisors(advisors);</span><br><span class="line">        proxyFactory.setTargetSource(targetSource);</span><br><span class="line">        customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">        proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">        <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">            proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.生成代理对象</span></span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="构建Advisor"><a href="#构建Advisor" class="headerlink" title="构建Advisor"></a>构建Advisor</h2><p>AbstractAutoProxyCreator的buildAdvisors主要是对通知Advice进行校验，如果通知不是Advisor类型将其包装为Advisor，具体是通过AdvisorAdapterRegistry的wrap方法实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用GlobalAdvisorAdapterRegistry的getInstance获取AdvisorAdapterRegistry实例</span></span><br><span class="line">    <span class="keyword">private</span> AdvisorAdapterRegistry advisorAdapterRegistry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建Advisors，specificInterceptors是上一步获取到的Advice和Advisor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Advisor[] buildAdvisors(<span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> Object[] specificInterceptors) &#123;</span><br><span class="line">        <span class="comment">// Handle prototypes correctly...</span></span><br><span class="line">        Advisor[] commonInterceptors = resolveInterceptorNames();</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; allInterceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (specificInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将获取到的Advice和Advisor添加到拦截器中</span></span><br><span class="line">            allInterceptors.addAll(Arrays.asList(specificInterceptors));</span><br><span class="line">            <span class="keyword">if</span> (commonInterceptors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.applyCommonInterceptorsFirst) &#123;</span><br><span class="line">                    allInterceptors.addAll(<span class="number">0</span>, Arrays.asList(commonInterceptors));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    allInterceptors.addAll(Arrays.asList(commonInterceptors));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nrOfCommonInterceptors = commonInterceptors.length;</span><br><span class="line">            <span class="keyword">int</span> nrOfSpecificInterceptors = (specificInterceptors != <span class="keyword">null</span> ? specificInterceptors.length : <span class="number">0</span>);</span><br><span class="line">            logger.trace(<span class="string">"Creating implicit proxy for bean '"</span> + beanName + <span class="string">"' with "</span> + nrOfCommonInterceptors +</span><br><span class="line">                    <span class="string">" common interceptors and "</span> + nrOfSpecificInterceptors + <span class="string">" specific interceptors"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建Advisor集合</span></span><br><span class="line">        Advisor[] advisors = <span class="keyword">new</span> Advisor[allInterceptors.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allInterceptors.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 调用AdvisorAdapterRegistry的wrap方法将通知包装为Advisor进行增强，在DefaultAdvisorAdapterRegistry中实现</span></span><br><span class="line">            advisors[i] = <span class="keyword">this</span>.advisorAdapterRegistry.wrap(allInterceptors.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> advisors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AdvisorAdapterRegistry</strong></p>
<p>在GlobalAdvisorAdapterRegistry中可以看到使用的是DefaultAdvisorAdapterRegistry：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalAdvisorAdapterRegistry</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用DefaultAdvisorAdapterRegistry</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AdvisorAdapterRegistry instance = <span class="keyword">new</span> DefaultAdvisorAdapterRegistry();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回AdvisorAdapterRegistry</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AdvisorAdapterRegistry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DefaultAdvisorAdapterRegistry"><a href="#DefaultAdvisorAdapterRegistry" class="headerlink" title="DefaultAdvisorAdapterRegistry"></a>DefaultAdvisorAdapterRegistry</h3><p>DefaultAdvisorAdapterRegistry中的wrap方法主要逻辑如下：</p>
<ol>
<li>如果当前的通知已经是Advisor类型直接返回即可</li>
<li>如果当前的通知不是Advice类型，抛出异常</li>
<li>将通知转为Advice，对通知进行判断<ul>
<li>如果通知是MethodInterceptor方法拦截器，将其包装为DefaultPointcutAdvisor</li>
<li>如果不是MethodInterceptor，遍历Adapter适配器，找出支持当前通知的适配器，再将通知包装为DefaultPointcutAdvisor返回</li>
</ul>
</li>
<li>非以上几种情况抛出异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorAdapterRegistry</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapterRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advisor <span class="title">wrap</span><span class="params">(Object adviceObject)</span> <span class="keyword">throws</span> UnknownAdviceTypeException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果已经是Advisor，返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (adviceObject <span class="keyword">instanceof</span> Advisor) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Advisor) adviceObject;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是Advice类型，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!(adviceObject <span class="keyword">instanceof</span> Advice)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(adviceObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转为Advice</span></span><br><span class="line">        Advice advice = (Advice) adviceObject;</span><br><span class="line">        <span class="comment">// 如果是一个方法拦截器</span></span><br><span class="line">        <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line">            <span class="comment">// 包装为DefaultPointcutAdvisor</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line">            <span class="comment">// 判断Advisor适配器是否支持当前的Advice</span></span><br><span class="line">            <span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">                <span class="comment">// 包装为DefaultPointcutAdvisor</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成代理对象"><a href="#生成代理对象" class="headerlink" title="生成代理对象"></a>生成代理对象</h2><p>上一步中已经对所有的Advice进行了校验，转为了Advisor进行增强，接下来就可以生成代理对象了，具体实现在ProxyFactory的getProxy中：</p>
<ol>
<li><p>调用createAopProxy获取AopProxy，AopProxy是一个接口，定义了getProxy获取代理对象的方法，它有两个实现类分别为<strong>CglibAopProxy</strong>和<strong>JdkDynamicAopProxy</strong></p>
<p><img src="/images/AOPPROXY.png" alt=""></p>
</li>
<li><p>调用AopProxy的getProxy方法获取代理对象 </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">extends</span> <span class="title">ProxyCreatorSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过工厂创建AOP代理对象，createAopProxy方法在ProxyCreatorSupport中实现</span></span><br><span class="line">        <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="createAopProxy创建AopProxy"><a href="#createAopProxy创建AopProxy" class="headerlink" title="createAopProxy创建AopProxy"></a>createAopProxy创建AopProxy</h3><p>createAopProxy的实现逻辑在ProxyFactory的父类ProxyCreatorSupport中实现，它使用了工厂模式生成代理对象：</p>
<ol>
<li>调用getAopProxyFactory方法获取AopProxyFactory，在无参构造函数中可以看的默认使用的工厂是DefaultAopProxyFactory</li>
<li>调用AopProxyFactory的createAopProxy方法创建代理对象 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProxyCreatorSupport</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCreatorSupport</span> <span class="keyword">extends</span> <span class="title">AdvisedSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AOP代理工厂</span></span><br><span class="line">    <span class="keyword">private</span> AopProxyFactory aopProxyFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyCreatorSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 工厂的实现默认使用DefaultAopProxyFactory</span></span><br><span class="line">        <span class="keyword">this</span>.aopProxyFactory = <span class="keyword">new</span> DefaultAopProxyFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带有AopProxyFactory参数的构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyCreatorSupport</span><span class="params">(AopProxyFactory aopProxyFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(aopProxyFactory, <span class="string">"AopProxyFactory must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.aopProxyFactory = aopProxyFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建AopProxy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">            activate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.调用getAopProxyFactory获取AopProxy，2.调用AopProxy的createAopProxy创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回AOP代理工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxyFactory <span class="title">getAopProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.aopProxyFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DefaultAopProxyFactory"><a href="#DefaultAopProxyFactory" class="headerlink" title="DefaultAopProxyFactory"></a>DefaultAopProxyFactory</h4><p>DefaultAopProxyFactory中创建AOP代理的逻辑如下：</p>
<ol>
<li>获取目标对象的Class信息</li>
<li>对Class进行判断：<ul>
<li><strong>如果是一个接口或者isProxyClass返回true使用JDK动态代理生成代理对象，</strong>isProxyClass方法在JDK的Proxy中实现，返回true的条件为目标类是java.lang.reflect.Proxy的子类并且缓存中包含目标类</li>
<li><strong>如果上一个条件不满足则使用CGLIB生成代理对象</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            <span class="comment">// 获取目标对象的Class信息</span></span><br><span class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">            <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                        <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是一个接口</span></span><br><span class="line">            <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则使用CGLIB生成代理对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.reflect.Proxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否是java.lang.reflect.Proxy的子类并且缓存中包含目标类</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.class.isAssignableFrom(cl) &amp;&amp; proxyClassCache.containsValue(cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此AopProxy已经创建成功，接下来以JdkDynamicAopProxy为例查看getProxy获取代理对象过程。</p>
<h3 id="getProxy获取代理对象"><a href="#getProxy获取代理对象" class="headerlink" title="getProxy获取代理对象"></a>getProxy获取代理对象</h3><p>JdkDynamicAopProxy是通过JDK的动态代理实现代理创建的，可以看到它实现了InvocationHandler接口，关于JDK的动态代理实现原理可参考<a href="https://shan-ml.github.io/2021/09/07/%E3%80%90JAVA%E3%80%91%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">【JAVA】动态代理</a>，这里我们需要关注getProxy和invoke方法：</p>
<ul>
<li><strong>getProxy：</strong>创建代理对象</li>
<li><strong>invoke：</strong>当代理对象中引用的方法执行时会进入这个方法中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Creating JDK dynamic proxy: "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">        <span class="comment">// 生成代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 先省略</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getProxy创建代理对象"><a href="#getProxy创建代理对象" class="headerlink" title="getProxy创建代理对象"></a>getProxy创建代理对象</h4><p>可以看到是通过JDK中Proxy的newProxyInstance生成代理对象的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Creating JDK dynamic proxy: "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">        <span class="comment">// 生成代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="invoke方法"><a href="#invoke方法" class="headerlink" title="invoke方法"></a>invoke方法</h1><p>当调用AOP中需要被通知拦截的方法时，会进入到invoke方法，<strong>比较核心的是getInterceptorsAndDynamicInterceptionAdvice获取拦截器链，如果为空直接通过反射执行目标方法即可，如果不为空，将方法包装为MethodInvocation，然后执行拦截器链</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** AdvisedSupport */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * InvocationHandler中定义的invoke方法，当目标方法执行时会进入到这个方法中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 需要被执行的目标方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">        Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是equals方法</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">                <span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">                <span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">                <span class="comment">// 如果是hashCode方法</span></span><br><span class="line">                <span class="keyword">return</span> hashCode();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">                <span class="comment">// 如果方法所在类是DecoratingProxy类</span></span><br><span class="line">                <span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">                    method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">                <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object retVal;</span><br><span class="line">            <span class="comment">// 是否需要暴露代理</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">                oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            target = targetSource.getTarget();</span><br><span class="line">            Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前方法的拦截器链</span></span><br><span class="line">            List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 校验拦截器链是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">                <span class="comment">// 如果为空直接执行目标方法即可</span></span><br><span class="line">                retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 创建MethodInvocation</span></span><br><span class="line">                MethodInvocation invocation =</span><br><span class="line">                        <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">                <span class="comment">// 执行拦截器链</span></span><br><span class="line">                retVal = invocation.proceed();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取方法返回值</span></span><br><span class="line">            Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">            <span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">                    returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">                    !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">                retVal = proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">                        <span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">                <span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">                targetSource.releaseTarget(target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">                <span class="comment">// Restore old proxy.</span></span><br><span class="line">                AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取方法的拦截器链"><a href="#获取方法的拦截器链" class="headerlink" title="获取方法的拦截器链"></a>获取方法的拦截器链</h2><p>获取目标方法的拦截器链在AdvisedSupport中实现，<strong>它主要用于将适用于当前方法的Advisor转为方法拦截器</strong>，首先它先从缓存中查询，如果未查询到，调用advisorChainFactory方法的getInterceptorsAndDynamicInterceptionAdvice进行获取，在DefaultAdvisorChainFactory中实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">extends</span> <span class="title">ProxyConfig</span> <span class="keyword">implements</span> <span class="title">Advised</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** AdvisorChainFactory，默认使用DefaultAdvisorChainFactory*/</span></span><br><span class="line">    AdvisorChainFactory advisorChainFactory = <span class="keyword">new</span> DefaultAdvisorChainFactory();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取方法的拦截器链</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建缓存KEY</span></span><br><span class="line">        MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</span><br><span class="line">        <span class="comment">// 从缓存获取</span></span><br><span class="line">        List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果未从缓存中获取到，调用getInterceptorsAndDynamicInterceptionAdvice获取方法的拦截器链</span></span><br><span class="line">            cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">                    <span class="keyword">this</span>, method, targetClass);</span><br><span class="line">            <span class="comment">// 加入到缓存</span></span><br><span class="line">            <span class="keyword">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cached;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="DefaultAdvisorChainFactory"><a href="#DefaultAdvisorChainFactory" class="headerlink" title="DefaultAdvisorChainFactory"></a>DefaultAdvisorChainFactory</h3><p>getInterceptorsAndDynamicInterceptionAdvice中先获取了所有的Advisor，然后遍历Advisor，对Advisor进行判断：</p>
<ol>
<li><p>如果是PointcutAdvisor类型，<strong>将Advisor转为PointcutAdvisor，然后获取Pointcut切点的ClassFilter，通过matches方法判断当前方法所属的class是否匹配，如果匹配，则从切点中获取MethodMatcher方法匹配器，调用它的matches方法判断切点与当前方法是否匹配，如果也匹配，调用AdvisorAdapterRegistry的getInterceptors将Advisor转为方法拦截器</strong></p>
</li>
<li><p>如果是引入通知IntroductionAdvisor，并且ClassFilter的matches与当前类匹配，调用AdvisorAdapterRegistry的getInterceptors将Advisor转为方法拦截器</p>
</li>
<li>非以上两种情况，调用AdvisorAdapterRegistry的getInterceptors将Advisor转为方法拦截器</li>
</ol>
<p>可以看到以上三种情况，最后都是调用了AdvisorAdapterRegistry获取拦截器的，接下来就进入AdvisorAdapterRegistry中查看getInterceptors的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorChainFactory</span> <span class="keyword">implements</span> <span class="title">AdvisorChainFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取方法的拦截器链</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Advised config, Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取AdvisorAdapterRegistry</span></span><br><span class="line">        AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line">        <span class="comment">// 获取Advisor</span></span><br><span class="line">        Advisor[] advisors = config.getAdvisors();</span><br><span class="line">        List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;&gt;(advisors.length);</span><br><span class="line">        Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">        Boolean hasIntroductions = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 遍历Advisor</span></span><br><span class="line">        <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">            <span class="comment">// 如果是PointcutAdvisor类型</span></span><br><span class="line">            <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">                <span class="comment">// Add it conditionally.</span></span><br><span class="line">                PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">                <span class="comment">// 调用matches方法判断与当前class是否匹配</span></span><br><span class="line">                <span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">                    <span class="comment">// 获取方法匹配器MethodMatcher</span></span><br><span class="line">                    MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">                    <span class="keyword">boolean</span> match;</span><br><span class="line">                    <span class="comment">// 如果是IntroductionAwareMethodMatcher</span></span><br><span class="line">                    <span class="keyword">if</span> (mm <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hasIntroductions == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hasIntroductions = hasMatchingIntroductions(advisors, actualClass);</span><br><span class="line">                        &#125;</span><br><span class="line">                        match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用MethodMatcher的matches方法匹配</span></span><br><span class="line">                        match = mm.matches(method, actualClass);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                        <span class="comment">// 如果匹配，从registry中获取方法拦截器</span></span><br><span class="line">                        MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                        <span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line">                            <span class="comment">// Creating a new object instance in the getInterceptors() method</span></span><br><span class="line">                            <span class="comment">// isn't a problem as we normally cache created chains.</span></span><br><span class="line">                            <span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">                                <span class="comment">// 将拦截器封装为InterceptorAndDynamicMethodMatcher</span></span><br><span class="line">                                interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">                <span class="comment">// 如果是引入通知IntroductionAdvisor</span></span><br><span class="line">                IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">                <span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">                    Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                    interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> interceptorList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DefaultAdvisorAdapterRegistry-1"><a href="#DefaultAdvisorAdapterRegistry-1" class="headerlink" title="DefaultAdvisorAdapterRegistry"></a>DefaultAdvisorAdapterRegistry</h3><p>在DefaultAdvisorAdapterRegistry的构造函数中注册了三种AdvisorAdapter，使用了适配器模式将Advisor转换为方法拦截器MethodInterceptor，三种AdvisorAdapter分别为：</p>
<ul>
<li>MethodBeforeAdviceAdapter：支持前置通知MethodBeforeAdvice</li>
<li>AfterReturningAdviceAdapter：支持返回通知AfterReturningAdvice</li>
<li>ThrowsAdviceAdapter：支持ThrowsAdvice</li>
</ul>
<p><strong>AspectJAfterThrowingAdvice、AspectJAroundAdvice和AspectJAfterAdvice本身已经实现了MethodInterceptor接口，所以不需要进行转换：</strong></p>
<p><img src="/images/Advice.png" alt=""></p>
<p>在getInterceptors方法中，<strong>对Advisor进行判断，如果本身已经是MethodInterceptor直接返回即可，否则遍历所有的AdvisorAdapter，找出支持当前Advisor的Adapter，然后将Advisor转为MethodInterceptor：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorAdapterRegistry</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapterRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;AdvisorAdapter&gt; adapters = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  注册AdvisorAdapter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultAdvisorAdapterRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册MethodBeforeAdviceAdapter</span></span><br><span class="line">        registerAdvisorAdapter(<span class="keyword">new</span> MethodBeforeAdviceAdapter());</span><br><span class="line">        <span class="comment">// 注册AfterReturningAdviceAdapter</span></span><br><span class="line">        registerAdvisorAdapter(<span class="keyword">new</span> AfterReturningAdviceAdapter());</span><br><span class="line">        <span class="comment">// 注册ThrowsAdviceAdapter</span></span><br><span class="line">        registerAdvisorAdapter(<span class="keyword">new</span> ThrowsAdviceAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MethodInterceptor[] getInterceptors(Advisor advisor) <span class="keyword">throws</span> UnknownAdviceTypeException &#123;</span><br><span class="line">        List&lt;MethodInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 从Advisor中获取Advice</span></span><br><span class="line">        Advice advice = advisor.getAdvice();</span><br><span class="line">        <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line">            interceptors.add((MethodInterceptor) advice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历Adapter</span></span><br><span class="line">        <span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line">            <span class="comment">// 判断是否支持当前的通知</span></span><br><span class="line">            <span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">                <span class="comment">// 通过Adapter获取拦截器</span></span><br><span class="line">                interceptors.add(adapter.getInterceptor(advisor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (interceptors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advisor.getAdvice());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> interceptors.toArray(<span class="keyword">new</span> MethodInterceptor[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AdvisorAdapter有三个实现类，以MethodBeforeAdviceAdapter为例查看一下supportsAdvice和getInterceptor的实现：</p>
<p><img src="images/AdvisorAdapter.png" alt=""></p>
<ol>
<li><p>在supportsAdvice方法中可以看到它支持的是MethodBeforeAdvice方法前置通知</p>
</li>
<li><p>在getInterceptor方法中，首先从Advisor中获取到了通知，然后将通知封装为MethodBeforeAdviceInterceptor返回</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否是MethodBeforeAdvice类型</span></span><br><span class="line">        <span class="keyword">return</span> (advice <span class="keyword">instanceof</span> MethodBeforeAdvice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">        MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();</span><br><span class="line">        <span class="comment">// 封装为MethodBeforeAdviceInterceptor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdviceInterceptor(advice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="执行目标方法"><a href="#执行目标方法" class="headerlink" title="执行目标方法"></a>执行目标方法</h2><p>回顾invoke方法中的主要逻辑，在获取到方法的拦截器之后，对拦截器是否为空进行了判断：</p>
<ul>
<li><p>如果为空，调用AopUtils的invokeJoinpointUsingReflection通过反射直接执行方法即可</p>
</li>
<li><p>如果不为空创建MethodInvocation，具体实现类是ReflectiveMethodInvocation，然后调用proceed执行拦截器链</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 获取当前方法的拦截器链</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验拦截器链是否为空</span></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">    <span class="comment">// 如果为空直接执行目标方法即可</span></span><br><span class="line">    retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 创建MethodInvocation，使用的是ReflectiveMethodInvocation类型</span></span><br><span class="line">    MethodInvocation invocation =</span><br><span class="line">            <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">    <span class="comment">// 执行拦截器链</span></span><br><span class="line">    retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="invokeJoinpointUsingReflection"><a href="#invokeJoinpointUsingReflection" class="headerlink" title="invokeJoinpointUsingReflection"></a>invokeJoinpointUsingReflection</h3><p>invokeJoinpointUsingReflection方法通过反射执行目标方法，在AopUtils中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AopUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">invokeJoinpointUsingReflection</span><span class="params">(@Nullable Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射执行目标方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"AOP configuration seems to be invalid: tried calling method ["</span> +</span><br><span class="line">                    method + <span class="string">"] on target ["</span> + target + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Could not access method ["</span> + method + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="proceed方法执行拦截器链"><a href="#proceed方法执行拦截器链" class="headerlink" title="proceed方法执行拦截器链"></a>proceed方法执行拦截器链</h3><p>因为拦截器可以有多个，所以proceed方法是一个递归调用的过程，currentInterceptorIndex记录了当前拦截器的下标：</p>
<ol>
<li>判断currentInterceptorIndex是否与拦截器链的大小一致，如果一致说明已经走到了最后一个拦截器，调用invokeJoinpoint方法执行目标方法即可，可以看到调用了AopUtils的invokeJoinpointUsingReflection通过反射执行目标方法，如果不是最后一个拦截器进入第2步</li>
<li>对currentInterceptorIndex++，获取下一个拦截器，判断拦截器是否是InterceptorAndDynamicMethodMatcher类型，如果是获取methodMatcher对目标方法进行匹配：<ul>
<li>如果与目标方法匹配成功，执行拦截器的invoke方法</li>
<li>如果与目标方法匹配不成功，递归调用proceed方法执行下一个拦截器</li>
</ul>
</li>
<li>如果拦截器不是InterceptorAndDynamicMethodMatcher类型，直接调用方法拦截器MethodInterceptor的invoke执行拦截器即可</li>
</ol>
<p><strong>在执行MethodInterceptor方法拦截器的invoke方法时，传入的参数是this，指的是ReflectiveMethodInvocation对象本身，在拦截器方法执行后需要拿到这个对象调用proceed方法继续执行下一个拦截器，可以看到这里使用了责任链模式，对拦截器进行一个个的调用。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveMethodInvocation</span> <span class="keyword">implements</span> <span class="title">ProxyMethodInvocation</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行方法</span></span><br><span class="line">            <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取下一个拦截器</span></span><br><span class="line">        Object interceptorOrInterceptionAdvice =</span><br><span class="line">                <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">        <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">            <span class="comment">// 如果是InterceptorAndDynamicMethodMatcher</span></span><br><span class="line">            InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                    (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">            Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">            <span class="comment">// 判断方法是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">                <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Dynamic matching failed.</span></span><br><span class="line">                <span class="comment">// 如果方法不匹配，跳过当前拦截器执行下一个，递归调用</span></span><br><span class="line">                <span class="keyword">return</span> proceed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 转为MethodInterceptor执行拦截器，注意invoke传入的参数是this，指的是ReflectiveMethodInvocation对象本身，在拦截器的invoke方法中需要拿到这个对象调用proceed方法继续执行下一个拦截器</span></span><br><span class="line">            <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射执行目标方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeJoinpoint</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.target, <span class="keyword">this</span>.method, <span class="keyword">this</span>.arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MethodBeforeAdviceInterceptor</strong></p>
<p>以前置通知为例，看一下MethodBeforeAdviceInterceptor拦截器中的invoke方法的执行逻辑：</p>
<ol>
<li>前置通知是在目标方法执行之前执行的方法，所以先调用了invokeAdviceMethod执行了前置通知方法</li>
<li>调用MethodInvocation的proceed执行下一个拦截器链，在上一步中可以看到调用拦截器时传入的是this，this指向ReflectiveMethodInvocation，所以会继续执行到它的proceed方法，继续下一个拦截器的执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">BeforeAdvice</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 先执行通知方法，在AspectJMethodBeforeAdvice中实现</span></span><br><span class="line">        <span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">        <span class="comment">// 执行拦截器链，这里调用的是MethodInvocation的proceed方法，会再次进入到ReflectiveMethodInvocation的proceed方法中</span></span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AspectJMethodBeforeAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJMethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, @Nullable Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 执行通知方法</span></span><br><span class="line">        invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AspectJAroundAdvice</strong></p>
<p>再以环绕通知为例，看一下环绕通知的执行逻辑，AspectJAroundAdvice实现了MethodInterceptor接口，所以它本身就是一个拦截器，在invoke方法中它调用了invokeAdviceMethod执行通知方法，<strong>并将ReflectiveMethodInvocation转换为ProceedingJoinPoint，在环绕通知中通过ProceedingJoinPoint调用proceed方法执行下一个拦截器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAroundAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(mi <span class="keyword">instanceof</span> ProxyMethodInvocation)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"MethodInvocation is not a Spring ProxyMethodInvocation: "</span> + mi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mi是上一步中传入的ReflectiveMethodInvocation，这里将其转换为ProxyMethodInvocation</span></span><br><span class="line">        ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;</span><br><span class="line">        <span class="comment">// 将ProxyMethodInvocation转为ProceedingJoinPoint</span></span><br><span class="line">        ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);</span><br><span class="line">        JoinPointMatch jpm = getJoinPointMatch(pmi);</span><br><span class="line">        <span class="comment">// 执行通知方法</span></span><br><span class="line">        <span class="keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAspectJAdvice</span> <span class="keyword">implements</span> <span class="title">Advice</span>, <span class="title">AspectJPrecedenceInformation</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行通知方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethod</span><span class="params">(JoinPoint jp, @Nullable JoinPointMatch jpMatch,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        @Nullable Object returnValue, @Nullable Throwable t)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 通过给定的参数执行通知方法</span></span><br><span class="line">        <span class="keyword">return</span> invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过给定的参数执行通知方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethodWithGivenArgs</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] actualArgs = args;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdviceMethod.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">            actualArgs = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReflectionUtils.makeAccessible(<span class="keyword">this</span>.aspectJAdviceMethod);</span><br><span class="line">            <span class="comment">// 这里执行了通知方法,接下来会进入到定义的环绕通知方法中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.aspectJAdviceMethod.invoke(<span class="keyword">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Mismatch on arguments to advice method ["</span> +</span><br><span class="line">                    <span class="keyword">this</span>.aspectJAdviceMethod + <span class="string">"]; pointcut expression ["</span> +</span><br><span class="line">                    <span class="keyword">this</span>.pointcut.getPointcutExpression() + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设定义了如下的环绕通知，在环绕通知方法被执行时，会进入到logAroudAdvice方法中，可以看到先打印了方法执行前的日志，然后调用了ProceedingJoinPoint的proceed方法执行拦截器链，上一步可知ProceedingJoinPoint是MethodInvocation转换而来，所以又会进入到ReflectiveMethodInvocation的proceed方法执行下一个拦截器链，待所有的拦截器执行完毕后proceed方法也就结束，然后执行了printAfterLog打印方法执行后的日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知Advice，这里使用了环绕通知</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> joinPoint 连接点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"logPoiontcut()"</span>) <span class="comment">// 引用切点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">logAroudAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 方法执行前的日志打印</span></span><br><span class="line">    printBeforeLog(joinPoint);</span><br><span class="line">    <span class="comment">// 执行拦截器链</span></span><br><span class="line">    Object returnValue = joinPoint.proceed();</span><br><span class="line">    <span class="comment">// 方法执行后的日志打印</span></span><br><span class="line">    printAfterLog(returnValue);</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>方法拦截器链的执行流程图</strong><br><img src="/images/aop执行流程.jpeg" alt=""></p>
<p><strong>AOP总结</strong></p>
<p><img src="/images/AOP总结二.png" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://blog.csdn.net/qq_36882793/article/details/106440723" target="_blank" rel="noopener">【猫吻鱼】Spring源码分析：全集整理</a></p>
<p><strong>Spring版本：5.2.5.RELEASE</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/19/【Spring】AOP实现原理（二）：Advisor获取（基于注解）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/19/【Spring】AOP实现原理（二）：Advisor获取（基于注解）/" itemprop="url">【Spring】AOP实现原理（二）：Advisor获取（基于注解）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-19T21:00:00+08:00">
                2022-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h1><p>@EnableAspectJAutoProxy注解可以用来开启AOP，那么就从@EnableAspectJAutoProxy入手学习一下Spring AOP的实现原理。</p>
<ol>
<li>@EnableAspectJAutoProxy导入了AspectJAutoProxyRegistrar。</li>
<li>定义了proxyTargetClass属性，表示是否使用CGLIB生成代理对象，默认返回false，默认是使用JDK动态代理创建代理对象的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(AspectJAutoProxyRegistrar.class)<span class="comment">// 导入了AspectJAutoProxyRegistrar</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否使用CGLIB生成代理对象，默认为false，默认是使用JDK动态代理创建代理对象的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否暴露代理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AspectJAutoProxyRegistrar"><a href="#AspectJAutoProxyRegistrar" class="headerlink" title="AspectJAutoProxyRegistrar"></a>AspectJAutoProxyRegistrar</h1><p>AspectJAutoProxyRegistrar是一个代理注册器，它实现了ImportBeanDefinitionRegistrar接口，<strong>ImportBeanDefinitionRegistrar可以向容器中注册bean，AspectJAutoProxyRegistrar实现了它应该是为了向容器中注册bean，那么看一下registerBeanDefinitions方法里面注册了什么</strong>。</p>
<p>在registerBeanDefinitions方法中它调用了AopConfigUtils的registerAspectJAnnotationAutoProxyCreatorIfNecessary方法<strong>向容器中注册了自动代理创建器，通过名称可以看出它与AspectJ注解以及代理创建有关</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AspectJ自动代理注册器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册BeanDefinitions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向容器中注册代理创建器</span></span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">        AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取proxyTargetClass</span></span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"proxyTargetClass"</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取exposeProxy</span></span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"exposeProxy"</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注册自动代理创建器"><a href="#注册自动代理创建器" class="headerlink" title="注册自动代理创建器"></a>注册自动代理创建器</h2><p>registerAspectJAnnotationAutoProxyCreatorIfNecessary在AopConfigUtils中实现：</p>
<ol>
<li>定义了一个自动代理创建器集合，是一个List，List里面的存储顺序代表了优先级，一共有三种代理创建器<ul>
<li>InfrastructureAdvisorAutoProxyCreator：优先级最低</li>
<li>AspectJAwareAdvisorAutoProxyCreator：优先级较InfrastructureAdvisorAutoProxyCreator高</li>
<li>AnnotationAwareAspectJAutoProxyCreator：优先级最高</li>
</ul>
</li>
<li><strong>Spring AOP默认使用的是AnnotationAwareAspectJAutoProxyCreator类型的创建器</strong>，向容器中注册的时候会判断容器中是否已经存在代理创建器：<ul>
<li>如果已经存在，从容器中取出创建器，判断优先级是否比AnnotationAwareAspectJAutoProxyCreator高，如果低于AnnotationAwareAspectJAutoProxyCreator，则使用AnnotationAwareAspectJAutoProxyCreator进行替换。</li>
<li>如果不存在，直接向容器中注册AnnotationAwareAspectJAutoProxyCreator类型的bean即可。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AopConfigUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动代理创建器beanName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTO_PROXY_CREATOR_BEAN_NAME =</span><br><span class="line">            <span class="string">"org.springframework.aop.config.internalAutoProxyCreator"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动创建器集合，是一个List，List里面的存储顺序代表了优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 向List中添加具体的代理创建器</span></span><br><span class="line">        APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">        APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);</span><br><span class="line">        APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用下面的registerAspectJAnnotationAutoProxyCreatorIfNecessary方法</span></span><br><span class="line">        <span class="keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里可以看到，注册的是AnnotationAwareAspectJAutoProxyCreator类型的</span></span><br><span class="line">        <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">        <span class="comment">// 如果容器中已经包含名称为AUTO_PROXY_CREATOR_BEAN_NAME的bean</span></span><br><span class="line">        <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">            <span class="comment">// 从容器中获取</span></span><br><span class="line">            BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">            <span class="comment">// 如果当前要注册的bean与容器中已经存在的bean类型不一致</span></span><br><span class="line">            <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">                <span class="comment">// 获取容器中存在的bean的优先级</span></span><br><span class="line">                <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">                <span class="comment">// 获取要注册的bean的优先级</span></span><br><span class="line">                <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">                <span class="comment">// 容器中存在的bean的优先级比当前要注册的低</span></span><br><span class="line">                <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                    <span class="comment">// 使用当的class进行注册，也就是AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">                    apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建BeanDefinition</span></span><br><span class="line">        RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">        beanDefinition.setSource(source);</span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        <span class="comment">// 向容器中注册</span></span><br><span class="line">        registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AbstractAutoProxyCreator"><a href="#AbstractAutoProxyCreator" class="headerlink" title="AbstractAutoProxyCreator"></a>AbstractAutoProxyCreator</h1><p>自动代理创建器AbstractAutoProxyCreator用于创建代理对象，Spring AOP使用的是AnnotationAwareAspectJAutoProxyCreator类型的创建器，它是AbstractAutoProxyCreator的子类，继承关系如下：<br><img src="/images/aopproxycreator.png" alt=""></p>
<p>AnnotationAwareAspectJAutoProxyCreator的主要方法都在AbstractAutoProxyCreator中实现，AbstractAutoProxyCreator实现了SmartInstantiationAwareBeanPostProcessor，它是Spring的Bean后置处理器，后置处理器有两个比较重要的方法：</p>
<p><strong>postProcessBeforeInstantiation</strong>：在bean<strong>实例化</strong>之前执行的方法，如果有自定义的TargetSource则在这个时候就创建代理对象，可以先不管这里，主要看postProcessAfterInitialization方法。</p>
<p><strong>postProcessAfterInitialization：在bean初始化之后执行的方法，这时候bean已经实例化完毕但是还没有设置属性等信息，调用了wrapIfNecessary方法判断是否有必要生成代理对象，如果不需要创建代理对象直接返回即可，反之需要调用getAdvicesAndAdvisorsForBean获取Advice和Advisor，然后创建代理对象。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在bean实例化之前执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">        Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有自定义的TargetSource则创建代理对象</span></span><br><span class="line">        TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">            <span class="comment">// 创建代理对象</span></span><br><span class="line">            Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">            <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在bean初始化之后执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 构建缓存Key</span></span><br><span class="line">            Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">                <span class="comment">// 是否有必要创建代理</span></span><br><span class="line">                <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有必要生成代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是基础类或者需要跳过则不创建代理对象,将bean加入到advisedBeans中即可</span></span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取bean的Advices和Advisors</span></span><br><span class="line">        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">            <span class="comment">// 创建代理</span></span><br><span class="line">            Object proxy = createProxy(</span><br><span class="line">                    bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">            <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳过代理对象创建的判断"><a href="#跳过代理对象创建的判断" class="headerlink" title="跳过代理对象创建的判断"></a>跳过代理对象创建的判断</h2><p>跳过代理对象的创建主要通过以下两个方法判断的：</p>
<p><strong>1.调用isInfrastructureClass判断是否是基础类，如果是则跳过代理创建。</strong></p>
<p><strong>2.调用shouldSkip方法判断是否需要跳过创建代理。</strong></p>
<h3 id="isInfrastructureClass"><a href="#isInfrastructureClass" class="headerlink" title="isInfrastructureClass"></a>isInfrastructureClass</h3><p>需要注意AOP使用的是AnnotationAwareAspectJAutoProxyCreator作为代理创建器，所以需要先看AnnotationAwareAspectJAutoProxyCreator是否重写了该方法，实际上它确实重写isInfrastructureClass方法，在里面它调用了父类的AbstractAutoProxyCreator的isInfrastructureClass和aspectJAdvisorFactory的isAspect进行判断：</p>
<ul>
<li>isInfrastructureClass：<strong>如果是Advice、Pointcut、Advisor、AopInfrastructureBean及其子类则跳过创建</strong>，这些是Spring的基础类，不需要进行代理。</li>
<li>isAspect：是否有Aspect注解并且不是通过Ajc编译的类则是一个切面。</li>
</ul>
<p><strong>总结：如果是Advice、Pointcut、Advisor、AopInfrastructureBean及其子类或者bean是一个切面并且不是通过Ajc编译的则跳过代理创建，并将当前bean的缓存key加入到advisedBeans中（wrapIfNecessary中可以看到）。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用AbstractAutoProxyCreator的isInfrastructureClass和aspectJAdvisorFactory的isAspect方法判断,在AbstractAspectJAdvisorFactory中有实现</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">super</span>.isInfrastructureClass(beanClass) ||</span><br><span class="line">                (<span class="keyword">this</span>.aspectJAdvisorFactory != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.aspectJAdvisorFactory.isAspect(beanClass)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutoProxyCreator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是基础类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是Advice、Pointcut、Advisor、AopInfrastructureBean类型</span></span><br><span class="line">        <span class="keyword">boolean</span> retVal = Advice.class.isAssignableFrom(beanClass) ||</span><br><span class="line">                Pointcut.class.isAssignableFrom(beanClass) ||</span><br><span class="line">                Advisor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">                AopInfrastructureBean.class.isAssignableFrom(beanClass);</span><br><span class="line">        <span class="keyword">if</span> (retVal &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Did not attempt to auto-proxy infrastructure class ["</span> + beanClass.getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAspectJAdvisorFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAspectJAdvisorFactory</span> <span class="keyword">implements</span> <span class="title">AspectJAdvisorFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是切面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAspect</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否有Aspect注解并且不是通过Ajc编译的类</span></span><br><span class="line">        <span class="keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否有Aspect注解</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasAspectAnnotation</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否有Aspect注解</span></span><br><span class="line">        <span class="keyword">return</span> (AnnotationUtils.findAnnotation(clazz, Aspect.class) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否通过Ajc编译</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compiledByAjc</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Field field : clazz.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.getName().startsWith(AJC_MAGIC)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shouldSkip"><a href="#shouldSkip" class="headerlink" title="shouldSkip"></a>shouldSkip</h3><p>AnnotationAwareAspectJAutoProxyCreator中重写的shouldSkip方法具体实现在父类AspectJAwareAdvisorAutoProxyCreator里面，它获取所有候选的Advisor进行遍历，<strong>判断Advisor是否是AspectJPointcutAdvisor类型并且当前的bean与advisor的AspectName切面名称一致则跳过代理创建：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否跳过代理创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取候选的Advisors</span></span><br><span class="line">        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">        <span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line">            <span class="comment">// 如果是AspectJPointcutAdvisor类型并且当前的bean与advisor的AspectName切面名称一致，则跳过代理创建</span></span><br><span class="line">            <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;</span><br><span class="line">                    ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用父类的shouldSkip判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取所有的Advice和Advisor"><a href="#获取所有的Advice和Advisor" class="headerlink" title="获取所有的Advice和Advisor"></a>获取所有的Advice和Advisor</h2><p>getAdvicesAndAdvisorsForBean方法在AbstractAdvisorAutoProxyCreator中实现，它又调用了findEligibleAdvisors方法获取所有可应用到当前bean的Advisors：</p>
<ol>
<li><strong>调用findCandidateAdvisors获取所有候选的Advisor</strong>，需要注意的是虽然AbstractAdvisorAutoProxyCreator类中实现了findCandidateAdvisors，但是<strong>向容器中注册代理创建器实际的类型是AnnotationAwareAspectJAutoProxyCreator</strong>，它重写了findCandidateAdvisors方法，所以会先进入AnnotationAwareAspectJAutoProxyCreator的findCandidateAdvisors方法，它里面又调用了父类的findCandidateAdvisors，这时候才会进入AbstractAdvisorAutoProxyCreator的方法。</li>
<li><strong>从所有候选的Advisor中过滤出可以适用于当前bean的Advisor</strong>，findAdvisorsThatCanApply具体实现逻辑在AopUtils中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAutoProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">            Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line">        <span class="comment">// 调用findEligibleAdvisors获取Advisor</span></span><br><span class="line">        List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Advisor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取所有的Advisor，需要注意实际的类型是AnnotationAwareAspectJAutoProxyCreator，所以会先进入它的findCandidateAdvisors方法中</span></span><br><span class="line">        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">        <span class="comment">// 2.获取可以应用到当前bean的Advisor</span></span><br><span class="line">        List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">        extendAdvisors(eligibleAdvisors);</span><br><span class="line">        <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">            eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AbstractAutoProxyCreator中获取所有候选的Advisors方法，AnnotationAwareAspectJAutoProxyCreator中重写的findCandidateAdvisors会调用这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.state(<span class="keyword">this</span>.advisorRetrievalHelper != <span class="keyword">null</span>, <span class="string">"No BeanFactoryAdvisorRetrievalHelper available"</span>);</span><br><span class="line">        <span class="comment">// 具体的实现逻辑在advisorRetrievalHelper的findAdvisorBeans</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.advisorRetrievalHelper.findAdvisorBeans();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取可以应用到当前bean的Advisor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取可以应用到当前bean的Advisor</span></span><br><span class="line">            <span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="findCandidateAdvisors获取所有候选的Advisors"><a href="#findCandidateAdvisors获取所有候选的Advisors" class="headerlink" title="findCandidateAdvisors获取所有候选的Advisors"></a>findCandidateAdvisors获取所有候选的Advisors</h3><p>AOP使用的是的AnnotationAwareAspectJAutoProxyCreator类型的创建器，它重写了findCandidateAdvisors方法，方法的处理逻辑如下：</p>
<ul>
<li><p><strong>调用了父类的findCandidateAdvisors方法获取候选的Advisors，也就是AbstractAdvisorAutoProxyCreator中实现的findCandidateAdvisors方法，这里的Advisors指的是本身是Advisor类型的bean。</strong></p>
</li>
<li><p><strong>调用了buildAspectJAdvisors方法构建Advisors</strong>，具体的实现在BeanFactoryAspectJAdvisorsBuilder中， <strong>这里的Advisors指的是使用了@AspectJ注解定义的切面，Spring会把它包装成Advisor。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Advisors构建工厂</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> BeanFactoryAspectJAdvisorsBuilder aspectJAdvisorsBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.initBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为空使用ReflectiveAspectJAdvisorFactory</span></span><br><span class="line">            <span class="keyword">this</span>.aspectJAdvisorFactory = <span class="keyword">new</span> ReflectiveAspectJAdvisorFactory(beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化BeanFactoryAspectJAdvisorsBuilder,这里使用的BeanFactoryAspectJAdvisorsBuilderAdapter</span></span><br><span class="line">        <span class="keyword">this</span>.aspectJAdvisorsBuilder =</span><br><span class="line">                <span class="keyword">new</span> BeanFactoryAspectJAdvisorsBuilderAdapter(beanFactory, <span class="keyword">this</span>.aspectJAdvisorFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.调用父类的findCandidateAdvisors获取所有的Advisors，也就是AbstractAdvisorAutoProxyCreator中实现的findCandidateAdvisors方法</span></span><br><span class="line">        List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.构建Advisors，具体实现在BeanFactoryAspectJAdvisorsBuilder中</span></span><br><span class="line">            advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> advisors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractAdvisorAutoProxyCreator</span></span><br><span class="line"><span class="comment"> * 它是实现了findCandidateAdvisors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAutoProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> BeanFactoryAdvisorRetrievalHelper advisorRetrievalHelper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用的BeanFactoryAdvisorRetrievalHelperAdapter</span></span><br><span class="line">        <span class="keyword">this</span>.advisorRetrievalHelper = <span class="keyword">new</span> BeanFactoryAdvisorRetrievalHelperAdapter(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有的候选Advisors</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the List of candidate Advisors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.state(<span class="keyword">this</span>.advisorRetrievalHelper != <span class="keyword">null</span>, <span class="string">"No BeanFactoryAdvisorRetrievalHelper available"</span>);</span><br><span class="line">        <span class="comment">// 获取候选的Advisor，具体的实现逻辑在advisorRetrievalHelper的findAdvisorBeans</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.advisorRetrievalHelper.findAdvisorBeans();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-findCandidateAdvisors获取候选的Advisors"><a href="#1-findCandidateAdvisors获取候选的Advisors" class="headerlink" title="1. findCandidateAdvisors获取候选的Advisors"></a>1. findCandidateAdvisors获取候选的Advisors</h4><p>findCandidateAdvisors方法具体的实现在BeanFactoryAdvisorRetrievalHelper中，<strong>它从beanFactory中获取了所有Advisor类型的bean</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryAdvisorRetrievalHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在当前的bean工厂中查找所有Advisor类型的bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">findAdvisorBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取缓存的AdvisorBeanName</span></span><br><span class="line">        String[] advisorNames = <span class="keyword">this</span>.cachedAdvisorBeanNames;</span><br><span class="line">        <span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                    <span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果未获取到</span></span><br><span class="line">        <span class="keyword">if</span> (advisorNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有的advisorNames</span></span><br><span class="line">        <span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line">                <span class="comment">// 如果bean正在创建中</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">"Skipping currently created advisor '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 从容器中获取实例，可以看到这里获取的是Advisor类型的bean</span></span><br><span class="line">                        advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                        <span class="comment">// 省略了异常处理</span></span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> advisors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-buildAspectJAdvisors构建Advisor"><a href="#2-buildAspectJAdvisors构建Advisor" class="headerlink" title="2. buildAspectJAdvisors构建Advisor"></a>2. buildAspectJAdvisors构建Advisor</h4><p>buildAspectJAdvisors在BeanFactoryAspectJAdvisorsBuilder中实现，<strong>这一步用于查找所有使用@AspectJ注解的bean，并将其包装成Advisor返回</strong>:</p>
<p>（1）从容器中获取所有的bean，调用isEligibleBean方法判断bean是否符合要求，如果符合进入下一步</p>
<p>（2）调用isAspect方法判断bean是否是一个切面，如果是进入下一步</p>
<p>（3）判断是否是单例模式</p>
<ul>
<li>如果是，创建BeanFactoryAspectInstanceFactory类型的工厂，调用<strong>AspectJAdvisorFactory的getAdvisors方法获取Advisor</strong></li>
<li>如果不是单例模式，创建PrototypeAspectInstanceFactory类型的工厂，调用AspectJAdvisorFactory的getAdvisors方法获取Advisor</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryAspectJAdvisorsBuilder</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> AspectJAdvisorFactory advisorFactory;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  在当前bean工厂中查找所有使用<span class="doctag">@AspectJ</span>注解的bean，并包装成Advisor返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">buildAspectJAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取所有的切面beanName</span></span><br><span class="line">        List&lt;String&gt; aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">        <span class="comment">// 如果为空</span></span><br><span class="line">        <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">                <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    aspectNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="comment">// 从容器中获取所有的beanName</span></span><br><span class="line">                    String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                            <span class="keyword">this</span>.beanFactory, Object.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                        <span class="comment">// 判断是否符合条件，BeanFactoryAspectJAdvisorsBuilderAdapter中实现</span></span><br><span class="line">                        <span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 根据BeanName获取class类型</span></span><br><span class="line">                        Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 是否是切面</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">                            <span class="comment">// 添加到aspectNames</span></span><br><span class="line">                            aspectNames.add(beanName);</span><br><span class="line">                            <span class="comment">// 创建Aspect元数据信息</span></span><br><span class="line">                            AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line">                            <span class="comment">// 单例模式</span></span><br><span class="line">                            <span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">                                <span class="comment">// 创建MetadataAwareAspectInstanceFactory</span></span><br><span class="line">                                MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                                        <span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                                <span class="comment">// 获取Advisor</span></span><br><span class="line">                                List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">                                <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                                    <span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                                &#125;</span><br><span class="line">                                advisors.addAll(classAdvisors);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 原型模式</span></span><br><span class="line">                                <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">                                            <span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                                        <span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                                <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                                advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">                    <span class="keyword">return</span> advisors;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">            List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">            <span class="keyword">if</span> (cachedAdvisors != <span class="keyword">null</span>) &#123;</span><br><span class="line">                advisors.addAll(cachedAdvisors);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">                advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> advisors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="isEligibleBean的判断"><a href="#isEligibleBean的判断" class="headerlink" title="isEligibleBean的判断"></a>isEligibleBean的判断</h5><p><img src="/images/BeanFactoryAspectJAdvisorsBuilderAdapter.png" alt=""></p>
<p>BeanFactoryAspectJAdvisorsBuilderAdapter是AnnotationAwareAspectJAutoProxyCreator的内部类，它继承了BeanFactoryAspectJAdvisorsBuilder并重写了isEligibleBean方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryAspectJAdvisorsBuilderAdapter</span> <span class="keyword">extends</span> <span class="title">BeanFactoryAspectJAdvisorsBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEligibleBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用isEligibleAspectBean</span></span><br><span class="line">            <span class="keyword">return</span> AnnotationAwareAspectJAutoProxyCreator.<span class="keyword">this</span>.isEligibleAspectBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验给定的切面是否符合要求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEligibleAspectBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.includePatterns == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pattern pattern : <span class="keyword">this</span>.includePatterns) &#123;</span><br><span class="line">                <span class="comment">// 通过includePatterns进行匹配</span></span><br><span class="line">                <span class="keyword">if</span> (pattern.matcher(beanName).matches()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="isAspect的判断"><a href="#isAspect的判断" class="headerlink" title="isAspect的判断"></a>isAspect的判断</h5><p>前面在讲跳过代理对象的创建时已经看到isAspect的实现逻辑，如果使用了Aspect注解并且不是通过Ajc进行编译的，则判定为切面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAspectJAdvisorFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAspectJAdvisorFactory</span> <span class="keyword">implements</span> <span class="title">AspectJAdvisorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是切面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAspect</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否有Aspect注解并且不是通过Ajc编译的类</span></span><br><span class="line">        <span class="keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否有Aspect注解</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasAspectAnnotation</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否有Aspect注解</span></span><br><span class="line">        <span class="keyword">return</span> (AnnotationUtils.findAnnotation(clazz, Aspect.class) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否通过Ajc编译</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compiledByAjc</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span> (Field field : clazz.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.getName().startsWith(AJC_MAGIC)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="AspectJAdvisorFactory获取Advisor"><a href="#AspectJAdvisorFactory获取Advisor" class="headerlink" title="AspectJAdvisorFactory获取Advisor"></a>AspectJAdvisorFactory获取Advisor</h5><p>AspectJAdvisorFactory是一个Advisor工厂，它的继承关系如下：</p>
<p><img src="/images/AspectJAdvisorFactory.png" alt=""></p>
<p>AnnotationAwareAspectJAutoProxyCreator在初始化bean工厂的方法中，对AspectJAdvisorFactory进行了判断，则如果为空使用ReflectiveAspectJAdvisorFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Advisors构建工厂</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> BeanFactoryAspectJAdvisorsBuilder aspectJAdvisorsBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.initBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为空使用ReflectiveAspectJAdvisorFactory</span></span><br><span class="line">            <span class="keyword">this</span>.aspectJAdvisorFactory = <span class="keyword">new</span> ReflectiveAspectJAdvisorFactory(beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化BeanFactoryAspectJAdvisorsBuilder</span></span><br><span class="line">        <span class="keyword">this</span>.aspectJAdvisorsBuilder =</span><br><span class="line">                <span class="keyword">new</span> BeanFactoryAspectJAdvisorsBuilderAdapter(beanFactory, <span class="keyword">this</span>.aspectJAdvisorFactory);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReflectiveAspectJAdvisorFactory中实现了getAdvisor方法：</p>
<ol>
<li>getAdvisorMethods获取Advisor方法（也就是获取通知），具体是<strong>根据方法上是否有Pointcut注解来判断的，如果没有Pointcut注解则判定为是Advisor方法</strong></li>
<li>调用getAdvisor方法将第1步中获取到的Advisor方法构建为Advisor对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveAspectJAdvisorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvisorFactory</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Aspect类信息</span></span><br><span class="line">        Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">        String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">        validate(aspectClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  装饰模式</span></span><br><span class="line">        MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line">                <span class="keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line"></span><br><span class="line">        List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取Advisor方法，也就是获取没有使用@Pointcut注解的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">            <span class="comment">// 将方法构建为Advisor对象</span></span><br><span class="line">            Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">            <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                advisors.add(advisor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If it's a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class="line">        <span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">            Advisor instantiationAdvisor = <span class="keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span><br><span class="line">            advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find introduction fields.</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">            Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line">            <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                advisors.add(advisor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> advisors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Advisor方法，也就是获取切面中没有被使用Pointcut注解的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Method&gt; <span class="title">getAdvisorMethods</span><span class="params">(Class&lt;?&gt; aspectClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ReflectionUtils.doWithMethods(aspectClass, method -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断是否有Pointcut注解，如果没有则判定为是Advisor方法加入结果集中</span></span><br><span class="line">            <span class="keyword">if</span> (AnnotationUtils.getAnnotation(method, Pointcut.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                methods.add(method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, ReflectionUtils.USER_DECLARED_METHODS);</span><br><span class="line">        <span class="keyword">if</span> (methods.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            methods.sort(METHOD_COMPARATOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="构建Advisor的具体实现"><a href="#构建Advisor的具体实现" class="headerlink" title="构建Advisor的具体实现"></a>构建Advisor的具体实现</h5><p>ReflectiveAspectJAdvisorFactory的getAdvisor方法用于将方法封装为Advisor对象，可以看到第一个参数叫candidateAdviceMethod（候选的通知方法），上一步中传入的是获取到的Advisor方法，<strong>所以Spring中Advisor方法指的就是使用了通知注解的方法</strong>，getAdvisor方法主要做了如下操作：</p>
<ol>
<li>构建AspectJExpressionPointcut切点表达式对象<ul>
<li>从通知方法上获取切面相关注解，具体是通过判断方法上是否有Pointcut、Around、Before、After、AfterReturning、AfterThrowing注解实现的</li>
<li>从切面注解中获取设置的切点表达式，用于之后判断方法是否匹配使用，然后创建AspectJExpressionPointcut对象并设置获取到的切点表达式</li>
</ul>
</li>
<li>将当前的Advisor方法、AspectJExpressionPointcut对象等信息封装为InstantiationModelAwarePointcutAdvisorImpl返回，它是一个Advisor</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveAspectJAdvisorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvisorFactory</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Advisor方法构建为Advisor对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advisor <span class="title">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">        <span class="comment">// 获取切点</span></span><br><span class="line">        AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class="line">                candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">        <span class="keyword">if</span> (expressionPointcut == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装为InstantiationModelAwarePointcutAdvisorImpl</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class="line">                <span class="keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取切点表达式</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AspectJExpressionPointcut <span class="title">getPointcut</span><span class="params">(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取AspectJ注解，具体是通过判断方法上是否有Pointcut、Around、Before、After、AfterReturning、AfterThrowing注解实现的</span></span><br><span class="line">        AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">        <span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建AspectJExpressionPointcut</span></span><br><span class="line">        AspectJExpressionPointcut ajexp =</span><br><span class="line">                <span class="keyword">new</span> AspectJExpressionPointcut(candidateAspectClass, <span class="keyword">new</span> String[<span class="number">0</span>], <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 设置切点表达式</span></span><br><span class="line">        ajexp.setExpression(aspectJAnnotation.getPointcutExpression());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ajexp.setBeanFactory(<span class="keyword">this</span>.beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ajexp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAspectJAdvisorFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAspectJAdvisorFactory</span> <span class="keyword">implements</span> <span class="title">AspectJAdvisorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] ASPECTJ_ANNOTATION_CLASSES = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;</span><br><span class="line">            Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有AspectJ相关注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;</span><br><span class="line">        <span class="comment">// 判断方法上是否有Pointcut、Around、Before、After、AfterReturning、AfterThrowing注解</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : ASPECTJ_ANNOTATION_CLASSES) &#123;</span><br><span class="line">            AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) clazz);</span><br><span class="line">            <span class="keyword">if</span> (foundAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> foundAnnotation;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>InstantiationModelAwarePointcutAdvisorImpl封装切面</strong></p>
<p>InstantiationModelAwarePointcutAdvisorImpl是一个Adviosr，它对Aspect切面进行了封装，里面引用了Advice、Pointcut等切面相关信息，在构造函数的最后，调用了instantiateAdvice对通知进行增强处理，也就是根据不同的通知类型，将其包装为不同的Advice对象，具体的实现在ReflectiveAspectJAdvisorFactory中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiationModelAwarePointcutAdvisorImpl</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">InstantiationModelAwarePointcutAdvisor</span>, <span class="title">AspectJPrecedenceInformation</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 切点表达式，用于匹配方法是否需要进行拦截</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AspectJExpressionPointcut declaredPointcut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Method aspectJAdviceMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AspectJAdvisorFactory</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AspectJAdvisorFactory aspectJAdvisorFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MetadataAwareAspectInstanceFactory aspectInstanceFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> declarationOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切面名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String aspectName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Pointcut pointcut; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> lazy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Advice instantiatedAdvice; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isBeforeAdvice;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isAfterAdvice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstantiationModelAwarePointcutAdvisorImpl</span><span class="params">(AspectJExpressionPointcut declaredPointcut,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.declaredPointcut = declaredPointcut;</span><br><span class="line">        <span class="comment">// 设置切面的类信息</span></span><br><span class="line">        <span class="keyword">this</span>.declaringClass = aspectJAdviceMethod.getDeclaringClass();</span><br><span class="line">        <span class="comment">// 设置方法名称</span></span><br><span class="line">        <span class="keyword">this</span>.methodName = aspectJAdviceMethod.getName();</span><br><span class="line">        <span class="keyword">this</span>.parameterTypes = aspectJAdviceMethod.getParameterTypes();</span><br><span class="line">        <span class="comment">// 通知</span></span><br><span class="line">        <span class="keyword">this</span>.aspectJAdviceMethod = aspectJAdviceMethod;</span><br><span class="line">        <span class="comment">// AspectJAdvisorFactory</span></span><br><span class="line">        <span class="keyword">this</span>.aspectJAdvisorFactory = aspectJAdvisorFactory;</span><br><span class="line">        <span class="keyword">this</span>.aspectInstanceFactory = aspectInstanceFactory;</span><br><span class="line">        <span class="keyword">this</span>.declarationOrder = declarationOrder;</span><br><span class="line">        <span class="comment">// 切面名称</span></span><br><span class="line">        <span class="keyword">this</span>.aspectName = aspectName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">            Pointcut preInstantiationPointcut = Pointcuts.union(</span><br><span class="line">                    aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), <span class="keyword">this</span>.declaredPointcut);</span><br><span class="line">            <span class="keyword">this</span>.pointcut = <span class="keyword">new</span> PerTargetInstantiationModelPointcut(</span><br><span class="line">                    <span class="keyword">this</span>.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);</span><br><span class="line">            <span class="keyword">this</span>.lazy = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// A singleton aspect.</span></span><br><span class="line">            <span class="keyword">this</span>.pointcut = <span class="keyword">this</span>.declaredPointcut;</span><br><span class="line">            <span class="keyword">this</span>.lazy = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 增强处理</span></span><br><span class="line">            <span class="keyword">this</span>.instantiatedAdvice = instantiateAdvice(<span class="keyword">this</span>.declaredPointcut);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Advice <span class="title">instantiateAdvice</span><span class="params">(AspectJExpressionPointcut pointcut)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用ReflectiveAspectJAdvisorFactory获取Advice</span></span><br><span class="line">        Advice advice = <span class="keyword">this</span>.aspectJAdvisorFactory.getAdvice(<span class="keyword">this</span>.aspectJAdviceMethod, pointcut,</span><br><span class="line">                <span class="keyword">this</span>.aspectInstanceFactory, <span class="keyword">this</span>.declarationOrder, <span class="keyword">this</span>.aspectName);</span><br><span class="line">        <span class="keyword">return</span> (advice != <span class="keyword">null</span> ? advice : EMPTY_ADVICE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ReflectiveAspectJAdvisorFactory</strong></p>
<p>ReflectiveAspectJAdvisorFactory中的getAdvice方法中可以看到对通知进行了判断，不同的通知使用不同的包装类：</p>
<ul>
<li>环绕通知，使用AspectJAroundAdvice</li>
<li>前置通知，使用AspectJMethodBeforeAdvice</li>
<li>后置通知，使用AspectJAfterAdvice</li>
<li>返回通知，使用AspectJAfterReturningAdvice</li>
<li>异常通知，使用AspectJAfterThrowingAdvice</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveAspectJAdvisorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvisorFactory</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,</span></span></span><br><span class="line"><span class="function"><span class="params">                            MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">        validate(candidateAspectClass);</span><br><span class="line">        <span class="comment">// 获取AspectJAnnotation</span></span><br><span class="line">        AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">        <span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次校验是否是切面</span></span><br><span class="line">        <span class="keyword">if</span> (!isAspect(candidateAspectClass)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Advice must be declared inside an aspect type: "</span> +</span><br><span class="line">                    <span class="string">"Offending method '"</span> + candidateAdviceMethod + <span class="string">"' in class ["</span> +</span><br><span class="line">                    candidateAspectClass.getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Found AspectJ method: "</span> + candidateAdviceMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AbstractAspectJAdvice springAdvice;</span><br><span class="line">        <span class="comment">// 判断通知类型</span></span><br><span class="line">        <span class="keyword">switch</span> (aspectJAnnotation.getAnnotationType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> AtPointcut: <span class="comment">// 如果是一个切点</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Processing pointcut '"</span> + candidateAdviceMethod.getName() + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAround: <span class="comment">// 环绕通知，使用AspectJAroundAdvice封装</span></span><br><span class="line">                springAdvice = <span class="keyword">new</span> AspectJAroundAdvice(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtBefore:<span class="comment">// 前置通知，使用AspectJMethodBeforeAdvice</span></span><br><span class="line">                springAdvice = <span class="keyword">new</span> AspectJMethodBeforeAdvice(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAfter:<span class="comment">// 后置通知，使用AspectJAfterAdvice</span></span><br><span class="line">                springAdvice = <span class="keyword">new</span> AspectJAfterAdvice(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAfterReturning:<span class="comment">// 返回通知，使用AspectJAfterReturningAdvice</span></span><br><span class="line">                springAdvice = <span class="keyword">new</span> AspectJAfterReturningAdvice(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;</span><br><span class="line">                    springAdvice.setReturningName(afterReturningAnnotation.returning());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAfterThrowing:<span class="comment">// 异常通知，使用AspectJAfterThrowingAdvice</span></span><br><span class="line">                springAdvice = <span class="keyword">new</span> AspectJAfterThrowingAdvice(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;</span><br><span class="line">                    springAdvice.setThrowingName(afterThrowingAnnotation.throwing());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">                        <span class="string">"Unsupported advice type on method: "</span> + candidateAdviceMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now to configure the advice...</span></span><br><span class="line">        springAdvice.setAspectName(aspectName);</span><br><span class="line">        springAdvice.setDeclarationOrder(declarationOrder);</span><br><span class="line">        String[] argNames = <span class="keyword">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class="line">        <span class="keyword">if</span> (argNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class="line">        &#125;</span><br><span class="line">        springAdvice.calculateArgumentBindings();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> springAdvice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="findAdvisorsThatCanApply获取可以应用到当前bean的Advisor"><a href="#findAdvisorsThatCanApply获取可以应用到当前bean的Advisor" class="headerlink" title="findAdvisorsThatCanApply获取可以应用到当前bean的Advisor"></a>findAdvisorsThatCanApply获取可以应用到当前bean的Advisor</h3><p>上一节中获取到了所有的Advisor，接下来要过滤出可以应用到当前bean的Advisor，findAdvisorsThatCanApply在AopUtils中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AopUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">            <span class="comment">// 是否是IntroductionAdvisor并且canApply,加入到eligibleAdvisors中</span></span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">                eligibleAdvisors.add(candidate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">        <span class="comment">// 再次遍历候选的Advisor</span></span><br><span class="line">        <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">            <span class="comment">// 如果是IntroductionAdvisor，上面已经对IntroductionAdvisor进行了处理，这里continue继续下一个</span></span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">                <span class="comment">// already processed</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用canApply方法判断</span></span><br><span class="line">            <span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">                eligibleAdvisors.add(candidate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心的逻辑在canApply方法中：</p>
<ul>
<li><p><strong>根据切点Pointcut的getClassFilter方法对类进行匹配</strong>，判断targetClass目标类是否与切点匹配</p>
</li>
<li><p>从切点获取MethodMatcher方法匹配器，<strong>通过MethodMatcher对目标类中的每一个方法进行匹配，也就是使用切点表达式对方法进行匹配，判断方法是否需要拦截。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AopUtils</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否可以应用到bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">            PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class="line">            <span class="comment">// 继续调用canApply</span></span><br><span class="line">            <span class="keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// It doesn't have a pointcut so we assume it applies.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否可以应用到bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(pc, <span class="string">"Pointcut must not be null"</span>);</span><br><span class="line">        <span class="comment">// 通过切点进行匹配，先判断类是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从切点中获取方法匹配器</span></span><br><span class="line">        MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">        <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">            <span class="comment">// No need to iterate the methods if we're matching any method anyway...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果是IntroductionAwareMethodMatcher</span></span><br><span class="line">        <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">            introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            classes.add(ClassUtils.getUserClass(targetClass));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取类的所有接口</span></span><br><span class="line">        classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">            <span class="comment">// 获取类中的所有方法</span></span><br><span class="line">            Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">            <span class="comment">// 遍历方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                <span class="keyword">if</span> (introductionAwareMethodMatcher != <span class="keyword">null</span> ?</span><br><span class="line">                        introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</span><br><span class="line">                        methodMatcher.matches(method, targetClass)) &#123; <span class="comment">// 调用方法的matches进行匹配</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h2><p>上一节中已经获取到了可以应用到当前bean的Advisor，接下来就可以创建代理对象了，由于篇幅原因，创建代理的过程将另起一篇文章。</p>
<p><strong>总结</strong><br><img src="/images/AOP原理总结一.png" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://blog.csdn.net/qq_36882793/article/details/106440723" target="_blank" rel="noopener">【猫吻鱼】Spring源码分析：全集整理</a></p>
<p><strong>Spring版本：5.2.5.RELEASE</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">shan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shan</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
