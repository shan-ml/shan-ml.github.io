<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="SHAN">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SHAN">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SHAN">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>SHAN</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SHAN</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/30/【Redis】事件驱动框架（多线程）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/30/【Redis】事件驱动框架（多线程）/" itemprop="url">【Redis】事件驱动源码分析（多线程）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-30T11:00:00+08:00">
                2022-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="IO线程初始化"><a href="#IO线程初始化" class="headerlink" title="IO线程初始化"></a>IO线程初始化</h2><p>Redis在6.0版本中引入了多线程，提高IO请求处理效率。</p>
<p>在Redis Server启动函数main（server.c文件）中初始化服务之后，又调用了InitServerLast函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 初始化服务</span></span><br><span class="line">    initServer();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// InitServerLast</span></span><br><span class="line">    InitServerLast();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 事件循环</span></span><br><span class="line">    aeMain(server.el);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>InitServerLast函数在server.c文件中，它调用了initThreadedIO函数对IO线程初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitServerLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bioInit();</span><br><span class="line">    <span class="comment">// 初始化IO线程</span></span><br><span class="line">    initThreadedIO();</span><br><span class="line">    set_jemalloc_bg_thread(server.jemalloc_bg_thread);</span><br><span class="line">    server.initial_memory_usage = zmalloc_used_memory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>initThreadedIO</strong></p>
<p>initThreadedIO的实现在networking.c文件中：</p>
<ol>
<li>初始化全局变量 server.io_threads_active线程活跃状态为0，表示未激活IO多线程</li>
<li>对server.io_threads_num的值进行判断，io_threads_num表示设置的IO线程数量<ul>
<li>如果线程数设置为1，表示不开启多线程直接返回即可</li>
<li>如果线程数超过了IO_THREADS_MAX_NUM设置的最大值（128），则报错并停止redis服务</li>
</ul>
</li>
<li>根据线程数的设置创建线程<ul>
<li>初始化io_threads_list[i]，<strong>io_threads_list是一个数组，数组中的每一个元素是一个list，里面存储每个线程要处理的客户端列表</strong>，<strong>下标为0的元素也就是io_threads_lis[0]存储的是主线程要处理的客户端列表</strong>，这里先调用listCreate创建列表，为io_threads_list[i]初始化</li>
<li>初始化io_threads_pending[i]为0，<strong>io_threads_pending数组存储每个线程等待处理的客户端个数</strong></li>
<li>调用pthread_create创建线程，并传入了<strong>线程的运行函数IOThreadMain</strong>，之后将线程保存在io_threads中，<strong>io_threads数组存储了创建的线程描述符</strong></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 初始化线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initThreadedIO</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    server.io_threads_active = <span class="number">0</span>; <span class="comment">/* 初始化线程活跃状态为0，表示未激活IO多线程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果IO线程数为1，直接返回即可 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 如果IO线程数超过了最大限制，打印错误，停止redis服务 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num &gt; IO_THREADS_MAX_NUM) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Fatal: too many I/O threads configured. "</span></span><br><span class="line">                             <span class="string">"The maximum number is %d."</span>, IO_THREADS_MAX_NUM);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据线程数设置创建线程 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; server.io_threads_num; i++) &#123;</span><br><span class="line">        <span class="comment">/* 创建List */</span></span><br><span class="line">        io_threads_list[i] = listCreate();</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">/* 下标为0的存储的是主线程 */</span></span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        pthread_mutex_init(&amp;io_threads_mutex[i],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 初始化待处理的客户端数量为0</span></span><br><span class="line">        setIOPendingCount(i, <span class="number">0</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[i]); <span class="comment">/* Thread will be stopped. */</span></span><br><span class="line">        <span class="comment">// 创建线程, 线程的运行函数为IOThreadMain</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;tid,<span class="literal">NULL</span>,IOThreadMain,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)i) != <span class="number">0</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Fatal: Can't initialize IO thread."</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将创建的线程加入io_threads线程组中*/</span></span><br><span class="line">        io_threads[i] = tid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setIOPendingCount在networking.c文件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setIOPendingCount</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置io_threads_pending[i]的值为count</span></span><br><span class="line">    atomicSetWithSync(io_threads_pending[i], count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>io_threads_list</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* io_threads_list存储每个线程要处理的客户端 */</span></span><br><span class="line"><span class="built_in">list</span> *io_threads_list[IO_THREADS_MAX_NUM];</span><br></pre></td></tr></table></figure>
<p><strong>io_threads</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存储创建的线程*/</span></span><br><span class="line"><span class="keyword">pthread_t</span> io_threads[IO_THREADS_MAX_NUM];</span><br></pre></td></tr></table></figure>
<p><strong>io_threads_pending</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存储每个线程要等待处理的客户端个数 */</span></span><br><span class="line">redisAtomic <span class="keyword">unsigned</span> <span class="keyword">long</span> io_threads_pending[IO_THREADS_MAX_NUM];</span><br></pre></td></tr></table></figure>
<p><strong>IO_THREADS_MAX_NUM定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_THREADS_MAX_NUM 128</span></span><br></pre></td></tr></table></figure>
<p><strong>初始化流程图</strong></p>
<p><img src="/images/redisio线程初始化.jpg" alt=""></p>
<h3 id="IO线程运行函数"><a href="#IO线程运行函数" class="headerlink" title="IO线程运行函数"></a>IO线程运行函数</h3><p>IO线程运行函数IOThreadMain在networking.c文件中，函数的入参传入的是线程id，它开启了一个while(1)循环，主要处理逻辑如下：</p>
<ol>
<li>从io_threads_list数组中获取当前线程id要处理的客户端列表，放入到列表迭代器li中</li>
<li>遍历迭代器，获取每一个待处理的客户端client，根据io_threads_op线程的操作状态判断读写状态<ul>
<li>如果是写状态，调用调用writeToClient处理</li>
<li>如果是读状态，调用readQueryFromClient处理</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">IOThreadMain</span><span class="params">(<span class="keyword">void</span> *myid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* myid是线程ID，从0开始，到 server.iothreads_num-1，0号线程存储的是主线程 */</span></span><br><span class="line">    <span class="keyword">long</span> id = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)myid;</span><br><span class="line">    <span class="keyword">char</span> thdname[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(thdname, <span class="keyword">sizeof</span>(thdname), <span class="string">"io_thd_%ld"</span>, id);</span><br><span class="line">    redis_set_thread_title(thdname);</span><br><span class="line">    redisSetCpuAffinity(server.server_cpulist);</span><br><span class="line">    makeThreadKillable();</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getIOPendingCount(id) != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Give the main thread a chance to stop this thread. */</span></span><br><span class="line">        <span class="keyword">if</span> (getIOPendingCount(id) == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;io_threads_mutex[id]);</span><br><span class="line">            pthread_mutex_unlock(&amp;io_threads_mutex[id]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        serverAssert(getIOPendingCount(id) != <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        listIter li;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        <span class="comment">// 获取每一个IO线程要处理的客户端，将其放入到迭代器li，这里的id指的线程id</span></span><br><span class="line">        listRewind(io_threads_list[id],&amp;li);</span><br><span class="line">        <span class="comment">// 遍历列表</span></span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            <span class="comment">// 获取每一个待处理的客户端</span></span><br><span class="line">            client *c = listNodeValue(ln);</span><br><span class="line">            <span class="comment">// 如果是写事件</span></span><br><span class="line">            <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                <span class="comment">// 调用writeToClient处理</span></span><br><span class="line">                writeToClient(c,<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_READ) &#123;</span><br><span class="line">                <span class="comment">// 如果是读事件，调用readQueryFromClient</span></span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverPanic(<span class="string">"io_threads_op value is unknown"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        listEmpty(io_threads_list[id]);</span><br><span class="line">        <span class="comment">// 处理完毕后，io_threads_pending数组中对应的数量设置为0，表示所有客户端已处理完毕</span></span><br><span class="line">        setIOPendingCount(id, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>io_threads_list数组中存储了每一个线程要处理的客户端列表，在线程运行函数IOThreadMain中，获取待处理的客户端列表，遍历每一个客户端，根据读写类型调用不同的方法进行处理，接下来就去看下Redis在何时将待处理的客户端加入到io_threads_list列表中的。</p>
<h2 id="延迟读写操作"><a href="#延迟读写操作" class="headerlink" title="延迟读写操作"></a>延迟读写操作</h2><p>Redis在处理客户端读事件和写事件时会根据一定条件推迟客户端的读取操作或者往客户端写数据操作，将待处理的读客户端和待处理的写客户端分别加入到全局变量server的clients_pending_read和clients_pending_write列表中，全局变量server对应的结构体为redisServer：</p>
<p>全局变量server定义，在server.c文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 全局变量server */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span></span><br></pre></td></tr></table></figure>
<p>redisServer的结构体定义在server.h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span> *clients_pending_write; <span class="comment">/* list类型，记录延迟写回数据的客户端 */</span></span><br><span class="line">    <span class="built_in">list</span> *clients_pending_read;  <span class="comment">/* list类型，记录延迟读取数据的客户端*/</span></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="推迟客户端读操作"><a href="#推迟客户端读操作" class="headerlink" title="推迟客户端读操作"></a>推迟客户端读操作</h3><p><strong>readQueryFromClient</strong></p>
<p>readQueryFromClient主要处理从客户端读取数据，在networking.c中实现，里面调用了postponeClientRead函数判断是否需要推迟客户端的读取操作 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    client *c = connGetPrivateData(conn);</span><br><span class="line">    <span class="keyword">int</span> nread, readlen;</span><br><span class="line">    <span class="keyword">size_t</span> qblen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断是否需要推迟客户端的读取操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (postponeClientRead(c)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 处理数据执行命令</span></span><br><span class="line">    processInputBuffer(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>postponeClientRead</strong></p>
<p>postponeClientRead函数用于判断是否延迟从客户端读取数据，包含四个条件：</p>
<ol>
<li>server.io_threads_active为1，表示激活了IO多线程</li>
<li>server.io_threads_do_reads为1，表示IO多线程可以延迟执行客户端的读取操作，在配置文件中定义，可以通过修改配置文件来开启延迟读取客户端数据</li>
<li>ProcessingEventsWhileBlocked值为0，processEventsWhileBlokced函数在执行时会将ProcessingEventsWhileBlocked的值置为1，执行完毕后置为0，Redis在读取RDB或者AOF文件时会调用processEventsWhileBlokced函数，<strong>为了避免读取RDB或AOF文件时阻塞无法及时处理请求，processEventsWhileBlokced函数在执行时不能推迟客户端数据读取。</strong></li>
<li>客户端的现有标识不能有CLIENT_MASTER、CLIENT_SLAVE、CLIENT_PENDING_READ、CLIENT_BLOCKED等状态<ul>
<li>CLIENT_MASTER、CLIENT_SLAVE表示是用于主从复制的客户端</li>
<li>CLIENT_PENDING_READ表示客户端本身已经是推迟读取状态</li>
<li>CLIENT_BLOCKED表示客户端是阻塞状态</li>
</ul>
</li>
</ol>
<p><strong>满足以上四个条件时将推迟从客户端读取数据，会将客户端标识置为CLIENT_PENDING_READ延迟读状态，并将待读取数据的客户端client加入到server.clients_pending_read中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">postponeClientRead</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_active &amp;&amp;</span><br><span class="line">        server.io_threads_do_reads &amp;&amp;</span><br><span class="line">        !ProcessingEventsWhileBlocked &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ|CLIENT_BLOCKED))) </span><br><span class="line">    &#123;</span><br><span class="line">        c-&gt;flags |= CLIENT_PENDING_READ;</span><br><span class="line">        <span class="comment">// 将客户端加入到clients_pending_read链表中</span></span><br><span class="line">        listAddNodeHead(server.clients_pending_read,c);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="推迟客户端写操作"><a href="#推迟客户端写操作" class="headerlink" title="推迟客户端写操作"></a>推迟客户端写操作</h3><p>在往客户端写数据的addReply（networking.c）函数中，调用了prepareClientToWrite判断是否准备往客户端写数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addReply</span><span class="params">(client *c, robj *obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用prepareClientToWrite往客户端写数据</span></span><br><span class="line">    <span class="keyword">if</span> (prepareClientToWrite(c) != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(obj)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != C_OK)</span><br><span class="line">            _addReplyProtoToList(c,obj-&gt;ptr,sdslen(obj-&gt;ptr));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">size_t</span> len = ll2string(buf,<span class="keyword">sizeof</span>(buf),(<span class="keyword">long</span>)obj-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,buf,len) != C_OK)</span><br><span class="line">            _addReplyProtoToList(c,buf,len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Wrong obj-&gt;encoding in addReply()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>prepareClientToWrite</strong></p>
<p>prepareClientToWrite（networking.c）中，首先对客户端标识状态进行了一系列的判断，然后调用了clientHasPendingReplies函数判断输出缓冲区是否有还有数据等待写回到客户端，如果没有，判断客户端的标识是否是CLIENT_PENDING_READ已延迟读，如果不是CLIENT_PENDING_READ状态，调用clientInstallWriteHandler处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prepareClientToWrite</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_LUA|CLIENT_MODULE)) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER_FORCE_REPLY)) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c-&gt;conn) <span class="keyword">return</span> C_ERR; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 如果缓冲区的数据都已写回到客户端并且客户端标识不是推迟读状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!clientHasPendingReplies(c) &amp;&amp; !(c-&gt;flags &amp; CLIENT_PENDING_READ))</span><br><span class="line">            clientInstallWriteHandler(c);<span class="comment">// 调用clientInstallWriteHandler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>clientInstallWriteHandler</strong></p>
<p>clientInstallWriteHandler（networking.c）函数中<strong>对是否推迟客户端写操作进行了判断</strong>：</p>
<ol>
<li>客户端标识不是CLIENT_PENDING_WRITE，对应条件为!(c-&gt;flags &amp; CLIENT_PENDING_WRITE)，表示客户端本身不是推迟写状态</li>
<li>客户端未在进行主从复制（对应条件为c-&gt;replstate == REPL_STATE_NONE） 或者 客户端是主从复制的从节点，但全量复制的 RDB 文件已经传输完成，客户端可以接收请求（对应条件 !c-&gt;repl_put_online_on_ack)）</li>
</ol>
<p><strong>满足以上两个条件时将推迟客户端写操作，将客户端的标识置为延迟写CLIENT_PENDING_WRITE状态，并将客户端加入到待写回的列表server.clients_pending_write中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientInstallWriteHandler</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 如果客户端的标识不是推迟写状态，并且客户端未在进行主从复制或者客户端是主从复制的从节点并能接收请求 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_PENDING_WRITE) &amp;&amp;</span><br><span class="line">        (c-&gt;replstate == REPL_STATE_NONE ||</span><br><span class="line">         (c-&gt;replstate == SLAVE_STATE_ONLINE &amp;&amp; !c-&gt;repl_put_online_on_ack)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 将客户端的标识置为延迟写 */</span></span><br><span class="line">        c-&gt;flags |= CLIENT_PENDING_WRITE;</span><br><span class="line">        <span class="comment">// 将客户端加入到待写回的列表clients_pending_write中</span></span><br><span class="line">        listAddNodeHead(server.clients_pending_write,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO线程的分配"><a href="#IO线程的分配" class="headerlink" title="IO线程的分配"></a>IO线程的分配</h2><p>上面我们已经知道了IO线程的初始化、IO线程的运行函数IOThreadMain主要处理逻辑，以及延迟读写的客户端是何时分别加入到server全局变量的clients_pending_read和clients_pending_write中的，接下来去看下时何时为客户端分配线程。</p>
<p>在aeProcessEvents处理事件的函数中，等待事件产生之前，调用了beforeSleep（networking.c）方法，beforeSleep中又调用了<strong>handleClientsWithPendingReadsUsingThreads为延迟读取操作的客户端分配线程</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    UNUSED(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">    handleBlockedClientsTimeout();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用了handleClientsWithPendingReadsUsingThreads为延迟读客户端分配线程 */</span></span><br><span class="line">    handleClientsWithPendingReadsUsingThreads();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 调用了handleClientsWithPendingWritesUsingThreads为延迟写客户端分配线程 */</span></span><br><span class="line">    handleClientsWithPendingWritesUsingThreads();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="延迟读操作的客户端分配线程"><a href="#延迟读操作的客户端分配线程" class="headerlink" title="延迟读操作的客户端分配线程"></a>延迟读操作的客户端分配线程</h3><p><strong>handleClientsWithPendingReadsUsingThreads</strong></p>
<p>handleClientsWithPendingReadsUsingThreads（networking.c）主要逻辑如下：</p>
<ol>
<li><p>从server.clients_pending_read获取延迟读取操作的客户端，将其加入到迭代列表</p>
</li>
<li><p>遍历延迟读操作的客户端列表，获取每一个待处理的客户端client，item_id表示每个客户端的序号，从0开始，每处理一个客户端就增1，用序号对线程数server.io_threads_num取模，得到一个target_id，客户端会被加入到io_threads_list[target_id]对应的列表中，<strong>也就是使用取模的方式轮询为每一个客户端分配对应线程，然后将客户端加入到该线程待处理的客户端列表中，此时客户端已分配到线程，在线程的运行函数IOThreadMain会调用readQueryFromClient处理客户端数据，需要注意多线程只是从客户端数据读取数据解析命令，并不会执行命令</strong>,在processInputBuffer中可以看到在IO多线程下只会将flags状态标记为CLIENT_PENDING_COMMAND，不会执行processCommandAndResetClient函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">processInputBuffer</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(c-&gt;qb_pos &lt; sdslen(c-&gt;querybuf)) &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">0</span>) &#123;</span><br><span class="line">            resetClient(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 在IO多线程情况下不能在这里执行命令，所以在这里将client标记为CLIENT_PENDING_COMMAND然后返回，等待主线程同步执行命令 */</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PENDING_READ) &#123;</span><br><span class="line">                c-&gt;flags |= CLIENT_PENDING_COMMAND;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 准备执行命令 */</span></span><br><span class="line">            <span class="keyword">if</span> (processCommandAndResetClient(c) == C_ERR) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将io_threads_op线程操作状态置为读操作</p>
</li>
<li><p>遍历线程数，获取每一个线程要处理的客户端个数，将其设置到线程对应的io_threads_pending[j]中，<strong>io_threads_pending数组中记录了每个线程等待处理的客户端个数</strong></p>
</li>
<li><p>获取io_threads_list[0]中待处理的客户端列表，io_threads_list[0]存储的是主线程的数据，<strong>因为当前执行handleClientsWithPendingReadsUsingThreads函数的线程正是主线程，所以让主线程来处理io_threads_list[0]中存放的待处理客户端</strong></p>
</li>
<li><p>主线程遍历io_threads_list[0]中每一个待处理的客户端，调用readQueryFromClient处理，从客户端读取数据</p>
</li>
<li><p>主线程开启一个while(1)循环等待其他IO线程处理完毕，结束条件是pending为0，pending记录了所有线程要处理的客户端数量总和，<strong>在前面IOThreadMain函数中可以看到线程在处理完毕之后会将对应io_threads_pending数组中记录的个数置为0，当pending为0表示所有的线程都已将各自复制的客户端数据处理完毕</strong></p>
</li>
<li><p>主线程开启while循环<strong>准备执行客户端命令（注意这里才开始执行命令，多线程只负责解析不负责执行）</strong>，循环条件是server.clients_pending_read列表的长度不为0，主线程需要保证客户端的请求顺序，所从clients_pending_read列表中的第一个元素开始向后遍历：</p>
<p>（1）调用listNodeValue获取列表中的元素，也就是待处理的客户端client</p>
<p>（2）调用listDelNode将获取到的元素从列表删除，因为在第7步中，<strong>主线程已经等待其他所有的线程执行完毕，此时所有的线程已经将各自负责的客户端数据处理完成</strong>，所以可以将客户端从server.clients_pending_read中移除</p>
<p>（3）<strong>调用processPendingCommandsAndResetClient函数判断客户端标识是否是CLIENT_PENDING_COMMAND状态，CLIENT_PENDING_COMMAND状态表示客户端的请求命令已经被IO线程解析（processInputBuffer方法中可以看到状态被标记为CLIENT_PENDING_COMMAND），可以开始执行命令，接着调用processCommandAndResetClient函数执行客户端发送的请求命令</strong></p>
<p>（4）<strong>由于客户端输入缓冲区可能有其他的命令未读取，这里调用processInputBuffer处理输入缓冲区数据继续解析命令并执行</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWithPendingReadsUsingThreads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!server.io_threads_active || !server.io_threads_do_reads) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> processed = listLength(server.clients_pending_read);</span><br><span class="line">    <span class="keyword">if</span> (processed == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="comment">// 获取待读取的客户端列表clients_pending_read加入到迭代链表中</span></span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    <span class="keyword">int</span> item_id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历待读取的客户端</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        <span class="comment">// 获取客户端</span></span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="comment">// 根据线程数取模，轮询分配线程</span></span><br><span class="line">        <span class="keyword">int</span> target_id = item_id % server.io_threads_num;</span><br><span class="line">        <span class="comment">// 分配线程，加入到线程对应的io_threads_list</span></span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将线程的操作状态置为读操作*/</span></span><br><span class="line">    io_threads_op = IO_THREADS_OP_READ;</span><br><span class="line">    <span class="comment">// 遍历线程数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++) &#123;</span><br><span class="line">        <span class="comment">// 获取每个线程待处理客户端的个数</span></span><br><span class="line">        <span class="keyword">int</span> count = listLength(io_threads_list[j]);</span><br><span class="line">        <span class="comment">// 将待处理客户端的个数设置到线程对应的io_threads_pending[j]中，io_threads_pending数组中记录了每个线程要处理的客户端个数</span></span><br><span class="line">        setIOPendingCount(j, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取io_threads_list[0]中待处理的客户端列表，io_threads_list[0]存储的是主线程的数据*/</span></span><br><span class="line">     <span class="comment">/* handleClientsWithPendingReadsUsingThreads函数的执行者刚好就是主线程，所以让主线程处理io_threads_list[0]中的数据*/</span></span><br><span class="line">    listRewind(io_threads_list[<span class="number">0</span>],&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="comment">// 调用readQueryFromClient</span></span><br><span class="line">        readQueryFromClient(c-&gt;conn);</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(io_threads_list[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待其他线程处理完毕 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pending = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">            <span class="comment">// 获取每一个客户端处理的客户端个数</span></span><br><span class="line">            pending += getIOPendingCount(j);</span><br><span class="line">        <span class="comment">// 如果为0表示所有线程对应的客户端都处理完毕</span></span><br><span class="line">        <span class="keyword">if</span> (pending == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再次判断server.clients_pending_read是否有待处理的客户端*/</span></span><br><span class="line">    <span class="keyword">while</span>(listLength(server.clients_pending_read)) &#123;</span><br><span class="line">        <span class="comment">// 获取列表第一个元素</span></span><br><span class="line">        ln = listFirst(server.clients_pending_read);</span><br><span class="line">        <span class="comment">// 获取客户端</span></span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_READ;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        listDelNode(server.clients_pending_read,ln);</span><br><span class="line"></span><br><span class="line">        serverAssert(!(c-&gt;flags &amp; CLIENT_BLOCKED));</span><br><span class="line">        <span class="comment">// processPendingCommandsAndResetClient函数中会判断客户端标识是否是CLIENT_PENDING_COMMAND状态，如果是调用processCommandAndResetClient函数处理请求命令</span></span><br><span class="line">        <span class="keyword">if</span> (processPendingCommandsAndResetClient(c) == C_ERR) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于客户端输入缓冲区可能有其他的命令未读取，这里解析命令并执行</span></span><br><span class="line">        processInputBuffer(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_PENDING_WRITE) &amp;&amp; clientHasPendingReplies(c))</span><br><span class="line">            clientInstallWriteHandler(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update processed count on server */</span></span><br><span class="line">    server.stat_io_reads_processed += processed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>processPendingCommandsAndResetClient</strong></p>
<p>processPendingCommandsAndResetClient函数在networking.c中，它先判断客户端标识是否是CLIENT_PENDING_COMMAND状态，CLIENT_PENDING_COMMAND状态表示客户端的请求命令已经被IO线程解析，可以被执行，所以如果处于CLIENT_PENDING_COMMAND状态，接下来会调用processCommandAndResetClient函数处理客户端命令，具体是调用processCommand函数执行命令的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*processPendingCommandsAndResetClient函数（networking.c中） */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processPendingCommandsAndResetClient</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断客户端标识是否是CLIENT_PENDING_COMMAND</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PENDING_COMMAND) &#123;</span><br><span class="line">        <span class="comment">// 取消CLIENT_PENDING_COMMAND状态</span></span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_COMMAND;</span><br><span class="line">        <span class="comment">// 调用processCommandAndResetClient执行命令</span></span><br><span class="line">        <span class="keyword">if</span> (processCommandAndResetClient(c) == C_ERR) &#123;</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* processCommandAndResetClient函数（networking.c中） */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommandAndResetClient</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> deadclient = <span class="number">0</span>;</span><br><span class="line">    client *old_client = server.current_client;</span><br><span class="line">    server.current_client = c;</span><br><span class="line">    <span class="comment">// 调用processCommand执行命令</span></span><br><span class="line">    <span class="keyword">if</span> (processCommand(c) == C_OK) &#123;</span><br><span class="line">        commandProcessed(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.current_client == <span class="literal">NULL</span>) deadclient = <span class="number">1</span>;</span><br><span class="line">    server.current_client = old_client;</span><br><span class="line">    <span class="keyword">return</span> deadclient ? C_ERR : C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>processCommand</strong></p>
<p>processCommand函数在server.c文件中，它调用了addReply函数将需要返回给客户端的数据先写入缓冲区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">"quit"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 调用addReply函数将需要返回给客户端的数据先写入缓冲区</span></span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">        c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据读取的整体过程如下，<strong>IO多线程只是负责从客户端读取数据解析命令，执行命令的过程仍然是单线程的</strong>：</p>
<p><img src="/images/redis数据读取过程.jpg" alt=""></p>
<h3 id="延迟写操作的客户端分配线程"><a href="#延迟写操作的客户端分配线程" class="headerlink" title="延迟写操作的客户端分配线程"></a>延迟写操作的客户端分配线程</h3><p><strong>handleClientsWithPendingWritesUsingThreads</strong></p>
<p>延迟写操作的客户端分配线程在handleClientsWithPendingWritesUsingThreads中实现（networking.c），处理逻辑与handleClientsWithPendingReadsUsingThreads类似：</p>
<ol>
<li><p>从server.clients_pending_write获取延迟写操作的客户端，将其加入到迭代列表</p>
</li>
<li><p>遍历延迟写操作的客户端列表，获取每一个待处理的客户端client，<strong>使用取模的方式轮询为每一个客户端分配线程，然后将客户端加入到该线程待处理的客户端列表中，此时客户端已分配到线程，在线程的运行函数IOThreadMain会处待写回数据的客户端</strong></p>
</li>
<li><p>将io_threads_op线程操作状态置为写操作</p>
</li>
<li><p>遍历线程数，获取每一个线程要处理的客户端个数，将其设置到线程对应的io_threads_pending[j]中，<strong>io_threads_pending数组中记录了每个线程等待处理的客户端个数</strong></p>
</li>
<li><p>获取io_threads_list[0]中待处理的客户端列表，io_threads_list[0]存储的是主线程的数据，<strong>因为当前执行handleClientsWithPendingWritesUsingThreads函数的线程正是主线程，所以让主线程来处理io_threads_list[0]中存放的待处理客户端</strong></p>
</li>
<li><p>主线程遍历io_threads_list[0]中每一个待处理的客户端，调用writeToClient往客户端写数据</p>
</li>
<li><p>主线程开启一个while(1)循环等待其他IO线程处理完毕</p>
</li>
<li><p>主线程开启while循环，循环条件是server.clients_pending_write列表的长度不为0，遍历clients_pending_write中待处理的写客户端：</p>
<p>（1）调用listNodeValue获取待处理的客户端client</p>
<p>（2）<strong>判断缓冲区数据是否全部写回到客户端，如果未全部写回调用connSetWriteHandler向内核注册写事件监听，回调函数为sendReplyToClient，待事件循环流程再次执行时，注册的可写事件会通过回调函数sendReplyToClient 处理，把缓冲区中的数据写回客户端。</strong></p>
</li>
<li><p>调用listEmpty函数清空server.clients_pending_write列表</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWithPendingWritesUsingThreads</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = listLength(server.clients_pending_write);</span><br><span class="line">    <span class="keyword">if</span> (processed == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span> || stopThreadedIOIfNeeded()) &#123;</span><br><span class="line">        <span class="keyword">return</span> handleClientsWithPendingWrites();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!server.io_threads_active) startThreadedIO();</span><br><span class="line"></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="comment">// 获取待写回客户端列表clients_pending_write加入到迭代链表中</span></span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="keyword">int</span> item_id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历待写的客户端</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP) &#123;</span><br><span class="line">            listDelNode(server.clients_pending_write, ln);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据线程数取模，轮询分配线程</span></span><br><span class="line">        <span class="keyword">int</span> target_id = item_id % server.io_threads_num;</span><br><span class="line">         <span class="comment">// 分配线程，加入到对应线程的io_threads_list</span></span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将io_threads_op线程操作状态置为写操作 */</span></span><br><span class="line">    io_threads_op = IO_THREADS_OP_WRITE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = listLength(io_threads_list[j]);</span><br><span class="line">        <span class="comment">// 设置每个线程需要处理的客户端个数</span></span><br><span class="line">        setIOPendingCount(j, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取io_threads_list[0]中待处理的客户端列表，io_threads_list[0]存储的是主线程的数据*/</span></span><br><span class="line">    <span class="comment">/* handleClientsWithPendingWritesUsingThreads函数的执行者刚好就是主线程，所以让主线程处理io_threads_list[0]中的数据*/</span></span><br><span class="line">    listRewind(io_threads_list[<span class="number">0</span>],&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="comment">// 调用writeToClient往客户写数据</span></span><br><span class="line">        writeToClient(c,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(io_threads_list[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待其他线程处理完毕 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pending = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">            pending += getIOPendingCount(j);</span><br><span class="line">        <span class="keyword">if</span> (pending == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 再次获取server.clients_pending_read所有待写的客户端*/</span></span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果缓冲区数据未全部写回调用connSetWriteHandler注册可写事件，回调函数为sendReplyToClient*/</span></span><br><span class="line">        <span class="keyword">if</span> (clientHasPendingReplies(c) &amp;&amp;</span><br><span class="line">                connSetWriteHandler(c-&gt;conn, sendReplyToClient) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空clients_pending_write</span></span><br><span class="line">    listEmpty(server.clients_pending_write);</span><br><span class="line"></span><br><span class="line">    server.stat_io_writes_processed += processed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>connSetWriteHandler</strong></p>
<p>connSetWriteHandler函数在connection.c文件中，它通过set_write_handler注册了写handler，set_write_handler对应的是connSocketSetWriteHandler函数，<strong>所以connSetWriteHandler会被映射为connSocketSetWriteHandler，connSocketSetWriteHandler函数调用了aeCreateFileEvent向内核中注册可写事件监听，上面可知回调函数为sendReplyToClient</strong> ，等事件循环流程再次执行时，handleClientsWithPendingWritesUsingThreads 函数注册的可写事件会通过回调函数sendReplyToClient 处理，把缓冲区中的数据写回客户端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ConnectionType CT_Socket = &#123;</span><br><span class="line">    .ae_handler = connSocketEventHandler,</span><br><span class="line">    .close = connSocketClose,</span><br><span class="line">    .write = connSocketWrite,</span><br><span class="line">    .read = connSocketRead,</span><br><span class="line">    .accept = connSocketAccept,</span><br><span class="line">    .connect = connSocketConnect,</span><br><span class="line">    .set_write_handler = connSocketSetWriteHandler, <span class="comment">// set_write_handler对应connSocketSetWriteHandler函数</span></span><br><span class="line">    .set_read_handler = connSocketSetReadHandler,</span><br><span class="line">    .get_last_error = connSocketGetLastError,</span><br><span class="line">    .blocking_connect = connSocketBlockingConnect,</span><br><span class="line">    .sync_write = connSocketSyncWrite,</span><br><span class="line">    .sync_read = connSocketSyncRead,</span><br><span class="line">    .sync_readline = connSocketSyncReadLine,</span><br><span class="line">    .get_type = connSocketGetType</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * connSetWriteHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">connSetWriteHandler</span><span class="params">(connection *conn, ConnectionCallbackFunc func)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册写handler, set_write_handler对应的是connSocketSetWriteHandler函数</span></span><br><span class="line">    <span class="keyword">return</span> conn-&gt;type-&gt;set_write_handler(conn, func, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * connSocketSetWriteHandler注册写事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">connSocketSetWriteHandler</span><span class="params">(connection *conn, ConnectionCallbackFunc func, <span class="keyword">int</span> barrier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (func == conn-&gt;write_handler) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    conn-&gt;write_handler = func;</span><br><span class="line">    <span class="keyword">if</span> (barrier)</span><br><span class="line">        conn-&gt;flags |= CONN_FLAG_WRITE_BARRIER;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        conn-&gt;flags &amp;= ~CONN_FLAG_WRITE_BARRIER;</span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;write_handler)</span><br><span class="line">        aeDeleteFileEvent(server.el,conn-&gt;fd,AE_WRITABLE);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,conn-&gt;fd,AE_WRITABLE, <span class="comment">// 向内核注册写事件</span></span><br><span class="line">                    conn-&gt;type-&gt;ae_handler,conn) == AE_ERR) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong><br><img src="/images/redis事件驱动框架多线程总结.png" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/25/【Redis】事件驱动框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/25/【Redis】事件驱动框架/" itemprop="url">【Redis】事件驱动源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-25T22:00:00+08:00">
                2022-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="aeEventLoop初始化"><a href="#aeEventLoop初始化" class="headerlink" title="aeEventLoop初始化"></a>aeEventLoop初始化</h2><p>在server.c文件的initServer函数中，对aeEventLoop进行了初始化：</p>
<ol>
<li>调用aeCreateEventLoop函数创建aeEventLoop结构体，对aeEventLoop结构体中的变量进行了初始化，之后<strong>调用了aeApiCreate函数创建epoll实例</strong></li>
<li>调用aeCreateFileEvent函数向内核注册监听事件，由参数可知，<strong>注册的是对TCP文件描述符的可读事件监听，回调函数是acceptTcpHandler，当内核监听到TCP文件描述符有可读事件时，Redis将调用acceptTcpHandler函数对事件进行处理</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建aeEventLoop结构体</span></span><br><span class="line">      server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);</span><br><span class="line">      <span class="keyword">if</span> (server.el == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">"Failed creating the event loop. Error message: '%s'"</span>,</span><br><span class="line">                  strerror(errno));</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略其他代码...</span></span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">          <span class="comment">// 注册监听事件，server.ipfd是TCP文件描述符，AE_READABLE可读事件，acceptTcpHandler事件处理回调函数</span></span><br><span class="line">          <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">                  acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">          &#123;</span><br><span class="line">              serverPanic(</span><br><span class="line">                      <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略其他代码...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在aeCreateEventLoop函数调用时，传入的最大文件描述符个数为客户端最大连接数+宏定义CONFIG_FDSET_INCR的大小，CONFIG_FDSET_INCR的定义在server.h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FDSET_INCR (CONFIG_MIN_RESERVED_FDS+96)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MIN_RESERVED_FDS 32</span></span><br></pre></td></tr></table></figure>
<h3 id="aeEventLoop结构体创建"><a href="#aeEventLoop结构体创建" class="headerlink" title="aeEventLoop结构体创建"></a>aeEventLoop结构体创建</h3><p>aeEventLoop结构体定义，在ae.h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* 记录最大的文件描述符 */</span></span><br><span class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* 最大文件描述符个数 */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     </span><br><span class="line">    aeFileEvent *events; <span class="comment">/* IO事件集合，记录了每个文件描述符产生事件时的回调函数 */</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">/* 记录已触发的事件 */</span></span><br><span class="line">    aeTimeEvent *timeEventHead; <span class="comment">/* 时间事件 */</span></span><br><span class="line">    <span class="keyword">int</span> stop;</span><br><span class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* IO多路复用API接口相关数据 */</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep;<span class="comment">/* 进入事件循环流程前的执行函数 */</span></span><br><span class="line">    aeBeforeSleepProc *aftersleep;<span class="comment">/* 退出事件循环流程后的执行函数 */</span></span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure>
<p><strong>aeCreateEventLoop</strong></p>
<p>aeEventLoop结构体创建在aeCreateEventLoop函数中（ae.c文件）：</p>
<ol>
<li>分配aeEventLoop结构体所需内存</li>
<li>分配aeEventLoop结构体中其他变量所需内存</li>
<li><strong>调用aeApiCreate函数创建epoll实例</strong></li>
<li>对IO事件集合events的mask掩码初始化为AE_NONE，表示当前没有事件监听</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// aeEventLoop结构体</span></span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 分配eventLoop内存</span></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">// 分配IO事件内存</span></span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;aftersleep = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 创建poll实例</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE; <span class="comment">// 初始化为空事件</span></span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建epoll实例"><a href="#创建epoll实例" class="headerlink" title="创建epoll实例"></a>创建epoll实例</h4><p>aeApiState结构体定义，在ae_epoll.c中：</p>
<ul>
<li><p><strong>epfd：创建的epoll实例文件描述符</strong></p>
</li>
<li><p><strong>events：记录文件描述符产生的事件</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeApiState</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> epfd; <span class="comment">// epoll实例文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span> <span class="comment">// 记录就绪的事件</span></span><br><span class="line">&#125; aeApiState;</span><br></pre></td></tr></table></figure>
<p><strong>aeApiCreate</strong></p>
<p>epoll实例的的创建在aeApiCreate函数（ae_epoll.c文件）中，处理逻辑如下：</p>
<ol>
<li><p>为aeApiState结构体分配内存空间</p>
</li>
<li><p>为aeApiState中的events分配内存空间，events数组个数为eventLoop中的最大文件描述个数</p>
</li>
<li><p><strong>调用epoll_create函数创建epoll实例，将返回的epoll文件描述符保存在epfd中</strong></p>
</li>
<li>将eventLoop的apidata指向创建的aeApiState，之后就可以通过eventLoop获取到epoll实例并且注册监听事件了</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 为epoll事件分配内存</span></span><br><span class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(struct epoll_event)*eventLoop-&gt;setsize);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// epoll_create创建epoll实例，返回文件描述符，保存在state的epfd中</span></span><br><span class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); </span><br><span class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        zfree(state-&gt;events);</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将aeApiState设置到eventLoop的apidata</span></span><br><span class="line">    eventLoop-&gt;apidata = state;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h3><p>IO 事件的数据结构是 aeFileEvent 结构体，在ae.c中定义：</p>
<ul>
<li><p><strong>mask：事件类型掩码</strong>，共有READABLE、WRITABLE、BARRIER三种事件，分别为可读事件、可写事件和屏障事件</p>
</li>
<li><p><strong>rfileProc：写事件回调函数</strong></p>
</li>
<li><p><strong>wfileProc：读事件回调函数</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mask; <span class="comment">/* 事件类型掩码 READABLE|WRITABLE|BARRIER  */</span></span><br><span class="line">    aeFileProc *rfileProc;  <span class="comment">/* 写事件回调函数  */</span></span><br><span class="line">    aeFileProc *wfileProc;  <span class="comment">/* 读事件回调函数  */</span></span><br><span class="line">    <span class="keyword">void</span> *clientData; <span class="comment">/* 客户端数据 */</span></span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure>
<p><strong>aeCreateFileEvent</strong></p>
<p>aeCreateFileEvent函数在ae.c文件中，主要处理逻辑如下：</p>
<ol>
<li>根据传入的文件描述符，在eventLoop中获取对应的IO事件aeFileEvent fe</li>
<li><strong>调用aeApiAddEvent方法注册要监听的事件</strong></li>
<li>设置读写事件的回调函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</span></span></span><br><span class="line"><span class="function"><span class="params">        aeFileProc *proc, <span class="keyword">void</span> *clientData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据传入的文件描述符获取对应的IO事件</span></span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line">    <span class="comment">// 注册要监听的事件，让内核可以监听到当前文件描述符上的IO事件</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc; <span class="comment">// 设置写事件的回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc; <span class="comment">// 设置读事件的回调函数</span></span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd)</span><br><span class="line">        eventLoop-&gt;maxfd = fd;</span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>aeApiAddEvent</strong></p>
<p>aeApiAddEvent用于注册事件（ae_epoll.c文件中）：</p>
<ol>
<li>从eventLoop获取aeApiState，因为aeApiState中的epfd记录了epoll实例</li>
<li>创建了epoll_event类型的变量ee，用于记录操作类型、要监听的文件描述符以及事件类型，在调用函数时使用</li>
<li>根据掩码mask判断操作类型，如果文件描述符还未设置监听事件mask掩码为AE_NONE, 类型设置为添加，否则设置为修改，操作类型有如下三种：<ul>
<li>EPOLL_CTL_ADD：用于向epoll添加监听事件</li>
<li>EPOLL_CTL_MOD：用于修改已经注册过的监听事件</li>
<li>EPOLL_CTL_ADD：用于删除监听事件</li>
</ul>
</li>
<li>将redis的可读、可写事件类型转换为epoll的类型，读事件类型为EPOLLIN，写事件为EPOLLOUT，并设置到ee的events中</li>
<li><strong>调用epoll_ctl函数添加文件描述符的监听事件</strong>，参数分别为epoll实例、操作类型、要监听的文件描述符、epoll_event类型变量ee</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取aeApiState</span></span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="comment">// 创建epoll_event类型的变量ee，添加监听事件的时候使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span> = &#123;</span><span class="number">0</span>&#125;; <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    <span class="comment">/* 如果fd文件描述符还未设置监听事件, 类型设置为添加，否则设置为修改，简言之就是根据掩码判断是添加还是修改监听事件 */</span></span><br><span class="line">    <span class="keyword">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</span><br><span class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    mask |= eventLoop-&gt;events[fd].mask; </span><br><span class="line">    <span class="comment">// 如果是可读事件，转换为epoll的读事件监听类型EPOLLIN，并设置到ee的events中</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="comment">// 如果是可写事件，转换为epoll的写事件监听类型EPOLLOUT，并设置到ee的events中</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    <span class="comment">// 记录要监听的文件描述符</span></span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="comment">// 调用epoll_ctl函数向epoll添加监听事件，参数分别为epoll实例、操作类型、要监听的文件描述符、epoll_event类型变量ee</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>Redis在启动时，调用aeCreateEventLoop创建aeEventLoop结构体和epoll实例，之后调用aeCreateFileEvent函数向内核注册TCP文件描述符的监听事件，当有客户端连接Redis服务时，TCP文件描述符产生可读事件，通过epoll可以获取产生事件的文件描述符，Redis就可以对连接请求进行处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.el是eventLoop</span></span><br><span class="line"><span class="comment">// server.ipfd[j]是监听端口的文件描述符</span></span><br><span class="line"><span class="comment">// AE_READABLE是读事件</span></span><br><span class="line"><span class="comment">// acceptTcpHandler是事件产生时的回调函数</span></span><br><span class="line">aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>aeMain函数在ae.c文件中，里面是一个while循环，它的处理逻辑如下：</p>
<ol>
<li>通过eventLoop的stop判断是否处于停止状态，如果非停止状态进入第2步</li>
<li>判断eventLoop的beforesleep是否为空，如果不为空，调用beforesleep函数</li>
<li><strong>调用了aeProcessEvents函数处理IO事件</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        <span class="comment">// 调用了aeProcessEvents处理事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>aeProcessEvents</strong></p>
<p>aeProcessEvents函数在ae.c文件中，处理逻辑如下：</p>
<ol>
<li><strong>调用aeApiPoll函数等待就绪的事件，如果有事件产生，返回就绪的文件描述符个数，aeApiPoll函数中对就绪文件描述符处理时将其放在了fired中</strong></li>
<li><strong>for循环中处理就绪的事件，通过fired可以获取到每一个产生事件的文件描述符fd，根据文件描述符fd可以在eventLoop的events中获取对应的事件aeFileEvent，aeFileEvent中记录了事件的回调函数，之后根据事件类型，调用对应的回调函数，调用回调函数的入参分别为eventLoop、文件描述符、aeFileEvent的clientData、事件类型掩码</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果没有事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果有IO事件或者时间事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略代码...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待事件，返回就绪文件描述符的数量</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* After sleep callback. */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理就绪的事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="comment">// aeApiPoll中已将就绪的事件放在了fired中,通过fired可以获取到产生事件的文件描述符fd</span></span><br><span class="line">            <span class="comment">// 根据文件描述符fd获取对应的事件aeFileEvent,aeFileEvent中记录了事件的回调函数</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="comment">// 获取文件描述符</span></span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 判断屏障 */</span></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 处理可读事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="comment">// 如果是可读事件，调用可读事件的回调函数，参数分别为eventLoop、文件描述符、aeFileEvent的clientData、事件类型掩码</span></span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 处理可写事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    <span class="comment">// 如果是写事件，调用写事件的回调函数，参数分别为eventLoop、文件描述符、aeFileEvent的clientData、事件类型掩码</span></span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">             * after the writable one. */</span></span><br><span class="line">            <span class="keyword">if</span> (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果有时间事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>aeApiPoll</strong></p>
<p>aeApiPoll处理就绪的事件：</p>
<ol>
<li><p><strong>调用IO多路复用epoll_wait函数等待事件的产生，epoll_wait函数需要传入epoll实例、记录就绪事件集合的epoll_event，这两个参数分别在aeApiState的epfd和events中</strong>，当监听的文件描述符有事件产生时，epoll_wait返回就绪的文件描述符个数</p>
</li>
<li><p>对epoll_wait返回的就绪事件进行处理，<strong>事件记录在events变量中，遍历每一个就绪的事件，将事件对应的文件描述符设置在eventLoop的fire中，后续通过fire对事件进行处理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, struct timeval *tvp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取aeApiState，aeApiState记录了epoll实例，events记录了产生的事件</span></span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="keyword">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 等待事件的产生，epoll_wait返回就绪的文件描述符个数，就绪的事件记录在state-&gt;events中</span></span><br><span class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="comment">// 处理返回的就绪事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 获取每一个就绪的事件</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">e</span> = <span class="title">state</span>-&gt;<span class="title">events</span>+<span class="title">j</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="comment">// 将就绪事件的文件描述符设置到已触发的事件fired的fd中</span></span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            <span class="comment">// 设置事件类型掩码</span></span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="处理客户端连接"><a href="#处理客户端连接" class="headerlink" title="处理客户端连接"></a>处理客户端连接</h3><p><strong>acceptTcpHandler</strong></p>
<p>由上面的调用可知，Redis在启动时，注册了AE_READABLE读事件，回调函数为acceptTcpHandler（network.c文件中）用于处理客户端连接，当有客户端与Redis连接时，epoll返回就绪的文件描述符，Redis在处理就绪的事件时调用acceptTcpHandler进行处理：</p>
<ol>
<li>调用anetTcpAccept建立连接，并返回已连接的套接字文件描述符cfd</li>
<li>调用acceptCommonHandler（network.c文件中）函数，它又调用了createClient函数，<strong>在createClient函数中调用了aeCreateFileEvent，向内核注册已连接套接字的可读监听事件</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cport, cfd, max = MAX_ACCEPTS_PER_CALL;</span><br><span class="line">    <span class="keyword">char</span> cip[NET_IP_STR_LEN];</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line">    UNUSED(privdata);</span><br><span class="line">    <span class="keyword">while</span>(max--) &#123;</span><br><span class="line">        <span class="comment">// 建立连接，返回已连接的套接字文件描述符cfd</span></span><br><span class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</span><br><span class="line">        <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"Accepting client connection: %s"</span>, server.neterr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_VERBOSE,<span class="string">"Accepted %s:%d"</span>, cip, cport);</span><br><span class="line">        <span class="comment">// 调用acceptCommonHandler处理连接，这里传入的文件描述符为已连接的套接字</span></span><br><span class="line">        acceptCommonHandler(cfd,<span class="number">0</span>,cip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptCommonHandler</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags, <span class="keyword">char</span> *ip)</span> </span>&#123;</span><br><span class="line">    client *c;</span><br><span class="line">    <span class="comment">// 调用createClient</span></span><br><span class="line">    <span class="keyword">if</span> ((c = createClient(fd)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Error registering fd event for the new client: %s (fd=%d)"</span>,</span><br><span class="line">            strerror(errno),fd);</span><br><span class="line">        close(fd); <span class="comment">/* May be already closed, just ignore errors */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>createClient</strong></p>
<p>createClient函数中调用了aeCreateFileEvent方法向内核中注册可读事件，上文可知传入的描述符是已连接套接字cfd，回调函数为readQueryFromClient，<strong>此时事件驱动框架增加了对客户端已连接套接字的监听，当客户端有数据发送到服务端时，Redis调用readQueryFromClient函数处理读事件：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,fd);</span><br><span class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</span><br><span class="line">        <span class="comment">// 注册已连接套接字的可读事件，回调函数为readQueryFromClient</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</span><br><span class="line">            readQueryFromClient, c) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            zfree(c);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="处理读事件"><a href="#处理读事件" class="headerlink" title="处理读事件"></a>处理读事件</h3><p><strong>readQueryFromClient</strong></p>
<p>readQueryFromClient函数在network.c文件中，是可读事件的回调函数，用于处理已连接套接字上的读事件，处理逻辑如下：</p>
<ol>
<li>从已连接的套接字中读取客户端的请求数据到输入缓冲区</li>
<li>调用processInputBufferAndReplicate函数处理输入缓冲区的数据</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aeProcessEvents中调用回调函数时，传入的参数分别为aeEventLoop、已连接套接字的文件描述符、aeFileEvent的clientData私有数据、事件类型掩码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    client *c = (client*) privdata;</span><br><span class="line">    <span class="keyword">int</span> nread, readlen;</span><br><span class="line">    <span class="keyword">size_t</span> qblen;</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line"></span><br><span class="line">    readlen = PROTO_IOBUF_LEN;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></span><br><span class="line">        &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> remaining = (<span class="keyword">size_t</span>)(c-&gt;bulklen+<span class="number">2</span>)-sdslen(c-&gt;querybuf);</span><br><span class="line">        <span class="keyword">if</span> (remaining &gt; <span class="number">0</span> &amp;&amp; remaining &lt; readlen) readlen = remaining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;</span><br><span class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);</span><br><span class="line">    <span class="comment">// 从已连接的套接字中读取客户端的请求数据到输入缓冲区</span></span><br><span class="line">    nread = read(fd, c-&gt;querybuf+qblen, readlen);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_VERBOSE, <span class="string">"Reading from client: %s"</span>,strerror(errno));</span><br><span class="line">            freeClient(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        serverLog(LL_VERBOSE, <span class="string">"Client closed connection"</span>);</span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) &#123;</span><br><span class="line">        c-&gt;pending_querybuf = sdscatlen(c-&gt;pending_querybuf,</span><br><span class="line">                                        c-&gt;querybuf+qblen,nread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 处理输入缓冲区数据 */</span></span><br><span class="line">    processInputBufferAndReplicate(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理写事件"><a href="#处理写事件" class="headerlink" title="处理写事件"></a>处理写事件</h3><p>在aeMain调用aeProcessEvents之前，先调用了beforeSleep方法，beforeSleep中又调用了handleClientsWithPendingWrites，它会将Redis Server缓冲区的数据写回到客户端：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle writes with pending output buffers. */</span></span><br><span class="line">    handleClientsWithPendingWrites();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;.</span><br></pre></td></tr></table></figure></p>
<p><strong>handleClientsWithPendingWrites</strong></p>
<p><strong>Redis Server收到客户端的请求命令后，需要处理请求，然后将要返回的数据写回到客户端，写回到客户端的逻辑在handleClientsWithPendingWrites函数中</strong>，处理逻辑如下：</p>
<ol>
<li>获取待写回数据的客户端列表</li>
<li>遍历每一个待写回数据的客户端，调用writeToClient方法将缓冲区的数据写到客户端socket中，<strong>然后调用clientHasPendingReplies方法判断数据是否全部写回，如果为否，则调用aeCreateFileEvent向内核注册客户端文件描述符的可写事件监听，交由回调函数sendReplyToClient处理</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWithPendingWrites</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="keyword">int</span> processed = listLength(server.clients_pending_write);</span><br><span class="line">    <span class="comment">// 获取待写回数据的客户端列表</span></span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="comment">// 遍历每一个待写回数据的客户端</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;</span><br><span class="line">        listDelNode(server.clients_pending_write,ln);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PROTECTED) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将缓冲区的数据写到客户端socket中 */</span></span><br><span class="line">        <span class="keyword">if</span> (writeToClient(c-&gt;fd,c,<span class="number">0</span>) == C_ERR) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果数据未全部写回到客户端 */</span></span><br><span class="line">        <span class="keyword">if</span> (clientHasPendingReplies(c)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ae_flags = AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (server.aof_state == AOF_ON &amp;&amp;</span><br><span class="line">                server.aof_fsync == AOF_FSYNC_ALWAYS)</span><br><span class="line">            &#123;</span><br><span class="line">                ae_flags |= AE_BARRIER;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用aeCreateFileEvent方法，向内核注册客户端文件描述符的可写事件监听，交由回调函数sendReplyToClient处理</span></span><br><span class="line">            <span class="keyword">if</span> (aeCreateFileEvent(server.el, c-&gt;fd, ae_flags,</span><br><span class="line">                sendReplyToClient, c) == AE_ERR)</span><br><span class="line">            &#123;</span><br><span class="line">                    freeClientAsync(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>clientHasPendingReplies</strong></p>
<p>有时由于网络原因或者其他原因，可能只发出去了部分数据，客户端如果一直未从缓冲区读取数据，在缓冲区已满的情况，服务端将无法往客户端发送数据，所以调用clientHasPendingReplies函数判断数据是否写回完毕，如果未写回完毕交由事件循环驱动处理，提高处理效率。</p>
</blockquote>
<p><strong>整体流程图</strong><br><img src="/images/redis事件驱动流程.jpg" alt=""></p>
<p><strong>总结</strong><br><img src="/images/redis事件驱动总结.jpg" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a></p>
<p><a href="https://my.oschina.net/u/4350001/blog/3676193" target="_blank" rel="noopener">【osc_avxkth26】Redis 网络通信模块源码分析（3）</a></p>
<p><a href="https://www.cnblogs.com/jeakeven/p/4902332.html" target="_blank" rel="noopener">网络通信 –&gt; epoll用法</a></p>
<p><strong>Redis版本：redis-5.0.8</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/19/【Spring】AOP实现原理（三）：创建代理（基于注解）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/19/【Spring】AOP实现原理（三）：创建代理（基于注解）/" itemprop="url">【Spring】AOP实现原理（三）：创建代理（基于注解）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-19T21:00:00+08:00">
                2022-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="AbstractAutoProxyCreator"><a href="#AbstractAutoProxyCreator" class="headerlink" title="AbstractAutoProxyCreator"></a>AbstractAutoProxyCreator</h1><p>在AbstractAutoProxyCreator的wrapIfNecessary方法中，调用getAdvicesAndAdvisorsForBean方法获取到所有的Advisor之后，就可以创建代理对象了，创建的具体过程在createProxy方法中：</p>
<ol>
<li>创建代理工厂ProxyFactory</li>
<li>调用buildAdvisors构建Advisor，<strong>入参是getAdvicesAndAdvisorsForBean获取到的Advice和Advisor，里面又调用了AdvisorAdapterRegistry的wrap方法判断Advice是否是Advisor类型，这一步主要是对通知Advice进行校验，如果通知不是Advisor类型将其包装为Advisor</strong></li>
<li>通过代理工厂ProxyFactory生成代理对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有必要生成代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Advices和Advisors</span></span><br><span class="line">        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">            <span class="comment">// 创建代理，specificInterceptors就是获取到的Advices和Advisors</span></span><br><span class="line">            Object proxy = createProxy(</span><br><span class="line">                    bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">            <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 @Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">            AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.创建代理工厂</span></span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">                proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.构建Advisor</span></span><br><span class="line">        Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">        <span class="comment">// 设置Advisor</span></span><br><span class="line">        proxyFactory.addAdvisors(advisors);</span><br><span class="line">        proxyFactory.setTargetSource(targetSource);</span><br><span class="line">        customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">        proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">        <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">            proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.生成代理对象</span></span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="构建Advisor"><a href="#构建Advisor" class="headerlink" title="构建Advisor"></a>构建Advisor</h2><p>AbstractAutoProxyCreator的buildAdvisors主要是对通知Advice进行校验，如果通知不是Advisor类型将其包装为Advisor，具体是通过AdvisorAdapterRegistry的wrap方法实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用GlobalAdvisorAdapterRegistry的getInstance获取AdvisorAdapterRegistry实例</span></span><br><span class="line">    <span class="keyword">private</span> AdvisorAdapterRegistry advisorAdapterRegistry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建Advisors，specificInterceptors是上一步获取到的Advice和Advisor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Advisor[] buildAdvisors(<span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> Object[] specificInterceptors) &#123;</span><br><span class="line">        <span class="comment">// Handle prototypes correctly...</span></span><br><span class="line">        Advisor[] commonInterceptors = resolveInterceptorNames();</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; allInterceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (specificInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将获取到的Advice和Advisor添加到拦截器中</span></span><br><span class="line">            allInterceptors.addAll(Arrays.asList(specificInterceptors));</span><br><span class="line">            <span class="keyword">if</span> (commonInterceptors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.applyCommonInterceptorsFirst) &#123;</span><br><span class="line">                    allInterceptors.addAll(<span class="number">0</span>, Arrays.asList(commonInterceptors));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    allInterceptors.addAll(Arrays.asList(commonInterceptors));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nrOfCommonInterceptors = commonInterceptors.length;</span><br><span class="line">            <span class="keyword">int</span> nrOfSpecificInterceptors = (specificInterceptors != <span class="keyword">null</span> ? specificInterceptors.length : <span class="number">0</span>);</span><br><span class="line">            logger.trace(<span class="string">"Creating implicit proxy for bean '"</span> + beanName + <span class="string">"' with "</span> + nrOfCommonInterceptors +</span><br><span class="line">                    <span class="string">" common interceptors and "</span> + nrOfSpecificInterceptors + <span class="string">" specific interceptors"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建Advisor集合</span></span><br><span class="line">        Advisor[] advisors = <span class="keyword">new</span> Advisor[allInterceptors.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allInterceptors.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 调用AdvisorAdapterRegistry的wrap方法将通知包装为Advisor进行增强，在DefaultAdvisorAdapterRegistry中实现</span></span><br><span class="line">            advisors[i] = <span class="keyword">this</span>.advisorAdapterRegistry.wrap(allInterceptors.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> advisors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AdvisorAdapterRegistry</strong></p>
<p>在GlobalAdvisorAdapterRegistry中可以看到使用的是DefaultAdvisorAdapterRegistry：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalAdvisorAdapterRegistry</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用DefaultAdvisorAdapterRegistry</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AdvisorAdapterRegistry instance = <span class="keyword">new</span> DefaultAdvisorAdapterRegistry();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回AdvisorAdapterRegistry</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AdvisorAdapterRegistry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DefaultAdvisorAdapterRegistry"><a href="#DefaultAdvisorAdapterRegistry" class="headerlink" title="DefaultAdvisorAdapterRegistry"></a>DefaultAdvisorAdapterRegistry</h3><p>DefaultAdvisorAdapterRegistry中的wrap方法主要逻辑如下：</p>
<ol>
<li>如果当前的通知已经是Advisor类型直接返回即可</li>
<li>如果当前的通知不是Advice类型，抛出异常</li>
<li>将通知转为Advice，对通知进行判断<ul>
<li>如果通知是MethodInterceptor方法拦截器，将其包装为DefaultPointcutAdvisor</li>
<li>如果不是MethodInterceptor，遍历Adapter适配器，找出支持当前通知的适配器，再将通知包装为DefaultPointcutAdvisor返回</li>
</ul>
</li>
<li>非以上几种情况抛出异常</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorAdapterRegistry</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapterRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advisor <span class="title">wrap</span><span class="params">(Object adviceObject)</span> <span class="keyword">throws</span> UnknownAdviceTypeException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果已经是Advisor，返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (adviceObject <span class="keyword">instanceof</span> Advisor) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Advisor) adviceObject;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是Advice类型，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!(adviceObject <span class="keyword">instanceof</span> Advice)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(adviceObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转为Advice</span></span><br><span class="line">        Advice advice = (Advice) adviceObject;</span><br><span class="line">        <span class="comment">// 如果是一个方法拦截器</span></span><br><span class="line">        <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line">            <span class="comment">// 包装为DefaultPointcutAdvisor</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line">            <span class="comment">// 判断Advisor适配器是否支持当前的Advice</span></span><br><span class="line">            <span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">                <span class="comment">// 包装为DefaultPointcutAdvisor</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成代理对象"><a href="#生成代理对象" class="headerlink" title="生成代理对象"></a>生成代理对象</h2><p>上一步中已经对所有的Advice进行了校验，转为了Advisor进行增强，接下来就可以生成代理对象了，具体实现在ProxyFactory的getProxy中：</p>
<ol>
<li><p>调用createAopProxy获取AopProxy，AopProxy是一个接口，定义了getProxy获取代理对象的方法，它有两个实现类分别为<strong>CglibAopProxy</strong>和<strong>JdkDynamicAopProxy</strong></p>
<p><img src="/images/AOPPROXY.png" alt=""></p>
</li>
<li><p>调用AopProxy的getProxy方法获取代理对象 </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">extends</span> <span class="title">ProxyCreatorSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过工厂创建AOP代理对象，createAopProxy方法在ProxyCreatorSupport中实现</span></span><br><span class="line">        <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="createAopProxy创建AopProxy"><a href="#createAopProxy创建AopProxy" class="headerlink" title="createAopProxy创建AopProxy"></a>createAopProxy创建AopProxy</h3><p>createAopProxy的实现逻辑在ProxyFactory的父类ProxyCreatorSupport中实现，它使用了工厂模式生成代理对象：</p>
<ol>
<li>调用getAopProxyFactory方法获取AopProxyFactory，在无参构造函数中可以看的默认使用的工厂是DefaultAopProxyFactory</li>
<li>调用AopProxyFactory的createAopProxy方法创建代理对象 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProxyCreatorSupport</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCreatorSupport</span> <span class="keyword">extends</span> <span class="title">AdvisedSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AOP代理工厂</span></span><br><span class="line">    <span class="keyword">private</span> AopProxyFactory aopProxyFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyCreatorSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 工厂的实现默认使用DefaultAopProxyFactory</span></span><br><span class="line">        <span class="keyword">this</span>.aopProxyFactory = <span class="keyword">new</span> DefaultAopProxyFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带有AopProxyFactory参数的构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyCreatorSupport</span><span class="params">(AopProxyFactory aopProxyFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(aopProxyFactory, <span class="string">"AopProxyFactory must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.aopProxyFactory = aopProxyFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建AopProxy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">            activate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.调用getAopProxyFactory获取AopProxy，2.调用AopProxy的createAopProxy创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回AOP代理工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxyFactory <span class="title">getAopProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.aopProxyFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DefaultAopProxyFactory"><a href="#DefaultAopProxyFactory" class="headerlink" title="DefaultAopProxyFactory"></a>DefaultAopProxyFactory</h4><p>DefaultAopProxyFactory中创建AOP代理的逻辑如下：</p>
<ol>
<li>获取目标对象的Class信息</li>
<li>对Class进行判断：<ul>
<li><strong>如果是一个接口或者isProxyClass返回true使用JDK动态代理生成代理对象，</strong>isProxyClass方法在JDK的Proxy中实现，返回true的条件为目标类是java.lang.reflect.Proxy的子类并且缓存中包含目标类</li>
<li><strong>如果上一个条件不满足则使用CGLIB生成代理对象</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            <span class="comment">// 获取目标对象的Class信息</span></span><br><span class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">            <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                        <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是一个接口</span></span><br><span class="line">            <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则使用CGLIB生成代理对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.reflect.Proxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否是java.lang.reflect.Proxy的子类并且缓存中包含目标类</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.class.isAssignableFrom(cl) &amp;&amp; proxyClassCache.containsValue(cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此AopProxy已经创建成功，接下来以JdkDynamicAopProxy为例查看getProxy获取代理对象过程。</p>
<h3 id="getProxy获取代理对象"><a href="#getProxy获取代理对象" class="headerlink" title="getProxy获取代理对象"></a>getProxy获取代理对象</h3><p>JdkDynamicAopProxy是通过JDK的动态代理实现代理创建的，可以看到它实现了InvocationHandler接口，关于JDK的动态代理实现原理可参考<a href="https://shan-ml.github.io/2021/09/07/%E3%80%90JAVA%E3%80%91%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">【JAVA】动态代理</a>，这里我们需要关注getProxy和invoke方法：</p>
<ul>
<li><strong>getProxy：</strong>创建代理对象</li>
<li><strong>invoke：</strong>当代理对象中引用的方法执行时会进入这个方法中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Creating JDK dynamic proxy: "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">        <span class="comment">// 生成代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 先省略</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getProxy创建代理对象"><a href="#getProxy创建代理对象" class="headerlink" title="getProxy创建代理对象"></a>getProxy创建代理对象</h4><p>可以看到是通过JDK中Proxy的newProxyInstance生成代理对象的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Creating JDK dynamic proxy: "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">        <span class="comment">// 生成代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="invoke方法"><a href="#invoke方法" class="headerlink" title="invoke方法"></a>invoke方法</h1><p>当调用AOP中需要被通知拦截的方法时，会进入到invoke方法，<strong>比较核心的是getInterceptorsAndDynamicInterceptionAdvice获取拦截器链，如果为空直接通过反射执行目标方法即可，如果不为空，将方法包装为MethodInvocation，然后执行拦截器链</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** AdvisedSupport */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * InvocationHandler中定义的invoke方法，当目标方法执行时会进入到这个方法中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 需要被执行的目标方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">        Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是equals方法</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">                <span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">                <span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">                <span class="comment">// 如果是hashCode方法</span></span><br><span class="line">                <span class="keyword">return</span> hashCode();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">                <span class="comment">// 如果方法所在类是DecoratingProxy类</span></span><br><span class="line">                <span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">                    method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">                <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object retVal;</span><br><span class="line">            <span class="comment">// 是否需要暴露代理</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">                oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            target = targetSource.getTarget();</span><br><span class="line">            Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前方法的拦截器链</span></span><br><span class="line">            List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 校验拦截器链是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">                <span class="comment">// 如果为空直接执行目标方法即可</span></span><br><span class="line">                retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 创建MethodInvocation</span></span><br><span class="line">                MethodInvocation invocation =</span><br><span class="line">                        <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">                <span class="comment">// 执行拦截器链</span></span><br><span class="line">                retVal = invocation.proceed();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取方法返回值</span></span><br><span class="line">            Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">            <span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">                    returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">                    !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">                retVal = proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">                        <span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">                <span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">                targetSource.releaseTarget(target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">                <span class="comment">// Restore old proxy.</span></span><br><span class="line">                AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取方法的拦截器链"><a href="#获取方法的拦截器链" class="headerlink" title="获取方法的拦截器链"></a>获取方法的拦截器链</h2><p>获取目标方法的拦截器链在AdvisedSupport中实现，<strong>它主要用于将适用于当前方法的Advisor转为方法拦截器</strong>，首先它先从缓存中查询，如果未查询到，调用advisorChainFactory方法的getInterceptorsAndDynamicInterceptionAdvice进行获取，在DefaultAdvisorChainFactory中实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">extends</span> <span class="title">ProxyConfig</span> <span class="keyword">implements</span> <span class="title">Advised</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** AdvisorChainFactory，默认使用DefaultAdvisorChainFactory*/</span></span><br><span class="line">    AdvisorChainFactory advisorChainFactory = <span class="keyword">new</span> DefaultAdvisorChainFactory();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取方法的拦截器链</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建缓存KEY</span></span><br><span class="line">        MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</span><br><span class="line">        <span class="comment">// 从缓存获取</span></span><br><span class="line">        List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果未从缓存中获取到，调用getInterceptorsAndDynamicInterceptionAdvice获取方法的拦截器链</span></span><br><span class="line">            cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">                    <span class="keyword">this</span>, method, targetClass);</span><br><span class="line">            <span class="comment">// 加入到缓存</span></span><br><span class="line">            <span class="keyword">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cached;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="DefaultAdvisorChainFactory"><a href="#DefaultAdvisorChainFactory" class="headerlink" title="DefaultAdvisorChainFactory"></a>DefaultAdvisorChainFactory</h3><p>getInterceptorsAndDynamicInterceptionAdvice中先获取了所有的Advisor，然后遍历Advisor，对Advisor进行判断：</p>
<ol>
<li><p>如果是PointcutAdvisor类型，<strong>将Advisor转为PointcutAdvisor，然后获取Pointcut切点的ClassFilter，通过matches方法判断当前方法所属的class是否匹配，如果匹配，则从切点中获取MethodMatcher方法匹配器，调用它的matches方法判断切点与当前方法是否匹配，如果也匹配，调用AdvisorAdapterRegistry的getInterceptors将Advisor转为方法拦截器</strong></p>
</li>
<li><p>如果是引入通知IntroductionAdvisor，并且ClassFilter的matches与当前类匹配，调用AdvisorAdapterRegistry的getInterceptors将Advisor转为方法拦截器</p>
</li>
<li>非以上两种情况，调用AdvisorAdapterRegistry的getInterceptors将Advisor转为方法拦截器</li>
</ol>
<p>可以看到以上三种情况，最后都是调用了AdvisorAdapterRegistry获取拦截器的，接下来就进入AdvisorAdapterRegistry中查看getInterceptors的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorChainFactory</span> <span class="keyword">implements</span> <span class="title">AdvisorChainFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取方法的拦截器链</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Advised config, Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取AdvisorAdapterRegistry</span></span><br><span class="line">        AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line">        <span class="comment">// 获取Advisor</span></span><br><span class="line">        Advisor[] advisors = config.getAdvisors();</span><br><span class="line">        List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;&gt;(advisors.length);</span><br><span class="line">        Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">        Boolean hasIntroductions = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 遍历Advisor</span></span><br><span class="line">        <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">            <span class="comment">// 如果是PointcutAdvisor类型</span></span><br><span class="line">            <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">                <span class="comment">// Add it conditionally.</span></span><br><span class="line">                PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">                <span class="comment">// 调用matches方法判断与当前class是否匹配</span></span><br><span class="line">                <span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">                    <span class="comment">// 获取方法匹配器MethodMatcher</span></span><br><span class="line">                    MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">                    <span class="keyword">boolean</span> match;</span><br><span class="line">                    <span class="comment">// 如果是IntroductionAwareMethodMatcher</span></span><br><span class="line">                    <span class="keyword">if</span> (mm <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hasIntroductions == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hasIntroductions = hasMatchingIntroductions(advisors, actualClass);</span><br><span class="line">                        &#125;</span><br><span class="line">                        match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用MethodMatcher的matches方法匹配</span></span><br><span class="line">                        match = mm.matches(method, actualClass);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                        <span class="comment">// 如果匹配，从registry中获取方法拦截器</span></span><br><span class="line">                        MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                        <span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line">                            <span class="comment">// Creating a new object instance in the getInterceptors() method</span></span><br><span class="line">                            <span class="comment">// isn't a problem as we normally cache created chains.</span></span><br><span class="line">                            <span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">                                <span class="comment">// 将拦截器封装为InterceptorAndDynamicMethodMatcher</span></span><br><span class="line">                                interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">                <span class="comment">// 如果是引入通知IntroductionAdvisor</span></span><br><span class="line">                IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">                <span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">                    Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                    interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> interceptorList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DefaultAdvisorAdapterRegistry-1"><a href="#DefaultAdvisorAdapterRegistry-1" class="headerlink" title="DefaultAdvisorAdapterRegistry"></a>DefaultAdvisorAdapterRegistry</h3><p>在DefaultAdvisorAdapterRegistry的构造函数中注册了三种AdvisorAdapter，使用了适配器模式将Advisor转换为方法拦截器MethodInterceptor，三种AdvisorAdapter分别为：</p>
<ul>
<li>MethodBeforeAdviceAdapter：支持前置通知MethodBeforeAdvice</li>
<li>AfterReturningAdviceAdapter：支持返回通知AfterReturningAdvice</li>
<li>ThrowsAdviceAdapter：支持ThrowsAdvice</li>
</ul>
<p><strong>AspectJAfterThrowingAdvice、AspectJAroundAdvice和AspectJAfterAdvice本身已经实现了MethodInterceptor接口，所以不需要进行转换：</strong></p>
<p><img src="/images/Advice.png" alt=""></p>
<p>在getInterceptors方法中，<strong>对Advisor进行判断，如果本身已经是MethodInterceptor直接返回即可，否则遍历所有的AdvisorAdapter，找出支持当前Advisor的Adapter，然后将Advisor转为MethodInterceptor：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorAdapterRegistry</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapterRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;AdvisorAdapter&gt; adapters = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  注册AdvisorAdapter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultAdvisorAdapterRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册MethodBeforeAdviceAdapter</span></span><br><span class="line">        registerAdvisorAdapter(<span class="keyword">new</span> MethodBeforeAdviceAdapter());</span><br><span class="line">        <span class="comment">// 注册AfterReturningAdviceAdapter</span></span><br><span class="line">        registerAdvisorAdapter(<span class="keyword">new</span> AfterReturningAdviceAdapter());</span><br><span class="line">        <span class="comment">// 注册ThrowsAdviceAdapter</span></span><br><span class="line">        registerAdvisorAdapter(<span class="keyword">new</span> ThrowsAdviceAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MethodInterceptor[] getInterceptors(Advisor advisor) <span class="keyword">throws</span> UnknownAdviceTypeException &#123;</span><br><span class="line">        List&lt;MethodInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 从Advisor中获取Advice</span></span><br><span class="line">        Advice advice = advisor.getAdvice();</span><br><span class="line">        <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line">            interceptors.add((MethodInterceptor) advice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历Adapter</span></span><br><span class="line">        <span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line">            <span class="comment">// 判断是否支持当前的通知</span></span><br><span class="line">            <span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">                <span class="comment">// 通过Adapter获取拦截器</span></span><br><span class="line">                interceptors.add(adapter.getInterceptor(advisor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (interceptors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advisor.getAdvice());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> interceptors.toArray(<span class="keyword">new</span> MethodInterceptor[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AdvisorAdapter有三个实现类，以MethodBeforeAdviceAdapter为例查看一下supportsAdvice和getInterceptor的实现：</p>
<p><img src="images/AdvisorAdapter.png" alt=""></p>
<ol>
<li><p>在supportsAdvice方法中可以看到它支持的是MethodBeforeAdvice方法前置通知</p>
</li>
<li><p>在getInterceptor方法中，首先从Advisor中获取到了通知，然后将通知封装为MethodBeforeAdviceInterceptor返回</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否是MethodBeforeAdvice类型</span></span><br><span class="line">        <span class="keyword">return</span> (advice <span class="keyword">instanceof</span> MethodBeforeAdvice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">        MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();</span><br><span class="line">        <span class="comment">// 封装为MethodBeforeAdviceInterceptor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdviceInterceptor(advice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="执行目标方法"><a href="#执行目标方法" class="headerlink" title="执行目标方法"></a>执行目标方法</h2><p>回顾invoke方法中的主要逻辑，在获取到方法的拦截器之后，对拦截器是否为空进行了判断：</p>
<ul>
<li><p>如果为空，调用AopUtils的invokeJoinpointUsingReflection通过反射直接执行方法即可</p>
</li>
<li><p>如果不为空创建MethodInvocation，具体实现类是ReflectiveMethodInvocation，然后调用proceed执行拦截器链</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 获取当前方法的拦截器链</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验拦截器链是否为空</span></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">    <span class="comment">// 如果为空直接执行目标方法即可</span></span><br><span class="line">    retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 创建MethodInvocation，使用的是ReflectiveMethodInvocation类型</span></span><br><span class="line">    MethodInvocation invocation =</span><br><span class="line">            <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">    <span class="comment">// 执行拦截器链</span></span><br><span class="line">    retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="invokeJoinpointUsingReflection"><a href="#invokeJoinpointUsingReflection" class="headerlink" title="invokeJoinpointUsingReflection"></a>invokeJoinpointUsingReflection</h3><p>invokeJoinpointUsingReflection方法通过反射执行目标方法，在AopUtils中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AopUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">invokeJoinpointUsingReflection</span><span class="params">(@Nullable Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射执行目标方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"AOP configuration seems to be invalid: tried calling method ["</span> +</span><br><span class="line">                    method + <span class="string">"] on target ["</span> + target + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Could not access method ["</span> + method + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="proceed方法执行拦截器链"><a href="#proceed方法执行拦截器链" class="headerlink" title="proceed方法执行拦截器链"></a>proceed方法执行拦截器链</h3><p>因为拦截器可以有多个，所以proceed方法是一个递归调用的过程，currentInterceptorIndex记录了当前拦截器的下标：</p>
<ol>
<li>判断currentInterceptorIndex是否与拦截器链的大小一致，如果一致说明已经走到了最后一个拦截器，调用invokeJoinpoint方法执行目标方法即可，可以看到调用了AopUtils的invokeJoinpointUsingReflection通过反射执行目标方法，如果不是最后一个拦截器进入第2步</li>
<li>对currentInterceptorIndex++，获取下一个拦截器，判断拦截器是否是InterceptorAndDynamicMethodMatcher类型，如果是获取methodMatcher对目标方法进行匹配：<ul>
<li>如果与目标方法匹配成功，执行拦截器的invoke方法</li>
<li>如果与目标方法匹配不成功，递归调用proceed方法执行下一个拦截器</li>
</ul>
</li>
<li>如果拦截器不是InterceptorAndDynamicMethodMatcher类型，直接调用方法拦截器MethodInterceptor的invoke执行拦截器即可</li>
</ol>
<p><strong>在执行MethodInterceptor方法拦截器的invoke方法时，传入的参数是this，指的是ReflectiveMethodInvocation对象本身，在拦截器方法执行后需要拿到这个对象调用proceed方法继续执行下一个拦截器，可以看到这里使用了责任链模式，对拦截器进行一个个的调用。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveMethodInvocation</span> <span class="keyword">implements</span> <span class="title">ProxyMethodInvocation</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行方法</span></span><br><span class="line">            <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取下一个拦截器</span></span><br><span class="line">        Object interceptorOrInterceptionAdvice =</span><br><span class="line">                <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">        <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">            <span class="comment">// 如果是InterceptorAndDynamicMethodMatcher</span></span><br><span class="line">            InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                    (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">            Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">            <span class="comment">// 判断方法是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">                <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Dynamic matching failed.</span></span><br><span class="line">                <span class="comment">// 如果方法不匹配，跳过当前拦截器执行下一个，递归调用</span></span><br><span class="line">                <span class="keyword">return</span> proceed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 转为MethodInterceptor执行拦截器，注意invoke传入的参数是this，指的是ReflectiveMethodInvocation对象本身，在拦截器的invoke方法中需要拿到这个对象调用proceed方法继续执行下一个拦截器</span></span><br><span class="line">            <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射执行目标方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeJoinpoint</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.target, <span class="keyword">this</span>.method, <span class="keyword">this</span>.arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MethodBeforeAdviceInterceptor</strong></p>
<p>以前置通知为例，看一下MethodBeforeAdviceInterceptor拦截器中的invoke方法的执行逻辑：</p>
<ol>
<li>前置通知是在目标方法执行之前执行的方法，所以先调用了invokeAdviceMethod执行了前置通知方法</li>
<li>调用MethodInvocation的proceed执行下一个拦截器链，在上一步中可以看到调用拦截器时传入的是this，this指向ReflectiveMethodInvocation，所以会继续执行到它的proceed方法，继续下一个拦截器的执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">BeforeAdvice</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 先执行通知方法，在AspectJMethodBeforeAdvice中实现</span></span><br><span class="line">        <span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">        <span class="comment">// 执行拦截器链，这里调用的是MethodInvocation的proceed方法，会再次进入到ReflectiveMethodInvocation的proceed方法中</span></span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AspectJMethodBeforeAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJMethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, @Nullable Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 执行通知方法</span></span><br><span class="line">        invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AspectJAroundAdvice</strong></p>
<p>再以环绕通知为例，看一下环绕通知的执行逻辑，AspectJAroundAdvice实现了MethodInterceptor接口，所以它本身就是一个拦截器，在invoke方法中它调用了invokeAdviceMethod执行通知方法，<strong>并将ReflectiveMethodInvocation转换为ProceedingJoinPoint，在环绕通知中通过ProceedingJoinPoint调用proceed方法执行下一个拦截器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAroundAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(mi <span class="keyword">instanceof</span> ProxyMethodInvocation)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"MethodInvocation is not a Spring ProxyMethodInvocation: "</span> + mi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mi是上一步中传入的ReflectiveMethodInvocation，这里将其转换为ProxyMethodInvocation</span></span><br><span class="line">        ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;</span><br><span class="line">        <span class="comment">// 将ProxyMethodInvocation转为ProceedingJoinPoint</span></span><br><span class="line">        ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);</span><br><span class="line">        JoinPointMatch jpm = getJoinPointMatch(pmi);</span><br><span class="line">        <span class="comment">// 执行通知方法</span></span><br><span class="line">        <span class="keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAspectJAdvice</span> <span class="keyword">implements</span> <span class="title">Advice</span>, <span class="title">AspectJPrecedenceInformation</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行通知方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethod</span><span class="params">(JoinPoint jp, @Nullable JoinPointMatch jpMatch,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        @Nullable Object returnValue, @Nullable Throwable t)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 通过给定的参数执行通知方法</span></span><br><span class="line">        <span class="keyword">return</span> invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过给定的参数执行通知方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethodWithGivenArgs</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] actualArgs = args;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdviceMethod.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">            actualArgs = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReflectionUtils.makeAccessible(<span class="keyword">this</span>.aspectJAdviceMethod);</span><br><span class="line">            <span class="comment">// 这里执行了通知方法,接下来会进入到定义的环绕通知方法中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.aspectJAdviceMethod.invoke(<span class="keyword">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Mismatch on arguments to advice method ["</span> +</span><br><span class="line">                    <span class="keyword">this</span>.aspectJAdviceMethod + <span class="string">"]; pointcut expression ["</span> +</span><br><span class="line">                    <span class="keyword">this</span>.pointcut.getPointcutExpression() + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设定义了如下的环绕通知，在环绕通知方法被执行时，会进入到logAroudAdvice方法中，可以看到先打印了方法执行前的日志，然后调用了ProceedingJoinPoint的proceed方法执行拦截器链，上一步可知ProceedingJoinPoint是MethodInvocation转换而来，所以又会进入到ReflectiveMethodInvocation的proceed方法执行下一个拦截器链，待所有的拦截器执行完毕后proceed方法也就结束，然后执行了printAfterLog打印方法执行后的日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知Advice，这里使用了环绕通知</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> joinPoint 连接点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"logPoiontcut()"</span>) <span class="comment">// 引用切点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">logAroudAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 方法执行前的日志打印</span></span><br><span class="line">    printBeforeLog(joinPoint);</span><br><span class="line">    <span class="comment">// 执行拦截器链</span></span><br><span class="line">    Object returnValue = joinPoint.proceed();</span><br><span class="line">    <span class="comment">// 方法执行后的日志打印</span></span><br><span class="line">    printAfterLog(returnValue);</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>方法拦截器链的执行流程图</strong><br><img src="/images/aop执行流程.jpeg" alt=""></p>
<p><strong>AOP总结</strong></p>
<p><img src="/images/AOP总结二.png" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://blog.csdn.net/qq_36882793/article/details/106440723" target="_blank" rel="noopener">【猫吻鱼】Spring源码分析：全集整理</a></p>
<p><strong>Spring版本：5.2.5.RELEASE</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/19/【Spring】AOP实现原理（二）：Advisor获取（基于注解）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/19/【Spring】AOP实现原理（二）：Advisor获取（基于注解）/" itemprop="url">【Spring】AOP实现原理（二）：Advisor获取（基于注解）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-19T21:00:00+08:00">
                2022-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h1><p>@EnableAspectJAutoProxy注解可以用来开启AOP，那么就从@EnableAspectJAutoProxy入手学习一下Spring AOP的实现原理。</p>
<ol>
<li>@EnableAspectJAutoProxy导入了AspectJAutoProxyRegistrar。</li>
<li>定义了proxyTargetClass属性，表示是否使用CGLIB生成代理对象，默认返回false，默认是使用JDK动态代理创建代理对象的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(AspectJAutoProxyRegistrar.class)<span class="comment">// 导入了AspectJAutoProxyRegistrar</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否使用CGLIB生成代理对象，默认为false，默认是使用JDK动态代理创建代理对象的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否暴露代理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AspectJAutoProxyRegistrar"><a href="#AspectJAutoProxyRegistrar" class="headerlink" title="AspectJAutoProxyRegistrar"></a>AspectJAutoProxyRegistrar</h1><p>AspectJAutoProxyRegistrar是一个代理注册器，它实现了ImportBeanDefinitionRegistrar接口，<strong>ImportBeanDefinitionRegistrar可以向容器中注册bean，AspectJAutoProxyRegistrar实现了它应该是为了向容器中注册bean，那么看一下registerBeanDefinitions方法里面注册了什么</strong>。</p>
<p>在registerBeanDefinitions方法中它调用了AopConfigUtils的registerAspectJAnnotationAutoProxyCreatorIfNecessary方法<strong>向容器中注册了自动代理创建器，通过名称可以看出它与AspectJ注解以及代理创建有关</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AspectJ自动代理注册器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册BeanDefinitions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向容器中注册代理创建器</span></span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">        AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取proxyTargetClass</span></span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"proxyTargetClass"</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取exposeProxy</span></span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"exposeProxy"</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注册自动代理创建器"><a href="#注册自动代理创建器" class="headerlink" title="注册自动代理创建器"></a>注册自动代理创建器</h2><p>registerAspectJAnnotationAutoProxyCreatorIfNecessary在AopConfigUtils中实现：</p>
<ol>
<li>定义了一个自动代理创建器集合，是一个List，List里面的存储顺序代表了优先级，一共有三种代理创建器<ul>
<li>InfrastructureAdvisorAutoProxyCreator：优先级最低</li>
<li>AspectJAwareAdvisorAutoProxyCreator：优先级较InfrastructureAdvisorAutoProxyCreator高</li>
<li>AnnotationAwareAspectJAutoProxyCreator：优先级最高</li>
</ul>
</li>
<li><strong>Spring AOP默认使用的是AnnotationAwareAspectJAutoProxyCreator类型的创建器</strong>，向容器中注册的时候会判断容器中是否已经存在代理创建器：<ul>
<li>如果已经存在，从容器中取出创建器，判断优先级是否比AnnotationAwareAspectJAutoProxyCreator高，如果低于AnnotationAwareAspectJAutoProxyCreator，则使用AnnotationAwareAspectJAutoProxyCreator进行替换。</li>
<li>如果不存在，直接向容器中注册AnnotationAwareAspectJAutoProxyCreator类型的bean即可。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AopConfigUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动代理创建器beanName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTO_PROXY_CREATOR_BEAN_NAME =</span><br><span class="line">            <span class="string">"org.springframework.aop.config.internalAutoProxyCreator"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动创建器集合，是一个List，List里面的存储顺序代表了优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 向List中添加具体的代理创建器</span></span><br><span class="line">        APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">        APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);</span><br><span class="line">        APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用下面的registerAspectJAnnotationAutoProxyCreatorIfNecessary方法</span></span><br><span class="line">        <span class="keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里可以看到，注册的是AnnotationAwareAspectJAutoProxyCreator类型的</span></span><br><span class="line">        <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">        <span class="comment">// 如果容器中已经包含名称为AUTO_PROXY_CREATOR_BEAN_NAME的bean</span></span><br><span class="line">        <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">            <span class="comment">// 从容器中获取</span></span><br><span class="line">            BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">            <span class="comment">// 如果当前要注册的bean与容器中已经存在的bean类型不一致</span></span><br><span class="line">            <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">                <span class="comment">// 获取容器中存在的bean的优先级</span></span><br><span class="line">                <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">                <span class="comment">// 获取要注册的bean的优先级</span></span><br><span class="line">                <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">                <span class="comment">// 容器中存在的bean的优先级比当前要注册的低</span></span><br><span class="line">                <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                    <span class="comment">// 使用当的class进行注册，也就是AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">                    apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建BeanDefinition</span></span><br><span class="line">        RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">        beanDefinition.setSource(source);</span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        <span class="comment">// 向容器中注册</span></span><br><span class="line">        registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AbstractAutoProxyCreator"><a href="#AbstractAutoProxyCreator" class="headerlink" title="AbstractAutoProxyCreator"></a>AbstractAutoProxyCreator</h1><p>自动代理创建器AbstractAutoProxyCreator用于创建代理对象，Spring AOP使用的是AnnotationAwareAspectJAutoProxyCreator类型的创建器，它是AbstractAutoProxyCreator的子类，继承关系如下：<br><img src="/images/aopproxycreator.png" alt=""></p>
<p>AnnotationAwareAspectJAutoProxyCreator的主要方法都在AbstractAutoProxyCreator中实现，AbstractAutoProxyCreator实现了SmartInstantiationAwareBeanPostProcessor，它是Spring的Bean后置处理器，后置处理器有两个比较重要的方法：</p>
<p><strong>postProcessBeforeInstantiation</strong>：在bean<strong>实例化</strong>之前执行的方法，如果有自定义的TargetSource则在这个时候就创建代理对象，可以先不管这里，主要看postProcessAfterInitialization方法。</p>
<p><strong>postProcessAfterInitialization：在bean初始化之后执行的方法，这时候bean已经实例化完毕但是还没有设置属性等信息，调用了wrapIfNecessary方法判断是否有必要生成代理对象，如果不需要创建代理对象直接返回即可，反之需要调用getAdvicesAndAdvisorsForBean获取Advice和Advisor，然后创建代理对象。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在bean实例化之前执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">        Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有自定义的TargetSource则创建代理对象</span></span><br><span class="line">        TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">            <span class="comment">// 创建代理对象</span></span><br><span class="line">            Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">            <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在bean初始化之后执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 构建缓存Key</span></span><br><span class="line">            Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">                <span class="comment">// 是否有必要创建代理</span></span><br><span class="line">                <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有必要生成代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是基础类或者需要跳过则不创建代理对象,将bean加入到advisedBeans中即可</span></span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取bean的Advices和Advisors</span></span><br><span class="line">        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">            <span class="comment">// 创建代理</span></span><br><span class="line">            Object proxy = createProxy(</span><br><span class="line">                    bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">            <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳过代理对象创建的判断"><a href="#跳过代理对象创建的判断" class="headerlink" title="跳过代理对象创建的判断"></a>跳过代理对象创建的判断</h2><p>跳过代理对象的创建主要通过以下两个方法判断的：</p>
<p><strong>1.调用isInfrastructureClass判断是否是基础类，如果是则跳过代理创建。</strong></p>
<p><strong>2.调用shouldSkip方法判断是否需要跳过创建代理。</strong></p>
<h3 id="isInfrastructureClass"><a href="#isInfrastructureClass" class="headerlink" title="isInfrastructureClass"></a>isInfrastructureClass</h3><p>需要注意AOP使用的是AnnotationAwareAspectJAutoProxyCreator作为代理创建器，所以需要先看AnnotationAwareAspectJAutoProxyCreator是否重写了该方法，实际上它确实重写isInfrastructureClass方法，在里面它调用了父类的AbstractAutoProxyCreator的isInfrastructureClass和aspectJAdvisorFactory的isAspect进行判断：</p>
<ul>
<li>isInfrastructureClass：<strong>如果是Advice、Pointcut、Advisor、AopInfrastructureBean及其子类则跳过创建</strong>，这些是Spring的基础类，不需要进行代理。</li>
<li>isAspect：是否有Aspect注解并且不是通过Ajc编译的类则是一个切面。</li>
</ul>
<p><strong>总结：如果是Advice、Pointcut、Advisor、AopInfrastructureBean及其子类或者bean是一个切面并且不是通过Ajc编译的则跳过代理创建，并将当前bean的缓存key加入到advisedBeans中（wrapIfNecessary中可以看到）。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用AbstractAutoProxyCreator的isInfrastructureClass和aspectJAdvisorFactory的isAspect方法判断,在AbstractAspectJAdvisorFactory中有实现</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">super</span>.isInfrastructureClass(beanClass) ||</span><br><span class="line">                (<span class="keyword">this</span>.aspectJAdvisorFactory != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.aspectJAdvisorFactory.isAspect(beanClass)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutoProxyCreator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是基础类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是Advice、Pointcut、Advisor、AopInfrastructureBean类型</span></span><br><span class="line">        <span class="keyword">boolean</span> retVal = Advice.class.isAssignableFrom(beanClass) ||</span><br><span class="line">                Pointcut.class.isAssignableFrom(beanClass) ||</span><br><span class="line">                Advisor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">                AopInfrastructureBean.class.isAssignableFrom(beanClass);</span><br><span class="line">        <span class="keyword">if</span> (retVal &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Did not attempt to auto-proxy infrastructure class ["</span> + beanClass.getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAspectJAdvisorFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAspectJAdvisorFactory</span> <span class="keyword">implements</span> <span class="title">AspectJAdvisorFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是切面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAspect</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否有Aspect注解并且不是通过Ajc编译的类</span></span><br><span class="line">        <span class="keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否有Aspect注解</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasAspectAnnotation</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否有Aspect注解</span></span><br><span class="line">        <span class="keyword">return</span> (AnnotationUtils.findAnnotation(clazz, Aspect.class) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否通过Ajc编译</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compiledByAjc</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Field field : clazz.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.getName().startsWith(AJC_MAGIC)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shouldSkip"><a href="#shouldSkip" class="headerlink" title="shouldSkip"></a>shouldSkip</h3><p>AnnotationAwareAspectJAutoProxyCreator中重写的shouldSkip方法具体实现在父类AspectJAwareAdvisorAutoProxyCreator里面，它获取所有候选的Advisor进行遍历，<strong>判断Advisor是否是AspectJPointcutAdvisor类型并且当前的bean与advisor的AspectName切面名称一致则跳过代理创建：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否跳过代理创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取候选的Advisors</span></span><br><span class="line">        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">        <span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line">            <span class="comment">// 如果是AspectJPointcutAdvisor类型并且当前的bean与advisor的AspectName切面名称一致，则跳过代理创建</span></span><br><span class="line">            <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;</span><br><span class="line">                    ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用父类的shouldSkip判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取所有的Advice和Advisor"><a href="#获取所有的Advice和Advisor" class="headerlink" title="获取所有的Advice和Advisor"></a>获取所有的Advice和Advisor</h2><p>getAdvicesAndAdvisorsForBean方法在AbstractAdvisorAutoProxyCreator中实现，它又调用了findEligibleAdvisors方法获取所有可应用到当前bean的Advisors：</p>
<ol>
<li><strong>调用findCandidateAdvisors获取所有候选的Advisor</strong>，需要注意的是虽然AbstractAdvisorAutoProxyCreator类中实现了findCandidateAdvisors，但是<strong>向容器中注册代理创建器实际的类型是AnnotationAwareAspectJAutoProxyCreator</strong>，它重写了findCandidateAdvisors方法，所以会先进入AnnotationAwareAspectJAutoProxyCreator的findCandidateAdvisors方法，它里面又调用了父类的findCandidateAdvisors，这时候才会进入AbstractAdvisorAutoProxyCreator的方法。</li>
<li><strong>从所有候选的Advisor中过滤出可以适用于当前bean的Advisor</strong>，findAdvisorsThatCanApply具体实现逻辑在AopUtils中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAutoProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">            Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line">        <span class="comment">// 调用findEligibleAdvisors获取Advisor</span></span><br><span class="line">        List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Advisor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取所有的Advisor，需要注意实际的类型是AnnotationAwareAspectJAutoProxyCreator，所以会先进入它的findCandidateAdvisors方法中</span></span><br><span class="line">        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">        <span class="comment">// 2.获取可以应用到当前bean的Advisor</span></span><br><span class="line">        List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">        extendAdvisors(eligibleAdvisors);</span><br><span class="line">        <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">            eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AbstractAutoProxyCreator中获取所有候选的Advisors方法，AnnotationAwareAspectJAutoProxyCreator中重写的findCandidateAdvisors会调用这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.state(<span class="keyword">this</span>.advisorRetrievalHelper != <span class="keyword">null</span>, <span class="string">"No BeanFactoryAdvisorRetrievalHelper available"</span>);</span><br><span class="line">        <span class="comment">// 具体的实现逻辑在advisorRetrievalHelper的findAdvisorBeans</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.advisorRetrievalHelper.findAdvisorBeans();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取可以应用到当前bean的Advisor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取可以应用到当前bean的Advisor</span></span><br><span class="line">            <span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="findCandidateAdvisors获取所有候选的Advisors"><a href="#findCandidateAdvisors获取所有候选的Advisors" class="headerlink" title="findCandidateAdvisors获取所有候选的Advisors"></a>findCandidateAdvisors获取所有候选的Advisors</h3><p>AOP使用的是的AnnotationAwareAspectJAutoProxyCreator类型的创建器，它重写了findCandidateAdvisors方法，方法的处理逻辑如下：</p>
<ul>
<li><p><strong>调用了父类的findCandidateAdvisors方法获取候选的Advisors，也就是AbstractAdvisorAutoProxyCreator中实现的findCandidateAdvisors方法，这里的Advisors指的是本身是Advisor类型的bean。</strong></p>
</li>
<li><p><strong>调用了buildAspectJAdvisors方法构建Advisors</strong>，具体的实现在BeanFactoryAspectJAdvisorsBuilder中， <strong>这里的Advisors指的是使用了@AspectJ注解定义的切面，Spring会把它包装成Advisor。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Advisors构建工厂</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> BeanFactoryAspectJAdvisorsBuilder aspectJAdvisorsBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.initBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为空使用ReflectiveAspectJAdvisorFactory</span></span><br><span class="line">            <span class="keyword">this</span>.aspectJAdvisorFactory = <span class="keyword">new</span> ReflectiveAspectJAdvisorFactory(beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化BeanFactoryAspectJAdvisorsBuilder,这里使用的BeanFactoryAspectJAdvisorsBuilderAdapter</span></span><br><span class="line">        <span class="keyword">this</span>.aspectJAdvisorsBuilder =</span><br><span class="line">                <span class="keyword">new</span> BeanFactoryAspectJAdvisorsBuilderAdapter(beanFactory, <span class="keyword">this</span>.aspectJAdvisorFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.调用父类的findCandidateAdvisors获取所有的Advisors，也就是AbstractAdvisorAutoProxyCreator中实现的findCandidateAdvisors方法</span></span><br><span class="line">        List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.构建Advisors，具体实现在BeanFactoryAspectJAdvisorsBuilder中</span></span><br><span class="line">            advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> advisors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractAdvisorAutoProxyCreator</span></span><br><span class="line"><span class="comment"> * 它是实现了findCandidateAdvisors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAutoProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> BeanFactoryAdvisorRetrievalHelper advisorRetrievalHelper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用的BeanFactoryAdvisorRetrievalHelperAdapter</span></span><br><span class="line">        <span class="keyword">this</span>.advisorRetrievalHelper = <span class="keyword">new</span> BeanFactoryAdvisorRetrievalHelperAdapter(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有的候选Advisors</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the List of candidate Advisors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.state(<span class="keyword">this</span>.advisorRetrievalHelper != <span class="keyword">null</span>, <span class="string">"No BeanFactoryAdvisorRetrievalHelper available"</span>);</span><br><span class="line">        <span class="comment">// 获取候选的Advisor，具体的实现逻辑在advisorRetrievalHelper的findAdvisorBeans</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.advisorRetrievalHelper.findAdvisorBeans();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-findCandidateAdvisors获取候选的Advisors"><a href="#1-findCandidateAdvisors获取候选的Advisors" class="headerlink" title="1. findCandidateAdvisors获取候选的Advisors"></a>1. findCandidateAdvisors获取候选的Advisors</h4><p>findCandidateAdvisors方法具体的实现在BeanFactoryAdvisorRetrievalHelper中，<strong>它从beanFactory中获取了所有Advisor类型的bean</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryAdvisorRetrievalHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在当前的bean工厂中查找所有Advisor类型的bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">findAdvisorBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取缓存的AdvisorBeanName</span></span><br><span class="line">        String[] advisorNames = <span class="keyword">this</span>.cachedAdvisorBeanNames;</span><br><span class="line">        <span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                    <span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果未获取到</span></span><br><span class="line">        <span class="keyword">if</span> (advisorNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有的advisorNames</span></span><br><span class="line">        <span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line">                <span class="comment">// 如果bean正在创建中</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">"Skipping currently created advisor '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 从容器中获取实例，可以看到这里获取的是Advisor类型的bean</span></span><br><span class="line">                        advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                        <span class="comment">// 省略了异常处理</span></span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> advisors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-buildAspectJAdvisors构建Advisor"><a href="#2-buildAspectJAdvisors构建Advisor" class="headerlink" title="2. buildAspectJAdvisors构建Advisor"></a>2. buildAspectJAdvisors构建Advisor</h4><p>buildAspectJAdvisors在BeanFactoryAspectJAdvisorsBuilder中实现，<strong>这一步用于查找所有使用@AspectJ注解的bean，并将其包装成Advisor返回</strong>:</p>
<p>（1）从容器中获取所有的bean，调用isEligibleBean方法判断bean是否符合要求，如果符合进入下一步</p>
<p>（2）调用isAspect方法判断bean是否是一个切面，如果是进入下一步</p>
<p>（3）判断是否是单例模式</p>
<ul>
<li>如果是，创建BeanFactoryAspectInstanceFactory类型的工厂，调用<strong>AspectJAdvisorFactory的getAdvisors方法获取Advisor</strong></li>
<li>如果不是单例模式，创建PrototypeAspectInstanceFactory类型的工厂，调用AspectJAdvisorFactory的getAdvisors方法获取Advisor</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryAspectJAdvisorsBuilder</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> AspectJAdvisorFactory advisorFactory;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  在当前bean工厂中查找所有使用<span class="doctag">@AspectJ</span>注解的bean，并包装成Advisor返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">buildAspectJAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取所有的切面beanName</span></span><br><span class="line">        List&lt;String&gt; aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">        <span class="comment">// 如果为空</span></span><br><span class="line">        <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">                <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    aspectNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="comment">// 从容器中获取所有的beanName</span></span><br><span class="line">                    String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                            <span class="keyword">this</span>.beanFactory, Object.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                        <span class="comment">// 判断是否符合条件，BeanFactoryAspectJAdvisorsBuilderAdapter中实现</span></span><br><span class="line">                        <span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 根据BeanName获取class类型</span></span><br><span class="line">                        Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 是否是切面</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">                            <span class="comment">// 添加到aspectNames</span></span><br><span class="line">                            aspectNames.add(beanName);</span><br><span class="line">                            <span class="comment">// 创建Aspect元数据信息</span></span><br><span class="line">                            AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line">                            <span class="comment">// 单例模式</span></span><br><span class="line">                            <span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">                                <span class="comment">// 创建MetadataAwareAspectInstanceFactory</span></span><br><span class="line">                                MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                                        <span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                                <span class="comment">// 获取Advisor</span></span><br><span class="line">                                List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">                                <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                                    <span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                                &#125;</span><br><span class="line">                                advisors.addAll(classAdvisors);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 原型模式</span></span><br><span class="line">                                <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">                                            <span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                                        <span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                                <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                                advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">                    <span class="keyword">return</span> advisors;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">            List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">            <span class="keyword">if</span> (cachedAdvisors != <span class="keyword">null</span>) &#123;</span><br><span class="line">                advisors.addAll(cachedAdvisors);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">                advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> advisors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="isEligibleBean的判断"><a href="#isEligibleBean的判断" class="headerlink" title="isEligibleBean的判断"></a>isEligibleBean的判断</h5><p><img src="/images/BeanFactoryAspectJAdvisorsBuilderAdapter.png" alt=""></p>
<p>BeanFactoryAspectJAdvisorsBuilderAdapter是AnnotationAwareAspectJAutoProxyCreator的内部类，它继承了BeanFactoryAspectJAdvisorsBuilder并重写了isEligibleBean方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryAspectJAdvisorsBuilderAdapter</span> <span class="keyword">extends</span> <span class="title">BeanFactoryAspectJAdvisorsBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEligibleBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用isEligibleAspectBean</span></span><br><span class="line">            <span class="keyword">return</span> AnnotationAwareAspectJAutoProxyCreator.<span class="keyword">this</span>.isEligibleAspectBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验给定的切面是否符合要求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEligibleAspectBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.includePatterns == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pattern pattern : <span class="keyword">this</span>.includePatterns) &#123;</span><br><span class="line">                <span class="comment">// 通过includePatterns进行匹配</span></span><br><span class="line">                <span class="keyword">if</span> (pattern.matcher(beanName).matches()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="isAspect的判断"><a href="#isAspect的判断" class="headerlink" title="isAspect的判断"></a>isAspect的判断</h5><p>前面在讲跳过代理对象的创建时已经看到isAspect的实现逻辑，如果使用了Aspect注解并且不是通过Ajc进行编译的，则判定为切面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAspectJAdvisorFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAspectJAdvisorFactory</span> <span class="keyword">implements</span> <span class="title">AspectJAdvisorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是切面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAspect</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否有Aspect注解并且不是通过Ajc编译的类</span></span><br><span class="line">        <span class="keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否有Aspect注解</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasAspectAnnotation</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否有Aspect注解</span></span><br><span class="line">        <span class="keyword">return</span> (AnnotationUtils.findAnnotation(clazz, Aspect.class) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否通过Ajc编译</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compiledByAjc</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span> (Field field : clazz.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.getName().startsWith(AJC_MAGIC)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="AspectJAdvisorFactory获取Advisor"><a href="#AspectJAdvisorFactory获取Advisor" class="headerlink" title="AspectJAdvisorFactory获取Advisor"></a>AspectJAdvisorFactory获取Advisor</h5><p>AspectJAdvisorFactory是一个Advisor工厂，它的继承关系如下：</p>
<p><img src="/images/AspectJAdvisorFactory.png" alt=""></p>
<p>AnnotationAwareAspectJAutoProxyCreator在初始化bean工厂的方法中，对AspectJAdvisorFactory进行了判断，则如果为空使用ReflectiveAspectJAdvisorFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Advisors构建工厂</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> BeanFactoryAspectJAdvisorsBuilder aspectJAdvisorsBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.initBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为空使用ReflectiveAspectJAdvisorFactory</span></span><br><span class="line">            <span class="keyword">this</span>.aspectJAdvisorFactory = <span class="keyword">new</span> ReflectiveAspectJAdvisorFactory(beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化BeanFactoryAspectJAdvisorsBuilder</span></span><br><span class="line">        <span class="keyword">this</span>.aspectJAdvisorsBuilder =</span><br><span class="line">                <span class="keyword">new</span> BeanFactoryAspectJAdvisorsBuilderAdapter(beanFactory, <span class="keyword">this</span>.aspectJAdvisorFactory);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReflectiveAspectJAdvisorFactory中实现了getAdvisor方法：</p>
<ol>
<li>getAdvisorMethods获取Advisor方法（也就是获取通知），具体是<strong>根据方法上是否有Pointcut注解来判断的，如果没有Pointcut注解则判定为是Advisor方法</strong></li>
<li>调用getAdvisor方法将第1步中获取到的Advisor方法构建为Advisor对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveAspectJAdvisorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvisorFactory</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Aspect类信息</span></span><br><span class="line">        Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">        String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">        validate(aspectClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  装饰模式</span></span><br><span class="line">        MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line">                <span class="keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line"></span><br><span class="line">        List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取Advisor方法，也就是获取没有使用@Pointcut注解的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">            <span class="comment">// 将方法构建为Advisor对象</span></span><br><span class="line">            Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">            <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                advisors.add(advisor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If it's a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class="line">        <span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">            Advisor instantiationAdvisor = <span class="keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span><br><span class="line">            advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find introduction fields.</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">            Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line">            <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                advisors.add(advisor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> advisors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Advisor方法，也就是获取切面中没有被使用Pointcut注解的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Method&gt; <span class="title">getAdvisorMethods</span><span class="params">(Class&lt;?&gt; aspectClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ReflectionUtils.doWithMethods(aspectClass, method -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断是否有Pointcut注解，如果没有则判定为是Advisor方法加入结果集中</span></span><br><span class="line">            <span class="keyword">if</span> (AnnotationUtils.getAnnotation(method, Pointcut.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                methods.add(method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, ReflectionUtils.USER_DECLARED_METHODS);</span><br><span class="line">        <span class="keyword">if</span> (methods.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            methods.sort(METHOD_COMPARATOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="构建Advisor的具体实现"><a href="#构建Advisor的具体实现" class="headerlink" title="构建Advisor的具体实现"></a>构建Advisor的具体实现</h5><p>ReflectiveAspectJAdvisorFactory的getAdvisor方法用于将方法封装为Advisor对象，可以看到第一个参数叫candidateAdviceMethod（候选的通知方法），上一步中传入的是获取到的Advisor方法，<strong>所以Spring中Advisor方法指的就是使用了通知注解的方法</strong>，getAdvisor方法主要做了如下操作：</p>
<ol>
<li>构建AspectJExpressionPointcut切点表达式对象<ul>
<li>从通知方法上获取切面相关注解，具体是通过判断方法上是否有Pointcut、Around、Before、After、AfterReturning、AfterThrowing注解实现的</li>
<li>从切面注解中获取设置的切点表达式，用于之后判断方法是否匹配使用，然后创建AspectJExpressionPointcut对象并设置获取到的切点表达式</li>
</ul>
</li>
<li>将当前的Advisor方法、AspectJExpressionPointcut对象等信息封装为InstantiationModelAwarePointcutAdvisorImpl返回，它是一个Advisor</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveAspectJAdvisorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvisorFactory</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Advisor方法构建为Advisor对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advisor <span class="title">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">        <span class="comment">// 获取切点</span></span><br><span class="line">        AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class="line">                candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">        <span class="keyword">if</span> (expressionPointcut == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装为InstantiationModelAwarePointcutAdvisorImpl</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class="line">                <span class="keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取切点表达式</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AspectJExpressionPointcut <span class="title">getPointcut</span><span class="params">(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取AspectJ注解，具体是通过判断方法上是否有Pointcut、Around、Before、After、AfterReturning、AfterThrowing注解实现的</span></span><br><span class="line">        AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">        <span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建AspectJExpressionPointcut</span></span><br><span class="line">        AspectJExpressionPointcut ajexp =</span><br><span class="line">                <span class="keyword">new</span> AspectJExpressionPointcut(candidateAspectClass, <span class="keyword">new</span> String[<span class="number">0</span>], <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 设置切点表达式</span></span><br><span class="line">        ajexp.setExpression(aspectJAnnotation.getPointcutExpression());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ajexp.setBeanFactory(<span class="keyword">this</span>.beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ajexp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAspectJAdvisorFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAspectJAdvisorFactory</span> <span class="keyword">implements</span> <span class="title">AspectJAdvisorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] ASPECTJ_ANNOTATION_CLASSES = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;</span><br><span class="line">            Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有AspectJ相关注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;</span><br><span class="line">        <span class="comment">// 判断方法上是否有Pointcut、Around、Before、After、AfterReturning、AfterThrowing注解</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : ASPECTJ_ANNOTATION_CLASSES) &#123;</span><br><span class="line">            AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) clazz);</span><br><span class="line">            <span class="keyword">if</span> (foundAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> foundAnnotation;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>InstantiationModelAwarePointcutAdvisorImpl封装切面</strong></p>
<p>InstantiationModelAwarePointcutAdvisorImpl是一个Adviosr，它对Aspect切面进行了封装，里面引用了Advice、Pointcut等切面相关信息，在构造函数的最后，调用了instantiateAdvice对通知进行增强处理，也就是根据不同的通知类型，将其包装为不同的Advice对象，具体的实现在ReflectiveAspectJAdvisorFactory中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiationModelAwarePointcutAdvisorImpl</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">InstantiationModelAwarePointcutAdvisor</span>, <span class="title">AspectJPrecedenceInformation</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 切点表达式，用于匹配方法是否需要进行拦截</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AspectJExpressionPointcut declaredPointcut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Method aspectJAdviceMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AspectJAdvisorFactory</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AspectJAdvisorFactory aspectJAdvisorFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MetadataAwareAspectInstanceFactory aspectInstanceFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> declarationOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切面名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String aspectName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Pointcut pointcut; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> lazy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Advice instantiatedAdvice; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isBeforeAdvice;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isAfterAdvice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstantiationModelAwarePointcutAdvisorImpl</span><span class="params">(AspectJExpressionPointcut declaredPointcut,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.declaredPointcut = declaredPointcut;</span><br><span class="line">        <span class="comment">// 设置切面的类信息</span></span><br><span class="line">        <span class="keyword">this</span>.declaringClass = aspectJAdviceMethod.getDeclaringClass();</span><br><span class="line">        <span class="comment">// 设置方法名称</span></span><br><span class="line">        <span class="keyword">this</span>.methodName = aspectJAdviceMethod.getName();</span><br><span class="line">        <span class="keyword">this</span>.parameterTypes = aspectJAdviceMethod.getParameterTypes();</span><br><span class="line">        <span class="comment">// 通知</span></span><br><span class="line">        <span class="keyword">this</span>.aspectJAdviceMethod = aspectJAdviceMethod;</span><br><span class="line">        <span class="comment">// AspectJAdvisorFactory</span></span><br><span class="line">        <span class="keyword">this</span>.aspectJAdvisorFactory = aspectJAdvisorFactory;</span><br><span class="line">        <span class="keyword">this</span>.aspectInstanceFactory = aspectInstanceFactory;</span><br><span class="line">        <span class="keyword">this</span>.declarationOrder = declarationOrder;</span><br><span class="line">        <span class="comment">// 切面名称</span></span><br><span class="line">        <span class="keyword">this</span>.aspectName = aspectName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">            Pointcut preInstantiationPointcut = Pointcuts.union(</span><br><span class="line">                    aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), <span class="keyword">this</span>.declaredPointcut);</span><br><span class="line">            <span class="keyword">this</span>.pointcut = <span class="keyword">new</span> PerTargetInstantiationModelPointcut(</span><br><span class="line">                    <span class="keyword">this</span>.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);</span><br><span class="line">            <span class="keyword">this</span>.lazy = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// A singleton aspect.</span></span><br><span class="line">            <span class="keyword">this</span>.pointcut = <span class="keyword">this</span>.declaredPointcut;</span><br><span class="line">            <span class="keyword">this</span>.lazy = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 增强处理</span></span><br><span class="line">            <span class="keyword">this</span>.instantiatedAdvice = instantiateAdvice(<span class="keyword">this</span>.declaredPointcut);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Advice <span class="title">instantiateAdvice</span><span class="params">(AspectJExpressionPointcut pointcut)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用ReflectiveAspectJAdvisorFactory获取Advice</span></span><br><span class="line">        Advice advice = <span class="keyword">this</span>.aspectJAdvisorFactory.getAdvice(<span class="keyword">this</span>.aspectJAdviceMethod, pointcut,</span><br><span class="line">                <span class="keyword">this</span>.aspectInstanceFactory, <span class="keyword">this</span>.declarationOrder, <span class="keyword">this</span>.aspectName);</span><br><span class="line">        <span class="keyword">return</span> (advice != <span class="keyword">null</span> ? advice : EMPTY_ADVICE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ReflectiveAspectJAdvisorFactory</strong></p>
<p>ReflectiveAspectJAdvisorFactory中的getAdvice方法中可以看到对通知进行了判断，不同的通知使用不同的包装类：</p>
<ul>
<li>环绕通知，使用AspectJAroundAdvice</li>
<li>前置通知，使用AspectJMethodBeforeAdvice</li>
<li>后置通知，使用AspectJAfterAdvice</li>
<li>返回通知，使用AspectJAfterReturningAdvice</li>
<li>异常通知，使用AspectJAfterThrowingAdvice</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveAspectJAdvisorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvisorFactory</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,</span></span></span><br><span class="line"><span class="function"><span class="params">                            MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">        validate(candidateAspectClass);</span><br><span class="line">        <span class="comment">// 获取AspectJAnnotation</span></span><br><span class="line">        AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">        <span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次校验是否是切面</span></span><br><span class="line">        <span class="keyword">if</span> (!isAspect(candidateAspectClass)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Advice must be declared inside an aspect type: "</span> +</span><br><span class="line">                    <span class="string">"Offending method '"</span> + candidateAdviceMethod + <span class="string">"' in class ["</span> +</span><br><span class="line">                    candidateAspectClass.getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Found AspectJ method: "</span> + candidateAdviceMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AbstractAspectJAdvice springAdvice;</span><br><span class="line">        <span class="comment">// 判断通知类型</span></span><br><span class="line">        <span class="keyword">switch</span> (aspectJAnnotation.getAnnotationType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> AtPointcut: <span class="comment">// 如果是一个切点</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Processing pointcut '"</span> + candidateAdviceMethod.getName() + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAround: <span class="comment">// 环绕通知，使用AspectJAroundAdvice封装</span></span><br><span class="line">                springAdvice = <span class="keyword">new</span> AspectJAroundAdvice(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtBefore:<span class="comment">// 前置通知，使用AspectJMethodBeforeAdvice</span></span><br><span class="line">                springAdvice = <span class="keyword">new</span> AspectJMethodBeforeAdvice(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAfter:<span class="comment">// 后置通知，使用AspectJAfterAdvice</span></span><br><span class="line">                springAdvice = <span class="keyword">new</span> AspectJAfterAdvice(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAfterReturning:<span class="comment">// 返回通知，使用AspectJAfterReturningAdvice</span></span><br><span class="line">                springAdvice = <span class="keyword">new</span> AspectJAfterReturningAdvice(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;</span><br><span class="line">                    springAdvice.setReturningName(afterReturningAnnotation.returning());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAfterThrowing:<span class="comment">// 异常通知，使用AspectJAfterThrowingAdvice</span></span><br><span class="line">                springAdvice = <span class="keyword">new</span> AspectJAfterThrowingAdvice(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;</span><br><span class="line">                    springAdvice.setThrowingName(afterThrowingAnnotation.throwing());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">                        <span class="string">"Unsupported advice type on method: "</span> + candidateAdviceMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now to configure the advice...</span></span><br><span class="line">        springAdvice.setAspectName(aspectName);</span><br><span class="line">        springAdvice.setDeclarationOrder(declarationOrder);</span><br><span class="line">        String[] argNames = <span class="keyword">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class="line">        <span class="keyword">if</span> (argNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class="line">        &#125;</span><br><span class="line">        springAdvice.calculateArgumentBindings();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> springAdvice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="findAdvisorsThatCanApply获取可以应用到当前bean的Advisor"><a href="#findAdvisorsThatCanApply获取可以应用到当前bean的Advisor" class="headerlink" title="findAdvisorsThatCanApply获取可以应用到当前bean的Advisor"></a>findAdvisorsThatCanApply获取可以应用到当前bean的Advisor</h3><p>上一节中获取到了所有的Advisor，接下来要过滤出可以应用到当前bean的Advisor，findAdvisorsThatCanApply在AopUtils中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AopUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">            <span class="comment">// 是否是IntroductionAdvisor并且canApply,加入到eligibleAdvisors中</span></span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">                eligibleAdvisors.add(candidate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">        <span class="comment">// 再次遍历候选的Advisor</span></span><br><span class="line">        <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">            <span class="comment">// 如果是IntroductionAdvisor，上面已经对IntroductionAdvisor进行了处理，这里continue继续下一个</span></span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">                <span class="comment">// already processed</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用canApply方法判断</span></span><br><span class="line">            <span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">                eligibleAdvisors.add(candidate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心的逻辑在canApply方法中：</p>
<ul>
<li><p><strong>根据切点Pointcut的getClassFilter方法对类进行匹配</strong>，判断targetClass目标类是否与切点匹配</p>
</li>
<li><p>从切点获取MethodMatcher方法匹配器，<strong>通过MethodMatcher对目标类中的每一个方法进行匹配，也就是使用切点表达式对方法进行匹配，判断方法是否需要拦截。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AopUtils</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否可以应用到bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">            PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class="line">            <span class="comment">// 继续调用canApply</span></span><br><span class="line">            <span class="keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// It doesn't have a pointcut so we assume it applies.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否可以应用到bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(pc, <span class="string">"Pointcut must not be null"</span>);</span><br><span class="line">        <span class="comment">// 通过切点进行匹配，先判断类是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从切点中获取方法匹配器</span></span><br><span class="line">        MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">        <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">            <span class="comment">// No need to iterate the methods if we're matching any method anyway...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果是IntroductionAwareMethodMatcher</span></span><br><span class="line">        <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">            introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            classes.add(ClassUtils.getUserClass(targetClass));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取类的所有接口</span></span><br><span class="line">        classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">            <span class="comment">// 获取类中的所有方法</span></span><br><span class="line">            Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">            <span class="comment">// 遍历方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                <span class="keyword">if</span> (introductionAwareMethodMatcher != <span class="keyword">null</span> ?</span><br><span class="line">                        introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</span><br><span class="line">                        methodMatcher.matches(method, targetClass)) &#123; <span class="comment">// 调用方法的matches进行匹配</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h2><p>上一节中已经获取到了可以应用到当前bean的Advisor，接下来就可以创建代理对象了，由于篇幅原因，创建代理的过程将另起一篇文章。</p>
<p><strong>总结</strong><br><img src="/images/AOP原理总结一.png" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://blog.csdn.net/qq_36882793/article/details/106440723" target="_blank" rel="noopener">【猫吻鱼】Spring源码分析：全集整理</a></p>
<p><strong>Spring版本：5.2.5.RELEASE</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/10/【Spring】AOP实现原理（一）：Aop基础知识（基于注解）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/10/【Spring】AOP实现原理（一）：Aop基础知识（基于注解）/" itemprop="url">【Spring】AOP实现原理（一）：Aop基础知识（基于注解）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-10T13:00:00+08:00">
                2022-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h3><p>在学习AOP实现原理之前，先了解下AOP相关基础知识。</p>
<p>AOP面向切面编程，它可以通过预编译方式或者基于动态代理对我们编写的代码进行拦截（也叫增强处理），在方法执行前后可以做一些操作，一般我们会看到以下几个概念：</p>
<p><strong>连接点（JointPoint）</strong>: AOP进行切入的位置称为连接点，一般指程序中的某个方法，对该方法进行拦截</p>
<p><strong>通知（Advice）</strong>: 在某个连接点执行的操作称为通知，也就是被拦截方法执行前后需要执行的操作称为通知，一共有五种</p>
<ul>
<li>前置通知：作用于被拦截方法执行之前</li>
<li>后置通知：作用于被拦截方法执行之后进行的操作，无论被拦截方法是否抛出异常都会执行</li>
<li>环绕通知：作用于被拦截方法执行之前和执行之后</li>
<li>返回通知：作用于被拦截方法正常执行完毕返回时，如果抛出异常将不会执行</li>
<li>异常通知：作用于被拦截方法抛出异常时</li>
</ul>
<p><strong>切点（Pointcut）:</strong> 切点作用在于让程序知道需要在哪个<strong>连接点</strong>（方法）上执行<strong>通知</strong>，所以它也可以是一个表达式，匹配所有需要拦截的方法。</p>
<p><strong>切面（Aspect）: 切点</strong>和<strong>通知</strong>共同组成了切面，其中切点定义了需要在哪些连接点上<strong>执行通知</strong>，通知里面定义了<strong>具体需要进行的操作</strong>。</p>
<p><strong>织入（Weaving）：</strong>将切面连接到应用程序类型或者对象上，创建一个被通知的对象（advised object）的过程称为织入，换句话说<strong>织入就是将切面应用到目标对象的过程，它可以在编译期时（使用AspectJ）、加载时或者在运行时实现</strong>，Spring AOP是在运行时基于动态代理实现的。</p>
<p><strong>Advisor</strong>：它是对切面的封装，使用了@AspectJ注解的类会被封装成Advisor。</p>
<h4 id="Spring-AOP和AspectJ区别"><a href="#Spring-AOP和AspectJ区别" class="headerlink" title="Spring AOP和AspectJ区别"></a>Spring AOP和AspectJ区别</h4><p><strong>Spring AOP</strong></p>
<p>Spring AOP是基于动态代理实现拦截功能的，默认使用JDK动态代理实现，当然这需要目标对象实现接口，如果目标对象没有实现接口，则使用CGLIB生成。</p>
<p><strong>AspectJ</strong></p>
<p>AspectJ提供了三种方式实现AOP：</p>
<ul>
<li><p>编译时织入：在编译期间将代码进行织入到目标类的class文件中。</p>
</li>
<li><p>编译后织入：在编译后将代码织入到目标类的class文件中。</p>
</li>
<li><p>加载时织入：在JVM加载class文件的时候进行织入。</p>
</li>
</ul>
<h3 id="Spring-AOP的应用"><a href="#Spring-AOP的应用" class="headerlink" title="Spring AOP的应用"></a>Spring AOP的应用</h3><p>了解了AOP相关知识后我们来实现一个需求：</p>
<ol>
<li>自定义一个日志注解MyLogger</li>
<li>对使用了MyLogger注解的方法进行拦截，在方法的执行前后分别进行一些操作（环绕通知）：<ul>
<li>方法执行前打印方法传入的参数</li>
<li>方法执行后打印方法的返回值</li>
</ul>
</li>
</ol>
<p><strong>自定义注解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLogger &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义切面Aspect"><a href="#定义切面Aspect" class="headerlink" title="定义切面Aspect"></a>定义切面Aspect</h4><p>这里使用注解@Aspect来标记这是一个切面，切面是切点和通知的集合，分别使用注解@Pointcut和@Around实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 使用注解定义切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">// 开启AOP</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="切点Pointcut"><a href="#切点Pointcut" class="headerlink" title="切点Pointcut"></a>切点Pointcut</h5><p>使用表达式<code>@annotation(com.demo.mybatis.annotation.MyLogger)</code>匹配所有使用了@MyLogger注解的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义切点，匹配所有使用了<span class="doctag">@MyLogger</span>注解的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.example.annotation.MyLogger)"</span>) <span class="comment">// 这里传入MyLogger的全路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPoiontcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通知Advice"><a href="#通知Advice" class="headerlink" title="通知Advice"></a>通知Advice</h5><p>定义一个<code>logAroudAdvice</code>方法，使用@Around注解标记这是一个环绕通知，<code>logPoiontcut()</code>引用了切点，表示通知要作用于哪些连接点上，该方法需要传入一个ProceedingJoinPoint类型参数（连接点）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知Advice，这里使用了环绕通知</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> joinPoint 连接点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"logPoiontcut()"</span>) <span class="comment">// 引用切点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">logAroudAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 方法执行前的日志打印</span></span><br><span class="line">    printBeforeLog(joinPoint);</span><br><span class="line">    <span class="comment">// 执行方法</span></span><br><span class="line">    Object returnValue = joinPoint.proceed();</span><br><span class="line">    <span class="comment">// 方法执行后的日志打印</span></span><br><span class="line">    printAfterLog(returnValue);</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的切面如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 使用注解定义切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义切点，匹配所有使用了<span class="doctag">@MyLogger</span>注解的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.example.annotation.MyLogger)"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPoiontcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知Advice，这里使用了环绕通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 连接点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"logPoiontcut()"</span>) <span class="comment">// 引用切点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">logAroudAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 方法执行前的日志打印</span></span><br><span class="line">        printBeforeLog(joinPoint);</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        Object returnValue = joinPoint.proceed();</span><br><span class="line">        <span class="comment">// 方法执行后的日志打印</span></span><br><span class="line">        printAfterLog(returnValue);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法执行前的日志打印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printBeforeLog</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line">        log.info(<span class="string">"开始执行方法：&#123;&#125;"</span>, method.getName());</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">if</span> (args == <span class="keyword">null</span> || args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取参数名称</span></span><br><span class="line">        String[] parameterNames = methodSignature.getParameterNames();</span><br><span class="line">        StringBuilder parameterBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            parameterBuilder.append(parameterNames[i]).append(<span class="string">"："</span>).append(args[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; parameterNames.length - <span class="number">1</span>) &#123;</span><br><span class="line">                parameterBuilder.append(<span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"方法参数【&#123;&#125;】"</span>, parameterBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法执行后的日志打印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnValue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAfterLog</span><span class="params">(Object returnValue)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"方法返回值【&#123;&#125;】"</span>, returnValue == <span class="keyword">null</span> ? <span class="keyword">null</span> : returnValue.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<p>定义一个用于计算的Service，实现一个两数相加的方法<code>addTwoNum</code>，并使用<code>@MyLogger</code>注解，对方法进行拦截，在方法执行前后打印相关日志</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义日志注解对方法进行拦截</span></span><br><span class="line">    <span class="meta">@MyLogger</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">addTwoNum</span><span class="params">(Integer value1, Integer value2)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"执行addTwoNum方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> value1 + value2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写单元测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ComputeService computeService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> testAddTwoNum &#123;</span><br><span class="line">	computeService.addTwoNum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于ComputeService没有实现接口，可以看到Spring默认使用了CGLIB生成对象：</p>
<p><img src="/images/aop代理.png" alt=""></p>
<p>日志输出如下，可以看到方法执行前后打印了相关日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始执行方法：addTwoNum</span><br><span class="line">方法参数【value1：1,value2：2】</span><br><span class="line">执行addTwoNum方法</span><br><span class="line">方法返回值【3】</span><br></pre></td></tr></table></figure>
<p><strong>参考</strong></p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-introduction-defn" target="_blank" rel="noopener">Spring官方文档</a></p>
<p><a href="https://www.cnblogs.com/FatalFlower/p/15547242.html" target="_blank" rel="noopener">【 FatalFlower】AspectJ 简介 </a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/07/【Srping】事务的执行原理（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/07/【Srping】事务的执行原理（三）/" itemprop="url">【Spring】事务的执行原理（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-07T21:30:00+08:00">
                2022-04-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事务的回滚"><a href="#事务的回滚" class="headerlink" title="事务的回滚"></a>事务的回滚</h2><ol>
<li><p>如果获取事务属性不为空，并且抛出的异常是RuntimeException或者Error类型，调用事务管理器中的rollback方法进行回滚</p>
</li>
<li><p>如果事务属性为空或者抛出的异常不是RuntimeException，也不是Error，将继续提交事务</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理抛出异常下的事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span><span class="params">(@Nullable TransactionInfo txInfo, Throwable ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判空</span></span><br><span class="line">        <span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Completing transaction for ["</span> + txInfo.getJoinpointIdentification() +</span><br><span class="line">                        <span class="string">"] after exception: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果事务属性不为空并且异常是是RuntimeException或者Error</span></span><br><span class="line">            <span class="keyword">if</span> (txInfo.transactionAttribute != <span class="keyword">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取事务管理器，调用rollback方法进行回滚</span></span><br><span class="line">                    txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line">                    ex2.initApplicationException(ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果事务属性为空或者异常不是RuntimeException或者Error，继续提交事务</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 提交</span></span><br><span class="line">                    txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Application exception overridden by commit exception"</span>, ex);</span><br><span class="line">                    ex2.initApplicationException(ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Application exception overridden by commit exception"</span>, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultTransactionAttribute中实现了rollbackOn方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultTransactionAttribute</span> <span class="keyword">extends</span> <span class="title">DefaultTransactionDefinition</span> <span class="keyword">implements</span> <span class="title">TransactionAttribute</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否是RuntimeException或者Error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rollbackOn</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ex <span class="keyword">instanceof</span> RuntimeException || ex <span class="keyword">instanceof</span> Error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rollback方法在AbstractPlatformTransactionManager中实现，主要分为以下三种情况：</p>
<ol>
<li>判断事务是否设置了保存点，如果设置了将事务回滚到保存点</li>
<li>如果是一个独立的新事务，直接回滚即可</li>
<li>如果既没有设置保存点，也不是一个新事务，说明可能处于嵌套事务中，此时只设置回滚状态rollbackOnly为true，当它的外围事务进行提交时，如果发现回滚状态为true，则不提交</li>
</ol>
<p>以上步骤执行完毕，调用cleanupAfterCompletion方法进行资源的清理已经挂起事务的恢复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title">PlatformTransactionManager</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 回滚</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">                    <span class="string">"Transaction is already completed - do not call commit or rollback more than once per transaction"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转为DefaultTransactionStatus</span></span><br><span class="line">        DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">        <span class="comment">// 处理回滚</span></span><br><span class="line">        processRollback(defStatus, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="keyword">boolean</span> unexpected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> unexpectedRollback = unexpected;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 回滚之前的触发器</span></span><br><span class="line">                triggerBeforeCompletion(status);</span><br><span class="line">                <span class="comment">// 是否有保存点</span></span><br><span class="line">                <span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">"Rolling back transaction to savepoint"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 回滚至保存点</span></span><br><span class="line">                    status.rollbackToHeldSavepoint();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123; <span class="comment">// 如果是一个独立的新事务</span></span><br><span class="line">                    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">"Initiating transaction rollback"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 直接回滚</span></span><br><span class="line">                    doRollback(status);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果处于一个嵌套的事务汇总</span></span><br><span class="line">                    <span class="keyword">if</span> (status.hasTransaction()) &#123;</span><br><span class="line">                        <span class="comment">// 如果本地的回滚状态置为true 或者 事务失败进行全局回滚</span></span><br><span class="line">                        <span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                                logger.debug(<span class="string">"Participating transaction failed - marking existing transaction as rollback-only"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 设置事务rollbackOnly状态为true</span></span><br><span class="line">                            doSetRollbackOnly(stat);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 打印日志，意思是由事务的组织者决定是否回滚</span></span><br><span class="line">                            <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                                logger.debug(<span class="string">"Participating transaction failed - letting transaction originator decide on rollback"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 打印DEBUG日志，应该回滚但是没有获取到事务</span></span><br><span class="line">                        logger.debug(<span class="string">"Should roll back transaction but cannot - no transaction available"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Unexpected rollback only matters here if we're asked to fail early</span></span><br><span class="line">                    <span class="keyword">if</span> (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">                        unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">                triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回滚之后的触发器</span></span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Raise UnexpectedRollbackException if we had a global rollback-only marker</span></span><br><span class="line">            <span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line">                        <span class="string">"Transaction rolled back because it has been marked as rollback-only"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清除相关资源并恢复挂起的事务</span></span><br><span class="line">            cleanupAfterCompletion(status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一个事务失败以后，是否全局的标进行事务回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isGlobalRollbackOnParticipationFailure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.globalRollbackOnParticipationFailure;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回滚处理"><a href="#回滚处理" class="headerlink" title="回滚处理"></a>回滚处理</h3><h4 id="rollbackToHeldSavepoint回滚至保存点"><a href="#rollbackToHeldSavepoint回滚至保存点" class="headerlink" title="rollbackToHeldSavepoint回滚至保存点"></a>rollbackToHeldSavepoint回滚至保存点</h4><p>rollbackToHeldSavepoint方法在AbstractTransactionStatus中实现，它调用了getSavepointManager方法获取保存点管理器，调用SavepointManager的rollbackToSavepoint方法进行回滚的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTransactionStatus</span> <span class="keyword">implements</span> <span class="title">TransactionStatus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollbackToHeldSavepoint</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">        Object savepoint = getSavepoint();</span><br><span class="line">        <span class="keyword">if</span> (savepoint == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransactionUsageException(</span><br><span class="line">                    <span class="string">"Cannot roll back to savepoint - no savepoint associated with current transaction"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// getSavepointManager方法在DefaultTransactionStatus中实现</span></span><br><span class="line">        getSavepointManager().rollbackToSavepoint(savepoint);</span><br><span class="line">        getSavepointManager().releaseSavepoint(savepoint);</span><br><span class="line">        setSavepoint(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SavepointManager是一个接口，它的继承关系如下：</p>
<p><img src="/images/SavepointManager.png" alt=""></p>
<p>DefaultTransactionStatus中获取SavepointManager的方法：</p>
<ol>
<li>获取transaction对象，前面的知识可知这里是一个DataSourceTransactionObject</li>
<li>由继承关系可知DataSourceTransactionObject也是SavepointManager子类，所以将DataSourceTransactionObject转为SavepointManager返回<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultTransactionStatus</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionStatus</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SavepointManager <span class="title">getSavepointManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前面的知识可知这里是一个DataSourceTransactionObject</span></span><br><span class="line">        Object transaction = <span class="keyword">this</span>.transaction;</span><br><span class="line">        <span class="keyword">if</span> (!(transaction <span class="keyword">instanceof</span> SavepointManager)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NestedTransactionNotSupportedException(</span><br><span class="line">                    <span class="string">"Transaction object ["</span> + <span class="keyword">this</span>.transaction + <span class="string">"] does not support savepoints"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将DataSourceTransactionObject转为SavepointManager</span></span><br><span class="line">        <span class="keyword">return</span> (SavepointManager) transaction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>DataSourceTransactionObject是DataSourceTransactionManager的内部类，它继承了JdbcTransactionObjectSupport,rollbackToSavepoint方法在JdbcTransactionObjectSupport中实现：</p>
<ol>
<li>获取ConnectionHolder，ConnectionHolder持有数据库连接</li>
<li>调用底层的rollback方法将事务回滚至保存点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title">AbstractPlatformTransactionManager</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ResourceTransactionManager</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部类DataSourceTransactionObject</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionObject</span> <span class="keyword">extends</span> <span class="title">JdbcTransactionObjectSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JdbcTransactionObjectSupport</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTransactionObjectSupport</span> <span class="keyword">implements</span> <span class="title">SavepointManager</span>, <span class="title">SmartTransactionObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回滚至保存点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollbackToSavepoint</span><span class="params">(Object savepoint)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取ConnectionHolder</span></span><br><span class="line">        ConnectionHolder conHolder = getConnectionHolderForSavepoint();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用底层的rollback方法将事务回滚至保存点</span></span><br><span class="line">            conHolder.getConnection().rollback((Savepoint) savepoint);</span><br><span class="line">            conHolder.resetRollbackOnly();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransactionSystemException(<span class="string">"Could not roll back to JDBC savepoint"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放保存点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseSavepoint</span><span class="params">(Object savepoint)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">        ConnectionHolder conHolder = getConnectionHolderForSavepoint();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用底层的方法释放保存点</span></span><br><span class="line">            conHolder.getConnection().releaseSavepoint((Savepoint) savepoint);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Could not explicitly release JDBC savepoint"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="doRollback事务回滚"><a href="#doRollback事务回滚" class="headerlink" title="doRollback事务回滚"></a>doRollback事务回滚</h4><p>回滚事务时先获取数据库连接，然后调用底层的rollback进行回滚：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title">AbstractPlatformTransactionManager</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ResourceTransactionManager</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRollback</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取数据源事务对象</span></span><br><span class="line">        DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">        <span class="comment">// 获取数据库连接</span></span><br><span class="line">        Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">        <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Rolling back JDBC transaction on Connection ["</span> + con + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用底层的回滚方法</span></span><br><span class="line">            con.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransactionSystemException(<span class="string">"Could not roll back JDBC transaction"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="doSetRollbackOnly设置回滚状态"><a href="#doSetRollbackOnly设置回滚状态" class="headerlink" title="doSetRollbackOnly设置回滚状态"></a>doSetRollbackOnly设置回滚状态</h4><p>doSetRollbackOnly方法在DataSourceTransactionManager中实现：</p>
<ol>
<li><p>将事务转为DataSourceTransactionObject对象，前面讲过DataSourceTransactionObject持有了数据库连接对象ConnectionHolder</p>
</li>
<li><p>将ConnectionHolder的rollbackOnly属性置为true，先标记事务的回滚状态，交由外围事务进行判断统一进行回滚</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title">AbstractPlatformTransactionManager</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ResourceTransactionManager</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSetRollbackOnly</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取数据源事务对象</span></span><br><span class="line">        DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">        <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Setting JDBC transaction ["</span> + txObject.getConnectionHolder().getConnection() +</span><br><span class="line">                    <span class="string">"] rollback-only"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置回滚状态</span></span><br><span class="line">        txObject.setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部类DataSourceTransactionObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionObject</span> <span class="keyword">extends</span> <span class="title">JdbcTransactionObjectSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其他方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置回滚状态</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 将ConnectionHolder的rollbackOnly属性置为true，在ConnectionHolder的父类ResourceHolderSupport中实现</span></span><br><span class="line">            getConnectionHolder().setRollbackOnly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConnectionHolder的父类ResourceHolderSupport</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceHolderSupport</span> <span class="keyword">implements</span> <span class="title">ResourceHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> rollbackOnly = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记事务回滚状态为true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rollbackOnly = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="资源清理"><a href="#资源清理" class="headerlink" title="资源清理"></a>资源清理</h3><p>在事务回滚之后，需要清理相关的资源以及恢复被挂起的事务：</p>
<ol>
<li>如果事务的newSynchronization状态为true，<strong>清除当前线程绑定的事务相关信息</strong><ul>
<li>在TransactionSynchronizationManager的clear方法中实现，清理了当前线程绑定的事务名称、事务隔离级别等信息</li>
</ul>
</li>
<li>如果是一个新事务，<strong>清除当前线程与数据库连接的绑定关系</strong>，在DataSourceTransactionManager的doCleanupAfterCompletion方法中实现</li>
<li><strong>如果挂起的事务不为空，恢复挂起的事务</strong><ul>
<li>获取数据源，恢复数据源与挂起事务的绑定关系</li>
<li>恢复挂起事务与当前线程的同步信息<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title">PlatformTransactionManager</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回滚之后的清除操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #doCleanupAfterCompletion</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanupAfterCompletion</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">        status.setCompleted();</span><br><span class="line">        <span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">            <span class="comment">// 清除当前线程绑定的信息</span></span><br><span class="line">            TransactionSynchronizationManager.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是一个新事务</span></span><br><span class="line">        <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">            <span class="comment">// 清除当前线程与数据库连接的绑定关系</span></span><br><span class="line">            doCleanupAfterCompletion(status.getTransaction());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果挂起的事务不为空</span></span><br><span class="line">        <span class="keyword">if</span> (status.getSuspendedResources() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Resuming suspended transaction after completion of inner transaction"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Object transaction = (status.hasTransaction() ? status.getTransaction() : <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 恢复挂起的事务</span></span><br><span class="line">            resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 恢复挂起的事务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #doResume</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #suspend</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">(@Nullable Object transaction, @Nullable SuspendedResourcesHolder resourcesHolder)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resourcesHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取挂起的事务</span></span><br><span class="line">            Object suspendedResources = resourcesHolder.suspendedResources;</span><br><span class="line">            <span class="keyword">if</span> (suspendedResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取数据源，并与挂起的事务进行绑定</span></span><br><span class="line">                doResume(transaction, suspendedResources);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 挂起事务的同步信息</span></span><br><span class="line">            List&lt;TransactionSynchronization&gt; suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;</span><br><span class="line">            <span class="keyword">if</span> (suspendedSynchronizations != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 恢复事务与线程的同步信息</span></span><br><span class="line">                TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive);</span><br><span class="line">                TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel);</span><br><span class="line">                TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly);</span><br><span class="line">                TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name);</span><br><span class="line">                doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataSourceTransactionManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title">AbstractPlatformTransactionManager</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ResourceTransactionManager</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主要是清除当前线程与数据库连接的绑定关系</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doCleanupAfterCompletion</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">        DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove the connection holder from the thread, if exposed.</span></span><br><span class="line">        <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">            TransactionSynchronizationManager.unbindResource(obtainDataSource());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据库连接</span></span><br><span class="line">        Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (txObject.isMustRestoreAutoCommit()) &#123;</span><br><span class="line">                <span class="comment">// 自动提交置为true</span></span><br><span class="line">                con.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置数据库连接的相关设置</span></span><br><span class="line">            DataSourceUtils.resetConnectionAfterTransaction(</span><br><span class="line">                    con, txObject.getPreviousIsolationLevel(), txObject.isReadOnly());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Could not reset JDBC Connection after transaction"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Releasing JDBC Connection ["</span> + con + <span class="string">"] after transaction"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放连接</span></span><br><span class="line">            DataSourceUtils.releaseConnection(con, <span class="keyword">this</span>.dataSource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除当前线程与数据库连接的绑定关系</span></span><br><span class="line">        txObject.getConnectionHolder().clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doResume</span><span class="params">(@Nullable Object transaction, Object suspendedResources)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取数据源，并与挂起的事务进行绑定</span></span><br><span class="line">        TransactionSynchronizationManager.bindResource(obtainDataSource(), suspendedResources);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransactionSynchronizationManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存了线程绑定的数据库资源信息，Map中Key为数据源构建的KEY，value为对应的ConnectionHolder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transactional resources"</span>);</span><br><span class="line">    <span class="comment">// 保存了线程绑定的事务同步信息TransactionSynchronization</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transaction synchronizations"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存了线程绑定的事务名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction name"</span>);</span><br><span class="line">    <span class="comment">// 保存了线程绑定的事务只读状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction read-only status"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存了线程绑定的事务隔离级别</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction isolation level"</span>);</span><br><span class="line">    <span class="comment">// 保存了线程绑定的事务活跃状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Actual transaction active"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理事务与当前线程的各种同步状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 清除当前线程绑定的事务同步信息TransactionSynchronization</span></span><br><span class="line">        synchronizations.remove();</span><br><span class="line">        <span class="comment">// 清除当前线程绑定的事务名称</span></span><br><span class="line">        currentTransactionName.remove();</span><br><span class="line">        <span class="comment">// 清除线程绑定的事务只读状态</span></span><br><span class="line">        currentTransactionReadOnly.remove();</span><br><span class="line">        <span class="comment">// 清除线程绑定的事务隔离级别</span></span><br><span class="line">        currentTransactionIsolationLevel.remove();</span><br><span class="line">        <span class="comment">// 清除线程绑定的事务活跃状态</span></span><br><span class="line">        actualTransactionActive.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p><img src="/images/事务原理三总结.png" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://blog.csdn.net/qq_36882793/article/details/106440723" target="_blank" rel="noopener">【猫吻鱼】Spring源码分析：全集整理</a></p>
<p><strong>Spring版本：5.2.5.RELEASE</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/03/【Srping】事务的执行原理（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/03/【Srping】事务的执行原理（二）/" itemprop="url">【Spring】事务的执行原理（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-03T22:00:00+08:00">
                2022-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>事务的执行步骤如下：</p>
<ol>
<li>获取事务管理器</li>
<li>创建事务</li>
<li>执行目标方法</li>
<li>捕捉异常，如果出现异常进行回滚</li>
<li>提交事务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 获取TransactionAttributeSource</span></span><br><span class="line">        TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">        <span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 1. 获取事务管理器</span></span><br><span class="line">        <span class="keyword">final</span> TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line">        <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">            <span class="comment">// 2. 创建事务</span></span><br><span class="line">            TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">            Object retVal;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 执行方法</span></span><br><span class="line">                retVal = invocation.proceedWithInvocation();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 4. 回滚事务</span></span><br><span class="line">                completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 清除事务</span></span><br><span class="line">                cleanupTransactionInfo(txInfo);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 省略代码</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 提交事务</span></span><br><span class="line">            commitTransactionAfterReturning(txInfo);</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 省略代码</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，详细看一下事务的创建过程。</p>
<h3 id="TransactionManager"><a href="#TransactionManager" class="headerlink" title="TransactionManager"></a>TransactionManager</h3><p>事务管理器是Srping对事务进行管理的核心，PlatformTransactionManager里面定义了获取事务、提交事务、回滚事务的接口，不同的数据源可以有自己的实现，比如常见的JDBC数据源事务管理器DataSourceTransactionManager以及分布式事务管理器JtaTransactionManager:</p>
<p><img src="/images/TransactionManager.jpeg" alt=""></p>
<h4 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取事务状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><p><img src="/images/TransactionStatus.png" alt=""></p>
<p>PlatformTransactionManager的getTransaction返回的是TransactionStatus，TransactionStatus是一个接口，主要的实现在DefaultTransactionStatus中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransactionStatus可以获取事务的状态，也可以在发生异常时用于回滚</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">TransactionExecution</span>, <span class="title">SavepointManager</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回事务是否设置了保存点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * flush所有的session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultTransactionStatus</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultTransactionStatus</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionStatus</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事务</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object transaction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否新事务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> newTransaction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> newSynchronization;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否只读</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> readOnly;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> debug;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起的事务</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object suspendedResources;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultTransactionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Object transaction, <span class="keyword">boolean</span> newTransaction, <span class="keyword">boolean</span> newSynchronization,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> readOnly, <span class="keyword">boolean</span> debug, @Nullable Object suspendedResources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transaction = transaction;</span><br><span class="line">        <span class="keyword">this</span>.newTransaction = newTransaction;</span><br><span class="line">        <span class="keyword">this</span>.newSynchronization = newSynchronization;</span><br><span class="line">        <span class="keyword">this</span>.readOnly = readOnly;</span><br><span class="line">        <span class="keyword">this</span>.debug = debug;</span><br><span class="line">        <span class="keyword">this</span>.suspendedResources = suspendedResources;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TransactionInfo"><a href="#TransactionInfo" class="headerlink" title="TransactionInfo"></a>TransactionInfo</h3><p>事务的创建方法createTransactionIfNecessary返回的是TransactionInfo对象，后续回滚事务、提交事务等操作，传入的都是TransactionInfo这个对象，它是TransactionAspectSupport的内部类，对事务管理器transactionManager、事务属性transactionAttribute、事务的状态transactionStatus等事务的相关信息进行了封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransactionAspectSupport的内部类TransactionInfo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionInfo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 事务管理器</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务属性</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionAttribute transactionAttribute;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String joinpointIdentification;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务状态</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> TransactionStatus transactionStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旧的事务信息</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> TransactionInfo oldTransactionInfo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindToThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从Holder中获取当前线程绑定的事务信息</span></span><br><span class="line">        <span class="keyword">this</span>.oldTransactionInfo = transactionInfoHolder.get();</span><br><span class="line">        <span class="comment">// 更新当前线程对应的事务信息</span></span><br><span class="line">        transactionInfoHolder.set(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h2><p>事务的创建分为两大部分：</p>
<ol>
<li>调用事务管理器的getTransaction获取事务状态，返回的是TransactionStatus类型的对象</li>
<li>预处理事务，进行事务相关信息的封装以及事务和线程的绑定，返回的是TransactionInfo对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                           @Nullable TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果事务属性不为空，但是名称为空</span></span><br><span class="line">        <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 事务状态</span></span><br><span class="line">        TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取事务状态</span></span><br><span class="line">                status = tm.getTransaction(txAttr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Skipping transactional joinpoint ["</span> + joinpointIdentification +</span><br><span class="line">                            <span class="string">"] because no transaction manager has been configured"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">        <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取事务状态"><a href="#获取事务状态" class="headerlink" title="获取事务状态"></a>获取事务状态</h3><p>事务状态获取是调用PlatformTransactionManager事务管理器的getTransaction获取的，具体实现在AbstractPlatformTransactionManager中：</p>
<ol>
<li>调用doGetTransaction方法获取事务，它是一个抽象方法，需要子类实现，数据源的不同具体的实现类也不同，接下来以常见的<strong>DataSourceTransactionManage</strong>r为例，查看获取事务的具体实现逻辑</li>
<li>当前线程经存在事务，<strong>判断方式是通过当前线程是否持有数据库连接并且事务处于活跃状态</strong><ul>
<li>如果存在事务，需要根据事务传播行为进行不同的处理</li>
</ul>
</li>
<li>当前线程不存在事务<ul>
<li>如果事务的传播行为是PROPAGATION_MANDATORY，当前线程没有事务会抛出异常</li>
<li>如果传播行为是PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW或者PROPAGATION_NESTED，先挂起一个空事务，然后新建事务</li>
<li>其他情况，调用prepareTransactionStatus创建TransactionStatus并返回</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title">PlatformTransactionManager</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取事务定义</span></span><br><span class="line">        TransactionDefinition def = (definition != <span class="keyword">null</span> ? definition : TransactionDefinition.withDefaults());</span><br><span class="line">        <span class="comment">// 获取事务</span></span><br><span class="line">        Object transaction = doGetTransaction();</span><br><span class="line">        <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line">        <span class="comment">// 当前的线程是否已经存在事务</span></span><br><span class="line">        <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">            <span class="comment">// 如果已经存在事务，根据事务传播行为的设置进行不同的处理</span></span><br><span class="line">            <span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前线程不存在事务</span></span><br><span class="line">        <span class="comment">// 检查事务是否超时</span></span><br><span class="line">        <span class="keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">"Invalid transaction timeout"</span>, def.getTimeout());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果事务的传播行为是PROPAGATION_MANDATORY，表示当前线程没有事务会抛出异常，而走到这里说明当前没有事务，所以抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">                    <span class="string">"No existing transaction found for transaction marked with propagation 'mandatory'"</span>);</span><br><span class="line">        &#125;<span class="comment">// 如果传播行为是PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW或者PROPAGATION_NESTED</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">                def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">                def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">            <span class="comment">// 因为当前线程不存在事务，所以先挂起一个空事务</span></span><br><span class="line">            SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Creating new transaction with name ["</span> + def.getName() + <span class="string">"]: "</span> + def);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 开启新事务</span></span><br><span class="line">                <span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">                resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Create "empty" transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">            <span class="keyword">if</span> (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Custom isolation level specified but no actual transaction initiated; "</span> +</span><br><span class="line">                        <span class="string">"isolation level will effectively be ignored: "</span> + def);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">            <span class="comment">// 其他情况，创建TransactionStatus</span></span><br><span class="line">            <span class="keyword">return</span> prepareTransactionStatus(def, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="doGetTransaction获取事务"><a href="#doGetTransaction获取事务" class="headerlink" title="doGetTransaction获取事务"></a>doGetTransaction获取事务</h5><p>DataSourceTransactionManager实现了doGetTransaction获取事务的方法：</p>
<ol>
<li><strong>创建DataSourceTransactionObject对象，它是DataSourceTransactionManager内部类，持有一个ConnectionHolder对象，里面记录了数据库的连接</strong></li>
<li>调用obtainDataSource获取数据源</li>
<li>从ThreadLocal中获取当前线程对应的Map资源数据集合，根据第2步中获取到的数据源从Map中获取对应的ConnectionHolder，<strong>也就是说当前线程绑定了某个数据源的连接，从ThreadLocal获取到数据库连接之后，将数据库连接设置到DataSourceTransactionObject中</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title">AbstractPlatformTransactionManager</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ResourceTransactionManager</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取事务，返回的是DataSourceTransactionObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doGetTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建DataSourceTransactionObject</span></span><br><span class="line">        DataSourceTransactionObject txObject = <span class="keyword">new</span> DataSourceTransactionObject();</span><br><span class="line">        <span class="comment">// 设置是否允许保存点</span></span><br><span class="line">        txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line">        <span class="comment">// 根据数据源获取当前线程绑定的ConnectionHolder对象，ConnectionHolder中存有数据库连接</span></span><br><span class="line">        ConnectionHolder conHolder =</span><br><span class="line">                (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());</span><br><span class="line">        <span class="comment">// 设置ConnectionHolder对象</span></span><br><span class="line">        txObject.setConnectionHolder(conHolder, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> txObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DataSource <span class="title">obtainDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取数据源</span></span><br><span class="line">        DataSource dataSource = getDataSource();</span><br><span class="line">        Assert.state(dataSource != <span class="keyword">null</span>, <span class="string">"No DataSource set"</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部类，DataSourceTransactionObject，记录了数据源信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionObject</span> <span class="keyword">extends</span> <span class="title">JdbcTransactionObjectSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> newConnectionHolder;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mustRestoreAutoCommit;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置连接信息，connectionHolder在父类JdbcTransactionObjectSupport中</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionHolder</span><span class="params">(@Nullable ConnectionHolder connectionHolder, <span class="keyword">boolean</span> newConnectionHolder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setConnectionHolder(connectionHolder);</span><br><span class="line">            <span class="keyword">this</span>.newConnectionHolder = newConnectionHolder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JdbcTransactionObjectSupport</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTransactionObjectSupport</span> <span class="keyword">implements</span> <span class="title">SavepointManager</span>, <span class="title">SmartTransactionObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ConnectionHolder，记录了数据库连接</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ConnectionHolder connectionHolder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConnectionHolder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionHolder</span> <span class="keyword">extends</span> <span class="title">ResourceHolderSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据库连接</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Connection currentConnection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TransactionSynchronizationManager</strong></p>
<p>TransactionSynchronizationManager中保存了线程绑定的各种信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存了线程绑定的数据库资源信息，Map中Key为数据源构建的KEY，value为对应的ConnectionHolder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transactional resources"</span>);</span><br><span class="line">    <span class="comment">// 保存了线程绑定的事务同步信息TransactionSynchronization</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transaction synchronizations"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存了线程绑定的事务名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction name"</span>);</span><br><span class="line">    <span class="comment">// 保存了线程绑定的事务只读状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction read-only status"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存了线程绑定的事务隔离级别</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction isolation level"</span>);</span><br><span class="line">    <span class="comment">// 保存了线程绑定的事务活跃状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Actual transaction active"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key（数据源dataSource）获取当前线程绑定的资源，也就是ConnectionHoler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getResource</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建KEY</span></span><br><span class="line">        Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);</span><br><span class="line">        <span class="comment">// 获取资源</span></span><br><span class="line">        Object value = doGetResource(actualKey);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Retrieved value ["</span> + value + <span class="string">"] for key ["</span> + actualKey + <span class="string">"] bound to thread ["</span> +</span><br><span class="line">                    Thread.currentThread().getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据KEY获取资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">doGetResource</span><span class="params">(Object actualKey)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程对应的数据,其中KEY为根据数据源构建出的KEY，value为ConnectionHoler</span></span><br><span class="line">        Map&lt;Object, Object&gt; map = resources.get();</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据KEY获取数据源</span></span><br><span class="line">        Object value = map.get(actualKey);</span><br><span class="line">        <span class="comment">// Transparently remove ResourceHolder that was marked as void...</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123;</span><br><span class="line">            map.remove(actualKey);</span><br><span class="line">            <span class="comment">// Remove entire ThreadLocal if empty...</span></span><br><span class="line">            <span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">                resources.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            value = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="isExistingTransaction是否存在事务"><a href="#isExistingTransaction是否存在事务" class="headerlink" title="isExistingTransaction是否存在事务"></a>isExistingTransaction是否存在事务</h5><p>isExistingTransaction同样在DataSourceTransactionManager中实现，<strong>具体是是通过DataSourceTransactionObject是否持有数据库连接并且事务处于活跃状态来判断是否存在事务的：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title">AbstractPlatformTransactionManager</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ResourceTransactionManager</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isExistingTransaction</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转换为DataSourceTransactionObject</span></span><br><span class="line">        DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">        <span class="comment">// 通过判断DataSourceTransactionObject是否持有ConnectionHolder并且事务处于活跃状态</span></span><br><span class="line">        <span class="keyword">return</span> (txObject.hasConnectionHolder() &amp;&amp; txObject.getConnectionHolder().isTransactionActive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="handleExistingTransaction当程已存在事务情况下的处理"><a href="#handleExistingTransaction当程已存在事务情况下的处理" class="headerlink" title="handleExistingTransaction当程已存在事务情况下的处理"></a>handleExistingTransaction当程已存在事务情况下的处理</h5><p>在当前线程已存在事务的情况下：</p>
<ol>
<li>如果事务传播行为设是PROPAGATION_NEVER，表示以非事务的方式执行，如果当前存在事务，将抛出异常</li>
<li>如果事务的传播行为是PROPAGATION_NOT_SUPPORTED，表示以非事务的方式执行，如果当前存在事务，则挂起当前的事务，不使用事务</li>
<li>如果事务的传播行为是PROPAGATION_REQUIRES_NEW，需要挂起当前事务，创建一个自己的事务</li>
<li>如果事务的传播行为是PROPAGATION_NESTED，判断是否使用保存点<ul>
<li>如果是使用嵌套事务</li>
<li>如果不是，开启一个新事务</li>
</ul>
</li>
<li>非以上四种情况，使用当前的事务，调用prepareTransactionStatus方法创建TransactionStatus</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title">PlatformTransactionManager</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理存在的事务，主要是对事务传播行为的判断和处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">handleExistingTransaction</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                TransactionDefinition definition, Object transaction,<span class="keyword">boolean</span> debugEnabled)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">            <span class="comment">// 如果事务传播行为设置的是PROPAGATION_NEVER，表示以非事务的方式执行，所以当前存在事务将抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">                        <span class="string">"Existing transaction found for transaction marked with propagation 'never'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果事务的传播行为是PROPAGATION_NOT_SUPPORTED，表示以非事务的方式执行，如果当前存在事务，则挂起当前事务，不使用事务</span></span><br><span class="line">            <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Suspending current transaction"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 挂起当前事务</span></span><br><span class="line">                Object suspendedResources = suspend(transaction);</span><br><span class="line">                <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">                <span class="comment">// 创建TransactionStatus，第二个参数传入的是事务，可以看到这里设置的为NULL，不使用事务</span></span><br><span class="line">                <span class="keyword">return</span> prepareTransactionStatus(</span><br><span class="line">                        definition, <span class="keyword">null</span>, <span class="keyword">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果事务的传播行为是PROPAGATION_REQUIRES_NEW，需要挂起当前事务创建新事务</span></span><br><span class="line">            <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">                <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Suspending current transaction, creating new transaction with name ["</span> +</span><br><span class="line">                            definition.getName() + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 挂起当前事务</span></span><br><span class="line">                SuspendedResourcesHolder suspendedResources = suspend(transaction);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 新建事务</span></span><br><span class="line">                    <span class="keyword">return</span> startTransaction(definition, transaction, debugEnabled, suspendedResources);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException | Error beginEx) &#123;</span><br><span class="line">                    resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">                    <span class="keyword">throw</span> beginEx;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是PROPAGATION_NESTED</span></span><br><span class="line">            <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">                <span class="comment">// 是否允许嵌套事务</span></span><br><span class="line">                <span class="keyword">if</span> (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NestedTransactionNotSupportedException(</span><br><span class="line">                            <span class="string">"Transaction manager does not allow nested transactions by default - "</span> +</span><br><span class="line">                                    <span class="string">"specify 'nestedTransactionAllowed' property with value 'true'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Creating nested transaction with name ["</span> + definition.getName() + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 是否使用保存点</span></span><br><span class="line">                <span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">                    <span class="comment">// 创建DefaultTransactionStatus，开启嵌套事务</span></span><br><span class="line">                    DefaultTransactionStatus status =</span><br><span class="line">                            prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, <span class="keyword">false</span>, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 创建保存点</span></span><br><span class="line">                    status.createAndHoldSavepoint();</span><br><span class="line">                    <span class="comment">// 返回事务状态</span></span><br><span class="line">                    <span class="keyword">return</span> status;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 新建事务</span></span><br><span class="line">                    <span class="keyword">return</span> startTransaction(definition, transaction, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</span></span><br><span class="line">            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Participating in existing transaction"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 校验存在事务的合法性</span></span><br><span class="line">            <span class="keyword">if</span> (isValidateExistingTransaction()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</span><br><span class="line">                    Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">                    <span class="keyword">if</span> (currentIsolationLevel == <span class="keyword">null</span> || currentIsolationLevel != definition.getIsolationLevel()) &#123;</span><br><span class="line">                        Constants isoConstants = DefaultTransactionDefinition.constants;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(<span class="string">"Participating transaction with definition ["</span> +</span><br><span class="line">                                definition + <span class="string">"] specifies isolation level which is incompatible with existing transaction: "</span> +</span><br><span class="line">                                (currentIsolationLevel != <span class="keyword">null</span> ?</span><br><span class="line">                                        isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :</span><br><span class="line">                                        <span class="string">"(unknown)"</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!definition.isReadOnly()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(<span class="string">"Participating transaction with definition ["</span> +</span><br><span class="line">                                definition + <span class="string">"] is not marked as read-only but existing transaction is"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">            <span class="comment">// 创建TransactionStatus</span></span><br><span class="line">            <span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="prepareTransactionStatus创建TransactionStatus"><a href="#prepareTransactionStatus创建TransactionStatus" class="headerlink" title="prepareTransactionStatus创建TransactionStatus"></a>prepareTransactionStatus创建TransactionStatus</h5><p>prepareTransactionStatus用于创建TransactionStatus，具体创建的是DefaultTransactionStatus类型的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title">PlatformTransactionManager</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建TransactionStatus</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> definition         事务定义</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transaction        事务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newTransaction     是否新事务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newSynchronization 是否需要同步线程绑定的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> debug</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> suspendedResources 挂起的事务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> DefaultTransactionStatus <span class="title">prepareTransactionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            TransactionDefinition definition, @Nullable Object transaction, <span class="keyword">boolean</span> newTransaction,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> newSynchronization, <span class="keyword">boolean</span> debug, @Nullable Object suspendedResources)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建DefaultTransactionStatus</span></span><br><span class="line">        DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">                definition, transaction, newTransaction, newSynchronization, debug, suspendedResources);</span><br><span class="line">        <span class="comment">// 初始化事务的同步信息</span></span><br><span class="line">        prepareSynchronization(status, definition);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化事务的同步信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareSynchronization</span><span class="params">(DefaultTransactionStatus status, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">            <span class="comment">// 设置当前线程绑定的线程活跃状态</span></span><br><span class="line">            TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());</span><br><span class="line">            <span class="comment">// 设置绑定的事务隔离级别</span></span><br><span class="line">            TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(</span><br><span class="line">                    definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?</span><br><span class="line">                            definition.getIsolationLevel() : <span class="keyword">null</span>);</span><br><span class="line">            TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());</span><br><span class="line">            <span class="comment">// 设置绑定的事务名称</span></span><br><span class="line">            TransactionSynchronizationManager.setCurrentTransactionName(definition.getName());</span><br><span class="line">            TransactionSynchronizationManager.initSynchronization();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="suspend挂起事务"><a href="#suspend挂起事务" class="headerlink" title="suspend挂起事务"></a>suspend挂起事务</h5><p>挂起事务其实是将当前事务的相关设置清除，并解绑当前线程对应的数据库连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title">PlatformTransactionManager</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 挂起事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SuspendedResourcesHolder <span class="title">suspend</span><span class="params">(@Nullable Object transaction)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">        <span class="comment">// 判断活跃状态</span></span><br><span class="line">        <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">            List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object suspendedResources = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 挂起事务</span></span><br><span class="line">                    suspendedResources = doSuspend(transaction);</span><br><span class="line">                &#125;</span><br><span class="line">                String name = TransactionSynchronizationManager.getCurrentTransactionName();</span><br><span class="line">                <span class="comment">// 清除当前事务的各种信息</span></span><br><span class="line">                TransactionSynchronizationManager.setCurrentTransactionName(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">boolean</span> readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</span><br><span class="line">                TransactionSynchronizationManager.setCurrentTransactionReadOnly(<span class="keyword">false</span>);</span><br><span class="line">                Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">                TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">boolean</span> wasActive = TransactionSynchronizationManager.isActualTransactionActive();</span><br><span class="line">                TransactionSynchronizationManager.setActualTransactionActive(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(</span><br><span class="line">                        suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">                <span class="comment">// doSuspend failed - original transaction is still active...</span></span><br><span class="line">                doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Transaction active but no synchronization active.</span></span><br><span class="line">            Object suspendedResources = doSuspend(transaction);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(suspendedResources);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Neither transaction nor synchronization active.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataSourceTransactionManager挂起事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title">AbstractPlatformTransactionManager</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ResourceTransactionManager</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doSuspend</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转为DataSourceTransactionObject</span></span><br><span class="line">        DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">        <span class="comment">// 将绑定的数据库连接置为null</span></span><br><span class="line">        txObject.setConnectionHolder(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 解绑当前线程的对应的数据源连接</span></span><br><span class="line">        <span class="keyword">return</span> TransactionSynchronizationManager.unbindResource(obtainDataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑资源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存了线程绑定的数据库资源信息，Map中Key为数据源构建的KEY，value为对应的ConnectionHolder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transactional resources"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解绑当前线程对应的资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unbindResource</span><span class="params">(Object key)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="comment">// 根据对象获取KEY</span></span><br><span class="line">        Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);</span><br><span class="line">        <span class="comment">// 解绑当前线程绑定的资源</span></span><br><span class="line">        Object value = doUnbindResource(actualKey);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"No value for key ["</span> + actualKey + <span class="string">"] bound to thread ["</span> + Thread.currentThread().getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解绑资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">doUnbindResource</span><span class="params">(Object actualKey)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程对应的数据</span></span><br><span class="line">        Map&lt;Object, Object&gt; map = resources.get();</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从Map中移除资源</span></span><br><span class="line">        Object value = map.remove(actualKey);</span><br><span class="line">        <span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">            resources.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123;</span><br><span class="line">            value = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Removed value ["</span> + value + <span class="string">"] for key ["</span> + actualKey + <span class="string">"] from thread ["</span> +</span><br><span class="line">                    Thread.currentThread().getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="startTransaction新建事务"><a href="#startTransaction新建事务" class="headerlink" title="startTransaction新建事务"></a>startTransaction新建事务</h5><p>startTransaction用于开启一个新事务，在AbstractPlatformTransactionManager中实现：</p>
<ol>
<li>创建TransactionStatus，可以看到在构造函数中传入了事务定义、当前事务、是否新建事务（置为了true）、是否同步、是否debug、挂起的事务这些参数</li>
<li>调用doBegin方法设置事务的一些信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title">PlatformTransactionManager</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启一个新事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">startTransaction</span><span class="params">(TransactionDefinition definition, Object transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">boolean</span> debugEnabled, @Nullable SuspendedResourcesHolder suspendedResources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">        <span class="comment">// 创建新事务DefaultTransactionStatus，第三个参数表示是否新建事务，这里置为了true, suspendedResources记录了挂起的事务</span></span><br><span class="line">        DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">                definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">        <span class="comment">// 设置事务的相关信息</span></span><br><span class="line">        doBegin(transaction, definition);</span><br><span class="line">        prepareSynchronization(status, definition);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doBegin方法在DataSourceTransactionManager中实现：</p>
<ol>
<li><strong>判断当前事务是否持有数据库连接获取事务与数据库的同步状态为true，从数据源中新建一个数据库连接，并与当前事务绑定</strong></li>
<li>如果开启了自动提交，将自动提交置为false</li>
<li><strong>如果是新创建的连接，将数据库连接ConnectionHolder绑定到当前线程</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataSourceTransactionManager实现了doBegin</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title">AbstractPlatformTransactionManager</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ResourceTransactionManager</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转为DataSourceTransactionObject</span></span><br><span class="line">        DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">        Connection con = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果未持有连接信息或者事务与数据库的同步状态为true</span></span><br><span class="line">            <span class="keyword">if</span> (!txObject.hasConnectionHolder() ||</span><br><span class="line">                    txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">                <span class="comment">// 从数据源获取一个新的连接</span></span><br><span class="line">                Connection newCon = obtainDataSource().getConnection();</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Acquired Connection ["</span> + newCon + <span class="string">"] for JDBC transaction"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将连接信息设置到当前的事务中</span></span><br><span class="line">                txObject.setConnectionHolder(<span class="keyword">new</span> ConnectionHolder(newCon), <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将事务与数据库连接的同步状态置为true</span></span><br><span class="line">            txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 获取数据库连接</span></span><br><span class="line">            con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">            Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">            txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line">            txObject.setReadOnly(definition.isReadOnly());</span><br><span class="line">            <span class="comment">// 是否是自动提交</span></span><br><span class="line">            <span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">                txObject.setMustRestoreAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Switching JDBC Connection ["</span> + con + <span class="string">"] to manual commit"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 自动提交置为false</span></span><br><span class="line">                con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理连接</span></span><br><span class="line">            prepareTransactionalConnection(con, definition);</span><br><span class="line">            <span class="comment">// 事务置为活跃状态</span></span><br><span class="line">            txObject.getConnectionHolder().setTransactionActive(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 超时时间获取</span></span><br><span class="line">            <span class="keyword">int</span> timeout = determineTimeout(definition);</span><br><span class="line">            <span class="keyword">if</span> (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">                txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 是否是新建的连接</span></span><br><span class="line">            <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">                <span class="comment">// 将数据库连接ConnectionHolder绑定到当前线程</span></span><br><span class="line">                TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">                DataSourceUtils.releaseConnection(con, obtainDataSource());</span><br><span class="line">                txObject.setConnectionHolder(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CannotCreateTransactionException(<span class="string">"Could not open JDBC Connection for transaction"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事务预处理"><a href="#事务预处理" class="headerlink" title="事务预处理"></a>事务预处理</h3><ol>
<li>创建TransactionInfo事务信息，它是TransactionAspectSupport的内部类，将事务管理器transactionManager、事务属性transactionAttribute、事务的状态transactionStatus等事务相关的信息进行了封装，并实现了将事务绑定到当前线程的方法</li>
<li><strong>调用TransactionInfo的bindToThread方法将事务与当前线程绑定，是通过ThreadLocal实现的</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 准备事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">prepareTransactionInfo</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     @Nullable TransactionAttribute txAttr, String joinpointIdentification,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     @Nullable TransactionStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建事务信息</span></span><br><span class="line">        TransactionInfo txInfo = <span class="keyword">new</span> TransactionInfo(tm, txAttr, joinpointIdentification);</span><br><span class="line">        <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Getting transaction for ["</span> + txInfo.getJoinpointIdentification() + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置事务状态</span></span><br><span class="line">            txInfo.newTransactionStatus(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"No need to create transaction for ["</span> + joinpointIdentification +</span><br><span class="line">                        <span class="string">"]: This method is not transactional."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将事务绑定到当前线程</span></span><br><span class="line">        txInfo.bindToThread();</span><br><span class="line">        <span class="keyword">return</span> txInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用ThreadLocal记录线程绑定的事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;TransactionInfo&gt; transactionInfoHolder =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current aspect-driven transaction"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部类TransactionInfo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TransactionAttribute transactionAttribute;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String joinpointIdentification;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">private</span> TransactionStatus transactionStatus;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">private</span> TransactionInfo oldTransactionInfo;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindToThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 从Holder中获取当前线程绑定的事务信息</span></span><br><span class="line">            <span class="keyword">this</span>.oldTransactionInfo = transactionInfoHolder.get();</span><br><span class="line">            <span class="comment">// 更新当前线程对应的事务信息</span></span><br><span class="line">            transactionInfoHolder.set(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p><img src="/images/事务创建.png" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://blog.csdn.net/qq_36882793/article/details/106440723" target="_blank" rel="noopener">【猫吻鱼】Spring源码分析：全集整理</a></p>
<p><strong>Spring版本：5.2.5.RELEASE</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/02/【Srping】事务的执行原理（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/02/【Srping】事务的执行原理（一）/" itemprop="url">【Spring】事务的执行原理（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-02T21:30:00+08:00">
                2022-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用事务的时候需要添加@EnableTransactionManagement注解来开启事务，那么就从@EnableTransactionManagement入手查看一下事务的执行原理。</p>
<p><strong>@EnableTransactionManagement</strong></p>
<ol>
<li><strong>Spring事务底层是通过AOP来完成的，而Spring AOP基于动态代理实现</strong>，可以看到mode方法默认返回了PROXY代理模式，我们只需关注代理模式下的执行流程即可</li>
<li>使用@Import导入了TransactionManagementConfigurationSelector</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(TransactionManagementConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否代理目标类</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用代理模式</span></span><br><span class="line">    <span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TransactionManagementConfigurationSelector</strong></p>
<p>在selectImports方法中可以看到对模式进行了判断：</p>
<ol>
<li>如果是基于代理模式，返回AutoProxyRegistrar和ProxyTransactionManagementConfiguration类</li>
<li>如果是基于ASPECTJ，调用determineTransactionAspectClass方法</li>
</ol>
<p>Spring默认使用的是代理模式，所以接下来看下AutoProxyRegistrar和ProxyTransactionManagementConfiguration里面都有什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManagementConfigurationSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableTransactionManagement</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROXY:</span><br><span class="line">                <span class="comment">// 如果基于代理模式</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">                        ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">            <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">                <span class="comment">// 如果基于ASPECTJ</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">determineTransactionAspectClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ClassUtils.isPresent(<span class="string">"javax.transaction.Transactional"</span>, getClass().getClassLoader()) ?</span><br><span class="line">                TransactionManagementConfigUtils.JTA_TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME :</span><br><span class="line">                TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AutoProxyRegistrar"><a href="#AutoProxyRegistrar" class="headerlink" title="AutoProxyRegistrar"></a>AutoProxyRegistrar</h2><p>AutoProxyRegistrar实现了ImportBeanDefinitionRegistrar接口，ImportBeanDefinitionRegistrar可以向容器中注册Bean，跟着registerBeanDefinitions方法看下它会向容器中注册什么样的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> candidateFound = <span class="keyword">false</span>;</span><br><span class="line">        Set&lt;String&gt; annTypes = importingClassMetadata.getAnnotationTypes();</span><br><span class="line">        <span class="keyword">for</span> (String annType : annTypes) &#123;</span><br><span class="line">            AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);</span><br><span class="line">            <span class="keyword">if</span> (candidate == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Object mode = candidate.get(<span class="string">"mode"</span>);</span><br><span class="line">            Object proxyTargetClass = candidate.get(<span class="string">"proxyTargetClass"</span>);</span><br><span class="line">            <span class="keyword">if</span> (mode != <span class="keyword">null</span> &amp;&amp; proxyTargetClass != <span class="keyword">null</span> &amp;&amp; AdviceMode.class == mode.getClass() &amp;&amp;</span><br><span class="line">                    Boolean.class == proxyTargetClass.getClass()) &#123;</span><br><span class="line">                candidateFound = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (mode == AdviceMode.PROXY) &#123;</span><br><span class="line">                    <span class="comment">// 调用AopConfigUtils的registerAutoProxyCreatorIfNecessary向容器中注册bean</span></span><br><span class="line">                    AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">                    <span class="keyword">if</span> ((Boolean) proxyTargetClass) &#123;</span><br><span class="line">                        AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AopConfigUtils"><a href="#AopConfigUtils" class="headerlink" title="AopConfigUtils"></a>AopConfigUtils</h3><p>在AopConfigUtils中一共有三种自动代理创建器：</p>
<ol>
<li>InfrastructureAdvisorAutoProxyCreator</li>
<li>AspectJAwareAdvisorAutoProxyCreator</li>
<li>AnnotationAwareAspectJAutoProxyCreator</li>
</ol>
<p>在registerAutoProxyCreatorIfNecessary方法中，可以看到事务使用的是InfrastructureAdvisorAutoProxyCreator类型的创建器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AopConfigUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动代理创建器BeanName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTO_PROXY_CREATOR_BEAN_NAME =</span><br><span class="line">            <span class="string">"org.springframework.aop.config.internalAutoProxyCreator"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有的自动代理创建器集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; APC_PRIORITY_LIST = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);</span><br><span class="line">        APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class); <span class="comment">// AspectJ</span></span><br><span class="line">        APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class); <span class="comment">// 注解</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AutoProxyRegistrar中调用的registerAutoProxyCreatorIfNecessary方法</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 会调用下面那个registerAutoProxyCreatorIfNecessary方法</span></span><br><span class="line">        <span class="keyword">return</span> registerAutoProxyCreatorIfNecessary(registry, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用registerOrEscalateApcAsRequired进行注册，这里传入的是InfrastructureAdvisorAutoProxyCreator类型的</span></span><br><span class="line">        <span class="keyword">return</span> registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">        <span class="comment">// 判断容器中是否已经包含代理创建器</span></span><br><span class="line">        <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">            <span class="comment">// 从容器中获取</span></span><br><span class="line">            BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">            <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">                <span class="comment">// 判断容器中已经存在的创建器的优先级</span></span><br><span class="line">                <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">                <span class="comment">// 需要的创建器的优先级</span></span><br><span class="line">                <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">                <span class="comment">// 如果容器中已经存在的创建器的优先级小于需要创建的</span></span><br><span class="line">                <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                    <span class="comment">// 使用优先级高的</span></span><br><span class="line">                    apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建RootBeanDefinition</span></span><br><span class="line">        RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">        <span class="comment">// 设置source</span></span><br><span class="line">        beanDefinition.setSource(source);</span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        <span class="comment">// 注册代理创建器</span></span><br><span class="line">        registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>AutoProxyRegistrar实现ImportBeanDefinitionRegistrar是为了向容器中注册代理创建器，事务默认使用的是InfrastructureAdvisorAutoProxyCreator类型的。</strong></p>
<h2 id="ProxyTransactionManagementConfiguration"><a href="#ProxyTransactionManagementConfiguration" class="headerlink" title="ProxyTransactionManagementConfiguration"></a>ProxyTransactionManagementConfiguration</h2><p><strong>1. AOP概念</strong></p>
<p><strong>Advice通知：</strong>定义在切点上需要执行什么样的操作</p>
<p><strong>PointCut切点</strong>：定义在哪些方法上使用通知</p>
<p><strong>Advisor：</strong>Advice和Pointcut加起来组成了Advisor</p>
<p><strong>2. 事务中的Advisor</strong></p>
<p>我们已经知道事务是基于AOP实现的，在transactionAdvisor方法中可以看到创建了Advisor，然后设置了事务属性TransactionAttributeSource和事务拦截器TransactionInterceptor：</p>
<ul>
<li><strong>TransactionAttributeSource，从名字上可以看出是和事务的属性设置相关的</strong></li>
<li><strong>TransactionInterceptor事务拦截器相当于Advice通知</strong></li>
<li><strong>BeanFactoryTransactionAttributeSourceAdvisor是Advisor</strong></li>
</ul>
<p>Advisor由Advice和PointCut组成，现在Advice已经有了，接下来看下Pointcut在哪里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTransactionManagementConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionManagementConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span><br><span class="line">    <span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title">transactionAdvisor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Advisor</span></span><br><span class="line">        BeanFactoryTransactionAttributeSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryTransactionAttributeSourceAdvisor();</span><br><span class="line">        <span class="comment">// 设置TransactionAttributeSource，类型为AnnotationTransactionAttributeSource</span></span><br><span class="line">        advisor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">        <span class="comment">// 设置事务拦截器，相当于Advice</span></span><br><span class="line">        advisor.setAdvice(transactionInterceptor);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.enableTx != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisor.setOrder(<span class="keyword">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="string">"order"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransactionAttributeSource <span class="title">transactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建AnnotationTransactionAttributeSource</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationTransactionAttributeSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransactionInterceptor <span class="title">transactionInterceptor</span><span class="params">(TransactionAttributeSource transactionAttributeSource)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建事务拦截器</span></span><br><span class="line">        TransactionInterceptor interceptor = <span class="keyword">new</span> TransactionInterceptor();</span><br><span class="line">        interceptor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.txManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interceptor.setTransactionManager(<span class="keyword">this</span>.txManager);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BeanFactoryTransactionAttributeSourceAdvisor"><a href="#BeanFactoryTransactionAttributeSourceAdvisor" class="headerlink" title="BeanFactoryTransactionAttributeSourceAdvisor"></a>BeanFactoryTransactionAttributeSourceAdvisor</h2><p>BeanFactoryTransactionAttributeSourceAdvisor继承关系如下：</p>
<p><img src="/images/BeanFactoryTransactionAttributeSourceAdvisor.png" alt=""></p>
<p>除了继承父类的属性和方法，它自己还有两个成员变量：</p>
<ol>
<li>transactionAttributeSource，实际传入的是AnnotationTransactionAttributeSource类型的对象</li>
<li><strong>TransactionAttributeSourcePointcut类型的切点pointcut</strong><ul>
<li>切点在实例化时实现了getTransactionAttributeSource方法，返回了transactionAttributeSource，后面的方法中需要调用此方法获取transactionAttributeSource</li>
</ul>
</li>
</ol>
<p>由上面的分析可知，在创建BeanFactoryTransactionAttributeSourceAdvisor的时候，<strong>设置了TransactionInterceptor和TransactionAttributeSource，TransactionInterceptor相当于Advice，而这里我们看到了它还有一个TransactionAttributeSourcePointcut切点:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactoryPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> TransactionAttributeSource transactionAttributeSource; <span class="comment">// 实际传入的是AnnotationTransactionAttributeSource类型的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建切点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionAttributeSourcePointcut pointcut = <span class="keyword">new</span> TransactionAttributeSourcePointcut() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现了getTransactionAttributeSource方法，返回的是AnnotationTransactionAttributeSource</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> TransactionAttributeSource <span class="title">getTransactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> transactionAttributeSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionAttributeSource</span><span class="params">(TransactionAttributeSource transactionAttributeSource)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置TransactionAttributeSource</span></span><br><span class="line">        <span class="keyword">this</span>.transactionAttributeSource = transactionAttributeSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pointcut;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TransactionAttributeSourcePointcut"><a href="#TransactionAttributeSourcePointcut" class="headerlink" title="TransactionAttributeSourcePointcut"></a>TransactionAttributeSourcePointcut</h3><p>TransactionAttributeSourcePointcut是一个切点，它的继承关系如下：</p>
<p><img src="/images/TransactionAttributeSourcePointcut.png" alt=""></p>
<p><strong>Pointcut</strong>和<strong>MethodMatcher</strong></p>
<p>Pointcut接口中定义了两个方法：</p>
<ol>
<li>获取ClassFilter，ClassFilter是一个接口，里面定义了matches方法，检查切点是否与类匹配</li>
<li>获取MethodMatcher，它也是一个接口，并且定义了matches方法，检查切点是否与方法匹配</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回类过滤器ClassFilter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回MethodMatcher</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查方法是否匹配pointcut</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查方法是否匹配pointcut</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查类是否与pointcut匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransactionAttributeSourcePointcut是Pointcut和MethodMatcher的子类：</p>
<ol>
<li>在构造函数中设置了ClassFilter，类型为TransactionAttributeSourceClassFilter，它是TransactionAttributeSourcePointcut的一个内部类，实现了ClassFilter接口中定义的matches方法，检查pointcut与类是否匹配：<ul>
<li><strong>如果是TransactionalProxy、PlatformTransactionManager或者PersistenceExceptionTranslator的子类，则不匹配</strong></li>
<li><strong>获取TransactionAttributeSource，调用它的isCandidateClass方法判断是否匹配</strong></li>
</ul>
</li>
<li>实现了MethodMatcher接口中定义的matches方法，检查pointcut是否匹配当前的方法<ul>
<li><strong>获取TransactionAttributeSource判断是否为空，如果不为空则调用getTransactionAttribute获取事务属性，TransactionAttributeSource为空，或者从TransactionAttributeSource获取到的事务属性不为空都会返回true</strong></li>
</ul>
</li>
</ol>
<p><strong>所以一个方法执行时开启事务，需要满足两个条件，当前的方法和类都需要与事务的pointcut匹配，对应的方法分别是MethodMatcher的matches和ClassFilter的matches方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAttributeSourcePointcut</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcut</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TransactionAttributeSourcePointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置ClassFilter</span></span><br><span class="line">        setClassFilter(<span class="keyword">new</span> TransactionAttributeSourceClassFilter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法是否与切点匹配</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取TransactionAttributeSource，由上面的步骤可知返回的是AnnotationTransactionAttributeSource</span></span><br><span class="line">        TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">        <span class="comment">// 如果TransactionAttributeSource为空，或者从TransactionAttributeSource获取到的事务属性不为空都会返回true</span></span><br><span class="line">        <span class="keyword">return</span> (tas == <span class="keyword">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ClassFilter过滤器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAttributeSourceClassFilter</span> <span class="keyword">implements</span> <span class="title">ClassFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切点是否与类匹配</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果TransactionalProxy、PlatformTransactionManager或者PersistenceExceptionTranslator的子类，则不匹配</span></span><br><span class="line">            <span class="keyword">if</span> (TransactionalProxy.class.isAssignableFrom(clazz) ||</span><br><span class="line">                    PlatformTransactionManager.class.isAssignableFrom(clazz) ||</span><br><span class="line">                    PersistenceExceptionTranslator.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取TransactionAttributeSource，由上文可知是AnnotationTransactionAttributeSource类型的</span></span><br><span class="line">            TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">            <span class="comment">// 调用isCandidateClass方法判断是否是匹配</span></span><br><span class="line">            <span class="keyword">return</span> (tas == <span class="keyword">null</span> || tas.isCandidateClass(clazz));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AnnotationTransactionAttributeSource</strong></p>
<h4 id="条件一：检查类是否匹配事务切点"><a href="#条件一：检查类是否匹配事务切点" class="headerlink" title="条件一：检查类是否匹配事务切点"></a>条件一：检查类是否匹配事务切点</h4><p>上面分析可知，检查类是否与切点匹配时获取了TransactionAttributeSource，调用它的isCandidateClass方法进行判断，TransactionAttributeSource的具体实现是AnnotationTransactionAttributeSource：</p>
<ol>
<li>在构造方法中，添加了注解解析器：<ul>
<li><strong>Spring事务注解解析器的实现类为SpringTransactionAnnotationParser，也是默认的注解解析器</strong>。</li>
<li>如果开启了JTA或者EJB，将会分别添加对应的解析器。</li>
</ul>
</li>
<li>实现了isCandidateClass方法，实际又是调用注解解析器的isCandidateClass判断是否是候选类的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTransactionAttributeSource</span> <span class="keyword">extends</span> <span class="title">AbstractFallbackTransactionAttributeSource</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jta12Present;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ejb3Present;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ClassLoader classLoader = AnnotationTransactionAttributeSource.class.getClassLoader();</span><br><span class="line">        jta12Present = ClassUtils.isPresent(<span class="string">"javax.transaction.Transactional"</span>, classLoader);</span><br><span class="line">        ejb3Present = ClassUtils.isPresent(<span class="string">"javax.ejb.TransactionAttribute"</span>, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> publicMethodsOnly;</span><br><span class="line">    <span class="comment">// 注解解析器集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;TransactionAnnotationParser&gt; annotationParsers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotationTransactionAttributeSource</span><span class="params">(<span class="keyword">boolean</span> publicMethodsOnly)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publicMethodsOnly = publicMethodsOnly;</span><br><span class="line">        <span class="comment">// 添加注解解析器</span></span><br><span class="line">        <span class="keyword">if</span> (jta12Present || ejb3Present) &#123;</span><br><span class="line">            <span class="keyword">this</span>.annotationParsers = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">            <span class="comment">// 添加Spring事务注解解析器</span></span><br><span class="line">            <span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> SpringTransactionAnnotationParser());</span><br><span class="line">            <span class="keyword">if</span> (jta12Present) &#123;</span><br><span class="line">                <span class="comment">// JTA事务注解解析器</span></span><br><span class="line">                <span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> JtaTransactionAnnotationParser());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ejb3Present) &#123;</span><br><span class="line">                <span class="comment">// EJB3事务注解解析器</span></span><br><span class="line">                <span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> Ejb3TransactionAnnotationParser());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 添加Spring事务注解解析器</span></span><br><span class="line">            <span class="keyword">this</span>.annotationParsers = Collections.singleton(<span class="keyword">new</span> SpringTransactionAnnotationParser());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是候选类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCandidateClass</span><span class="params">(Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TransactionAnnotationParser parser : <span class="keyword">this</span>.annotationParsers) &#123;</span><br><span class="line">            <span class="comment">// 调用解析器的isCandidateClass方法判断是否是候选类</span></span><br><span class="line">            <span class="keyword">if</span> (parser.isCandidateClass(targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SpringTransactionAnnotationParser</strong></p>
<ol>
<li><p>SpringTransactionAnnotationParser实现了isCandidateClass方法，<strong>它又调用了AnnotationUtils的isCandidateClass判断目标类是否是Transactional注解的候选类，AnnotationUtils中isCandidateClass的具体判断逻辑如下：</strong></p>
<ul>
<li><p>如果注解类路径以java.开头，返回true，这里Transactional注解不是java.开头，它是Spring的注解类，所以这个条件不会成立</p>
</li>
<li><p>如果目标类的类路径以java.开头，或者是Ordered类型，isCandidateClass返回false，说明目标类不是某个注解的候选类</p>
</li>
<li><p>除去以上两种情况之外，isCandidateClass都返回true</p>
<p><strong>总结： 如果目标类的类路径不以java.开头（也就是说它不是java的相关类），也不是Ordered类型，说明目标类是Transactional注解的候选类。</strong></p>
</li>
</ul>
</li>
<li><p>SpringTransactionAnnotationParser实现了parseTransactionAnnotation方法，里面包含对事物属性的解析。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTransactionAnnotationParser</span> <span class="keyword">implements</span> <span class="title">TransactionAnnotationParser</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCandidateClass</span><span class="params">(Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否是Transactional注解的候选类</span></span><br><span class="line">        <span class="keyword">return</span> AnnotationUtils.isCandidateClass(targetClass, Transactional.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析注解属性</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line">        AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(</span><br><span class="line">                element, Transactional.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析注解属性</span></span><br><span class="line">            <span class="keyword">return</span> parseTransactionAnnotation(attributes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析事务注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(Transactional ann)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseTransactionAnnotation(AnnotationUtils.getAnnotationAttributes(ann, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析事务注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">        RuleBasedTransactionAttribute rbta = <span class="keyword">new</span> RuleBasedTransactionAttribute();</span><br><span class="line">        <span class="comment">// 事务的传播行为</span></span><br><span class="line">        Propagation propagation = attributes.getEnum(<span class="string">"propagation"</span>);</span><br><span class="line">        rbta.setPropagationBehavior(propagation.value());</span><br><span class="line">        Isolation isolation = attributes.getEnum(<span class="string">"isolation"</span>);</span><br><span class="line">        rbta.setIsolationLevel(isolation.value());</span><br><span class="line">        rbta.setTimeout(attributes.getNumber(<span class="string">"timeout"</span>).intValue());</span><br><span class="line">        rbta.setReadOnly(attributes.getBoolean(<span class="string">"readOnly"</span>));</span><br><span class="line">        rbta.setQualifier(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;RollbackRuleAttribute&gt; rollbackRules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">"rollbackFor"</span>)) &#123;</span><br><span class="line">            rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">"rollbackForClassName"</span>)) &#123;</span><br><span class="line">            rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">"noRollbackFor"</span>)) &#123;</span><br><span class="line">            rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">"noRollbackForClassName"</span>)) &#123;</span><br><span class="line">            rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</span><br><span class="line">        &#125;</span><br><span class="line">        rbta.setRollbackRules(rollbackRules);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rbta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnnotationUtils</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查目标类clazz是否是注解的候选类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCandidateClass</span><span class="params">(Class&lt;?&gt; clazz, Collection&lt;Class&lt;? extends Annotation&gt;&gt; annotationTypes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; annotationType : annotationTypes) &#123;</span><br><span class="line">            <span class="comment">// 传入目标类和注解，SpringTransactionAnnotationParser传入的注解是Transactional</span></span><br><span class="line">            <span class="keyword">if</span> (isCandidateClass(clazz, annotationType)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查目标类clazz是否是注解的候选类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCandidateClass</span><span class="params">(Class&lt;?&gt; clazz, Class&lt;? extends Annotation&gt; annotationType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入目标类和注解类路径</span></span><br><span class="line">        <span class="keyword">return</span> isCandidateClass(clazz, annotationType.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查目标类clazz是否是注解的候选类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCandidateClass</span><span class="params">(Class&lt;?&gt; clazz, String annotationName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注解类路径是否是java.开头</span></span><br><span class="line">        <span class="keyword">if</span> (annotationName.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用AnnotationsScanner的hasPlainJavaAnnotationsOnly方法判断</span></span><br><span class="line">        <span class="comment">// hasPlainJavaAnnotationsOnly方法的判断逻辑是：如果目标类的类路径以java.开头或者是Ordered类会返回true</span></span><br><span class="line">        <span class="comment">// 所以如果目标类的类路径以java.开头或者是Ordered类，isCandidateClass会返回false，说明目标类不是注解的候选类</span></span><br><span class="line">        <span class="keyword">if</span> (AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果注解类路径不是java.开头，并且目标类的类路径不以java.开头，也不是Ordered类型，返回true，说明目标类是某个注解的候选类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnnotationsScanner</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationsScanner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPlainJavaAnnotationsOnly</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果目标类的类路径以java.开头或者是Ordered类</span></span><br><span class="line">        <span class="keyword">return</span> (type.getName().startsWith(<span class="string">"java."</span>) || type == Ordered.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="条件二：检查方法是否匹配事务切点"><a href="#条件二：检查方法是否匹配事务切点" class="headerlink" title="条件二：检查方法是否匹配事务切点"></a>条件二：检查方法是否匹配事务切点</h4><h5 id="AbstractFallbackTransactionAttributeSource"><a href="#AbstractFallbackTransactionAttributeSource" class="headerlink" title="AbstractFallbackTransactionAttributeSource"></a>AbstractFallbackTransactionAttributeSource</h5><p>如果从TransactionAttributeSource获取到的事务属性不为空将会满足切点的匹配条件，获取事务属性的方法实现在AbstractFallbackTransactionAttributeSource类中：</p>
<ol>
<li>如果当前方法是Object中的方法，返回空</li>
<li>根据当前的方法和类的信息构建缓存key，从缓存中获取<ul>
<li>如果获取不为空，判断是否为空的事务属性NULL_TRANSACTION_ATTRIBUTE，如果是则返回null，否则返回从缓存中获取到的事务属性</li>
<li>如果获取为空，调用解析事务属性的方法进行解析，然后放入缓存中并返回</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFallbackTransactionAttributeSource</span> <span class="keyword">implements</span> <span class="title">TransactionAttributeSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空的TransactionAttribute</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TransactionAttribute NULL_TRANSACTION_ATTRIBUTE = <span class="keyword">new</span> DefaultTransactionAttribute() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, TransactionAttribute&gt; attributeCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取事务属性</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前方法所在的类是Object</span></span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建cacheKey</span></span><br><span class="line">        Object cacheKey = getCacheKey(method, targetClass);</span><br><span class="line">        <span class="comment">// 首先根据cacheKey从缓存中获取</span></span><br><span class="line">        TransactionAttribute cached = <span class="keyword">this</span>.attributeCache.get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否为空的TRANSACTION_ATTRIBUTE</span></span><br><span class="line">            <span class="keyword">if</span> (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</span><br><span class="line">                <span class="comment">// 返回空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 返回事务属性TransactionAttribute</span></span><br><span class="line">                <span class="keyword">return</span> cached;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解析TransactionAttribute</span></span><br><span class="line">            TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);</span><br><span class="line">            <span class="comment">// 如果为空，也加入缓存，但是value是NULL_TRANSACTION_ATTRIBUTE</span></span><br><span class="line">            <span class="keyword">if</span> (txAttr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);</span><br><span class="line">                <span class="comment">// 如果是DefaultTransactionAttribute类型的</span></span><br><span class="line">                <span class="keyword">if</span> (txAttr <span class="keyword">instanceof</span> DefaultTransactionAttribute) &#123;</span><br><span class="line">                    ((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(<span class="string">"Adding transactional method '"</span> + methodIdentification + <span class="string">"' with attribute: "</span> + txAttr);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 加入缓存</span></span><br><span class="line">                <span class="keyword">this</span>.attributeCache.put(cacheKey, txAttr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> txAttr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取缓存KEY</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getCacheKey</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodClassKey(method, targetClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析TransactionAttribute</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断方法是否是public的</span></span><br><span class="line">        <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取目标方法</span></span><br><span class="line">        Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在方法上查找事务属性的设置，findTransactionAttribute方法在AnnotationTransactionAttributeSource中实现</span></span><br><span class="line">        TransactionAttribute txAttr = findTransactionAttribute方法(specificMethod);</span><br><span class="line">        <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> txAttr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在目标类上面查找事务属性的设置</span></span><br><span class="line">        txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> txAttr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line">            <span class="comment">// 使用方法上配置的事务属性</span></span><br><span class="line">            txAttr = findTransactionAttribute(method);</span><br><span class="line">            <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> txAttr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用类上面配置的事务属性</span></span><br><span class="line">            txAttr = findTransactionAttribute(method.getDeclaringClass());</span><br><span class="line">            <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">                <span class="keyword">return</span> txAttr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>事务是基于AOP实现的，事务的Advisor是BeanFactoryTransactionAttributeSourceAdvisor，Advisor判断方法是否匹配时，是通过Pointcut的matches方法判断的，事务的Pointcut是TransactionAttributeSourcePointcut，里面实现了方法是否与事务切点匹配的判断：</strong></p>
<ol>
<li><p>对类的匹配是通过判断目标类是否是Transactional注解的候选类实现的，我们创建的类一般不会以java.开头，所以说可以与Transactional注解匹配成功。</p>
</li>
<li><p>对方法的匹配是通过解析方法上面配置的事务属性判断的，如果解析到了事务属性，则满足匹配条件。</p>
</li>
</ol>
<h3 id="TransactionInterceptor"><a href="#TransactionInterceptor" class="headerlink" title="TransactionInterceptor"></a>TransactionInterceptor</h3><p>TransactionInterceptor是事务Advisor的Advice，执行目标方法时，方法会被拦截，进入到TransactionInterceptor中，在TransactionInterceptor的invoke方法中实际是调用invokeWithinTransaction执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionInterceptor</span> <span class="keyword">extends</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过事务执行目标方法，实现在TransactionAspectSupport方法中</span></span><br><span class="line">        <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TransactionAspectSupport</strong></p>
<p>TransactionAspectSupport中实现了invokeWithinTransaction方法：</p>
<ol>
<li>获取事务属性TransactionAttribute和TransactionManager事务管理器</li>
<li>对响应式事务、声明式事务和编程式事务分别进行判断，以声明式事务为例步骤如下：<ul>
<li>创建事务</li>
<li>执行方法</li>
<li>捕捉异常，如果抛出异常进行回滚</li>
<li>清除事务信息</li>
<li>提交事务</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取TransactionAttributeSource</span></span><br><span class="line">        TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">        <span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 获取事务管理器TransactionManager</span></span><br><span class="line">        <span class="keyword">final</span> TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">        <span class="comment">// 响应式事务处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reactiveAdapterRegistry != <span class="keyword">null</span> &amp;&amp; tm <span class="keyword">instanceof</span> ReactiveTransactionManager) &#123;</span><br><span class="line">            ReactiveTransactionSupport txSupport = <span class="keyword">this</span>.transactionSupportCache.computeIfAbsent(method, key -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (KotlinDetector.isKotlinType(method.getDeclaringClass()) &amp;&amp; KotlinDelegate.isSuspend(method)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TransactionUsageException(</span><br><span class="line">                            <span class="string">"Unsupported annotated transaction on suspending function detected: "</span> + method +</span><br><span class="line">                                    <span class="string">". Use TransactionalOperator.transactional extensions instead."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ReactiveAdapter adapter = <span class="keyword">this</span>.reactiveAdapterRegistry.getAdapter(method.getReturnType());</span><br><span class="line">                <span class="keyword">if</span> (adapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot apply reactive transaction to non-reactive return type: "</span> +</span><br><span class="line">                            method.getReturnType());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReactiveTransactionSupport(adapter);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> txSupport.invokeWithinTransaction(</span><br><span class="line">                    method, targetClass, invocation, txAttr, (ReactiveTransactionManager) tm);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line">        <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line">        <span class="comment">// 声明式事务的处理</span></span><br><span class="line">        <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">            <span class="comment">// 创建事务</span></span><br><span class="line">            TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">            Object retVal;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">                <span class="comment">// 这是一个环绕通知，将会在拦截链中执行下一个拦截</span></span><br><span class="line">                retVal = invocation.proceedWithInvocation();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 捕捉异常，进行回滚</span></span><br><span class="line">                completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 清除事务</span></span><br><span class="line">                cleanupTransactionInfo(txInfo);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">                <span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">                TransactionStatus status = txInfo.getTransactionStatus();</span><br><span class="line">                <span class="keyword">if</span> (status != <span class="keyword">null</span> &amp;&amp; txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">            commitTransactionAfterReturning(txInfo);</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 编程式事务的处理</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ThrowableHolder throwableHolder = <span class="keyword">new</span> ThrowableHolder();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object result = ((CallbackPreferringPlatformTransactionManager) ptm).execute(txAttr, status -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 获取事务信息</span></span><br><span class="line">                    TransactionInfo txInfo = prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 执行方法</span></span><br><span class="line">                        Object retVal = invocation.proceedWithInvocation();</span><br><span class="line">                        <span class="keyword">if</span> (vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">                            <span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">                            retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> retVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line">                            <span class="comment">// A RuntimeException: will lead to a rollback.</span></span><br><span class="line">                            <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> ThrowableHolderException(ex);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// A normal return value: will lead to a commit.</span></span><br><span class="line">                            throwableHolder.throwable = ex;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 清除事务信息</span></span><br><span class="line">                        cleanupTransactionInfo(txInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check result state: It might indicate a Throwable to rethrow.</span></span><br><span class="line">                <span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> throwableHolder.throwable;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ThrowableHolderException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Application exception overridden by commit exception"</span>, throwableHolder.throwable);</span><br><span class="line">                    ex2.initApplicationException(throwableHolder.throwable);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Application exception overridden by commit exception"</span>, throwableHolder.throwable);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p><img src="/images/事务原理一总结.png" alt=""></p>
<p><strong>参考</strong></p>
<p><a href="https://blog.csdn.net/qq_36882793/article/details/106440723" target="_blank" rel="noopener">【猫吻鱼】Spring源码分析：全集整理</a></p>
<p><strong>Spring版本：5.2.5.RELEASE</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/07/【JAVA】IO访问方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/07/【JAVA】IO访问方式/" itemprop="url">【JAVA】IO访问方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-07T21:00:00+08:00">
                2021-11-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>物理内存</strong></p>
<p>计算机物理内存条的容量，比如我们买电脑会关注内存大小有多少G，这个容量就是计算机的物理内存。</p>
<p><strong>虚拟内存</strong></p>
<p>操作系统为每个进程分配了独立的虚拟地址空间，也就是虚拟内存，虚拟地址空间又分为用户空间和内核空间，操作系统的位数不同，虚拟地址空间的大小也不同，32位操作系统虚拟地址内核空间为1G，用户空间大小为3G，64位操作系统用户空间和内核空间大小各为128T：<br><img src="/images/虚拟地址.jpg" alt=""></p>
<p>既然每个进程都拥有一块独立的虚拟地址空间，那么所有进程的虚拟地址空间大小加起来必定大于物理内存的大小，所以虚拟地址空间只是一个虚拟的概念，只有需要分配内存的时候才会为虚拟内存分配物理内存，并通过内存映射来管理虚拟地址和物理内存地址之间的映射关系。</p>
<p><strong>用户空间 / 内核空间</strong></p>
<p><strong>用户空间：</strong>是运行用户程序代码的地方，为了保证系统内核的安全，它不能直接访问内存等硬件设备，必须通过系统调用进入到内核空间来访问那些受限的资源。</p>
<p><strong>内核空间：</strong>是运行内核代码的地方，可以执行任意的指令访问系统资源，既可以访问内核空间也可以访问用户空间。</p>
<p><strong>用户态：</strong>进程运行在用户空间时处于用户态。</p>
<p><strong>内核态：</strong>程运行在内核空间时处于内核态。</p>
<h3 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h3><p>比如我们启动了一个java程序，此时运行在用户空间（用户态），接着准备做一个读取磁盘文件的操作，由于用户空间是无法直接从磁盘读取文件的，所以需要调用内核提供的接口来完成文件的读取，调用内核的接口的过程中由用户空间进入到了内核空间（内核态），通过DMA从磁盘读取文件到内核的缓冲区，之后再将数据从内核的缓冲区拷贝到用户空间完成文件的读取操作。</p>
<p><img src="/images/文件io.jpg" alt=""></p>
<ol>
<li>应用程序发起系统调用</li>
<li>从用户空间切换到内核空间，内核通过DMA从磁盘拷贝数据到内核缓冲区</li>
<li>将内核缓冲区的数据拷贝到用户空间的缓冲区</li>
</ol>
<p><strong>可以发现，整个读取过程发生了两次数据拷贝，一次是DMA将磁盘上的文件数据拷贝到内核缓冲区，一次是将内核缓冲区的数据拷贝到用户缓冲区。</strong>写操作与读取操作类似，只不过是将用户缓冲区的数据拷贝到内核缓冲区，再将内核缓冲区的数据拷贝到文件。</p>
<h3 id="网络I-O"><a href="#网络I-O" class="headerlink" title="网络I/O"></a>网络I/O</h3><p>网络I/O与文件I/O的底层原理一致，只不过文件I/O是从磁盘读取文件，网络I/O是从网卡中读取数据，客户端与服务端建立连接，当有数据到达时，从网卡中读取数据到内核缓冲区，再将内核缓冲区的数据复制到用户空间的缓冲区。</p>
<p><img src="/images/网络io.jpg" alt=""></p>
<h3 id="缓存I-O"><a href="#缓存I-O" class="headerlink" title="缓存I/O"></a>缓存I/O</h3><p>也称标准I/O，上面提到的文件I/O和网络I/O读取数据的方式都是使用的缓存I/O，需要将数据先拷贝到内核缓冲区，再将内核缓冲区的数据拷贝到用户缓冲区，数据经过两次拷贝，内核缓冲区和用户缓冲区分别指向不同的物理内存，其中内核缓存区是在Page Cache层：</p>
<p><img src="/images/缓存io.jpg" alt=""></p>
<p>标准I/O读取文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/Users/sml/test.txt"</span>);</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> FileInputStream(file))&#123;</span><br><span class="line">            <span class="comment">// 建立用户空间缓冲区</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么需要缓存IO？</strong></p>
<p>因为磁盘I/O是比较耗时的操作，如果每次都从磁盘上读取文件，性能将会大大下降，为了提升读取性能，增加了一层Page Cache，用于缓存读取的文件数据，Page Cache占用的是内存，从内存读取的速度远远大于从磁盘读取，内核缓冲区就是在Page Cache中开辟的一块内存，用户空间进行系统调用读取文件内容时，首先会判断Page Cache中是否缓存了文件的内容，如果缓存了直接读取即可，否则再从磁盘读取，所以缓存I/O可以减少磁盘I/O的次数提升性能。</p>
<p>文件的写操作同样如此，进行写操作时，将数据先写到Page Cache的缓冲区中，后续由操作系统将数据刷回到磁盘中。</p>
<p><strong>缓存I/O的优缺点</strong></p>
<p>优点：减少磁盘I/O次数，提升读写性能。</p>
<p>缺点：数据需要在内核空间和用户空间来回拷贝。</p>
<h3 id="直接I-O"><a href="#直接I-O" class="headerlink" title="直接I/O"></a>直接I/O</h3><p>缓存I/O经过了Page Cache，读取过程中需要将数据从Page Cache的缓冲区中拷贝到用户空间的缓存区，那么有没有一种方式可以省去这个拷贝的过程？</p>
<p>答案是有的，那就是直接I/O，应用程序直接访问磁盘数据，绕过了Page Cache，省去了从内核缓冲区拷贝到用户缓冲区的过程。</p>
<p><img src="/images/直接io.jpg" alt=""></p>
<p>目前JAVA并没有原生的直接/O操作方式，不过公众号博主<strong>Kirito</strong>提供了在JAVA中进行直接I/O操作的方法，具体参见【Kirito的技术分享】<a href="https://mp.weixin.qq.com/s/KtJUOTz4Pwyeo5hfRoumdg" target="_blank" rel="noopener">Java 文件 IO 操作之 DirectIO</a>。</p>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>内存映射就是将虚拟空间地址映射到物理空间地址，每个进程维护了一张页表，记录虚拟地址和物理地址之间的映射关系，当进程访问的虚拟地址在页表中无法查到映射关系时，系统产生缺页异常，进入内核空间为虚拟地址分配物理内存，并更新页表，记录映射关系。</p>
<p><strong>文件映射</strong></p>
<p>内存映射除了映射虚拟空间地址和物理空间地址，还包括将磁盘的文件内容映射到虚拟地址空间，称为文件映射，此时可以通过访问内存来访问文件里面的数据 。</p>
<p>mmap系统调用可以将文件映射到虚拟内存空间。文件映射的流程如下：</p>
<ol>
<li>进行mmap系统调用，将文件和虚拟地址空间建立映射，注意此时还没有分配物理内存空间，只是在逻辑上建立了虚拟地址和文件之间的映射关系，物理内存只有真正使用的时候才会分配。</li>
<li>应用程序访问用户空间虚拟内存中的某个地址，发现无法在页表中查到数据，产生缺页异常，此时进入内核空间</li>
<li><strong>因为不能直接使用物理地址，所以需要使用内核的虚拟地址临时建立与物理内存的映射关系，将文件内容读取到物理内存中，待数据读取完毕之后取消临时映射即可。</strong></li>
<li>缺页异常处理完毕，物理内存中已经加载了文件的数据，此时用户空间就可以通过虚拟地址直接访问物理内存中映射的文件数据。</li>
</ol>
<p><img src="/images/文件映射.jpg" alt=""></p>
<p><strong>从文件映射的流程中可以看出它与缓存I/O相比，少了从内核缓冲区将数据拷贝到用户缓冲区的步骤，减少了一次拷贝。</strong></p>
<p>Java NIO中提供了<strong>MappedByteBuffer</strong>来处理文件映射，下面是一个读取文件的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> (RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"/Users/sml/test.txt"</span>), <span class="string">"r"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 获取FileChannel</span></span><br><span class="line">            FileChannel fileChannel = file.getChannel();</span><br><span class="line">            <span class="keyword">long</span> size = fileChannel.size();</span><br><span class="line">            <span class="comment">// 调用map方法进行文件映射，返回MappedByteBuffer</span></span><br><span class="line">            MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, size);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)size];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">// 读取数据</span></span><br><span class="line">                bytes[i] = mappedByteBuffer.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>首先看一下使用传统缓存I/O从磁盘文件读取数据并发送到网络上的过程：</p>
<p><img src="/images/传统拷贝.jpg" alt=""></p>
<ol>
<li><p>用户发起系统调用，DMA从磁盘上读取数据到内核缓冲区</p>
</li>
<li><p>CPU将内核缓冲区的数据拷贝到用户缓冲区</p>
</li>
<li>CPU将用户缓冲区的数据拷贝到socket缓冲区</li>
<li>DMA将socket缓冲区的数据拷贝到网卡</li>
</ol>
<p>使用缓存I/O数据经过了四次拷贝，需要多次在内核空间和用户空间来回切换，影响系统性能。从数据拷贝的过程可以看到有些步骤其实是多余的，比如第二步，如果可以直接将内核缓存区的数据拷贝到socket缓冲区，或者直接将内核缓冲区的数据拷贝到网卡，岂不是减少了数据拷贝的次数？零拷贝就是这样一种致力于减少数据拷贝的技术。</p>
<p>Linux中的sendfile()函数可以实现将数据从一个文件描述符传输到另外一个文件描述符。Java NIO中的FileChannel也可以实现将数据从FileChannel直接传输到另一个Channel。</p>
<p><strong>FileChannel</strong></p>
<p>Java NIO中的FileChannel的transferTo方法将数据从FileChannel传输到另一个Channel：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"/Users/shanmenglu/test.txt"</span>), <span class="string">"r"</span>);</span><br><span class="line"><span class="comment">// 获取FileChannel</span></span><br><span class="line">FileChannel fileChannel = file.getChannel();</span><br><span class="line"><span class="keyword">long</span> size = fileChannel.size();</span><br><span class="line">SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">fileChannel.transferTo(<span class="number">0</span>,size,socketChannel);</span><br></pre></td></tr></table></figure>
<p>使用FileChanel后的数据拷贝：</p>
<p><img src="/images/filechannel.jpg" alt=""></p>
<p>Linux2.4版本之后通过对Socket Buffer添加一些Descriptor信息可以进一步减少数据的拷贝：</p>
<p><img src="/images/零拷贝.jpg" alt=""></p>
<p><strong>可以看到零拷贝并不是指的数据一次拷贝都没有发生，而是指没有通过CPU进行数据拷贝。</strong>Java中的堆外内存DirectByteBuffer和上面提到的mmap内存映射也是零拷贝中的一种，Netty中也提供了零拷贝相关的技术。</p>
<p><strong>堆外内存</strong></p>
<p>传统的缓存I/O，内核缓冲区和用户缓冲区分别占用不同的物理内存，其中用户缓冲区占用的是JVM堆内的内存：</p>
<p><img src="/images/缓存io内存占用.jpg" alt=""></p>
<p><strong>DirectByteBuffer</strong></p>
<p>Java NIO中提供了DirectByteBuffer，可以使用堆外内存，通过ByteBuffer的allocateDirect方法可以分配堆外内存，并返回内存的地址，之后就可以直接操作这块内存，不用将数据在内核缓冲区与用户缓冲区之间拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/堆外内存.jpg" alt=""></p>
<p><strong>堆外内存和直接I/O的区别</strong></p>
<p>直接I/O偏重的是绕过操作系统的Page Cache层，堆外内存偏重的是使用的JVM内存之外的内存，他们的侧重点不同，不过都可以减少数据的拷贝。</p>
<p>关于堆外内存是否在Page Cache中，这个待研究。</p>
<p><strong>参考</strong></p>
<p><a href="https://time.geekbang.org/column/intro/100020901?tab=catalog" target="_blank" rel="noopener">【极客时间-倪朋飞】Linux性能优化实战</a></p>
<p><a href="https://time.geekbang.org/column/intro/100024701?tab=catalog" target="_blank" rel="noopener">【极客时间-刘超】趣谈Linux操作系统</a></p>
<p><a href="https://edu.lagou.com/" target="_blank" rel="noopener">【拉勾教育-若地】Netty 核心原理剖析与 RPC 实践</a></p>
<p><a href="https://mp.weixin.qq.com/s/101wu0rg4mZWCxD9EuUYeA" target="_blank" rel="noopener">【 Kirito的技术分享】文件IO操作的最佳实践</a></p>
<p><a href="https://blog.csdn.net/zhangcongyi420/article/details/103099441" target="_blank" rel="noopener">【小码农叔叔】java使用nio读写文件</a></p>
<p><a href="https://www.jianshu.com/p/f90866dcbffc" target="_blank" rel="noopener">【占小狼】深入浅出MappedByteBuffer</a></p>
<p><a href="https://juejin.cn/post/6844903949359644680#heading-8" target="_blank" rel="noopener">【零壹技术栈】深入剖析Linux IO原理和几种零拷贝机制的实现</a></p>
<p><a href="https://www.jianshu.com/p/007052ee3773" target="_blank" rel="noopener">【tomas家的小拨浪鼓】堆外内存 之 DirectByteBuffer 详解</a></p>
<p><a href="https://www.cnblogs.com/sunsky303/p/8962628.html" target="_blank" rel="noopener">网络IO和磁盘IO详解</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/20/【Redis】quicklist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SHAN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/20/【Redis】quicklist/" itemprop="url">【Redis】quicklist</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-09-20T17:00:00+08:00">
                2021-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis-List"><a href="#Redis-List" class="headerlink" title="Redis List"></a>Redis List</h2><p>在Redis3.2版之前，Redis使用压缩列表和双向链表作为List的底层实现。当元素个数比较少并且元素长度比较小时，Redis使用压缩列表实现，否则Redis使用双向链表实现。</p>
<p><strong>ziplist存在问题</strong></p>
<ol>
<li><p>不能保存过多的元素，否则查找复杂度高，性能降低。</p>
</li>
<li><p>由于每个节点保存了前一个节点的长度，不同长度使用的字节数不一样，所以在更新节点的时候有可能引起长度的变化导致连锁更新问题。</p>
</li>
</ol>
<p>为了解决上面两个问题，在Redis3.2版之后，引入了quicklist。</p>
<h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><p>quicklist可以理解为是ziplist和链表的结合体，一个quicklist是一个双向链表，链表中的每一个节点是一个ziplist。</p>
<p><img src="/images/quicklist.jpg" alt=""></p>
<h4 id="quicklist结构定义"><a href="#quicklist结构定义" class="headerlink" title="quicklist结构定义"></a>quicklist结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头指针</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* 列表中的元素总个数，也就是所有ziplist中包含的元素数量之和 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* 链表中节点的个数 */</span></span><br><span class="line">    <span class="keyword">int</span> fill : QL_FILL_BITS;              <span class="comment">/* 表示ziplist的大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : QL_COMP_BITS; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bookmark_count: QL_BM_BITS;</span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>head：指向头结点的指针</p>
</li>
<li><p>tail：指向尾节点的指针</p>
</li>
<li><p>count：列表中的元素总个数，等于所有节点的ziplist中包含的元素数量之和</p>
</li>
<li><p>len：quicklist中quicklistNode节点的个数</p>
</li>
<li><p>fill：用来限制quicklistNode中ziplist的大小，为正数时代表ziplist中最多能包含的元素个数，为负数时有以下几种情况：</p>
<p>| 数值 | 含义                            |<br>| —- | ——————————- |<br>| -1   | 表示ziplist的字节数不能超过4KB  |<br>| -2   | 表示ziplist的字节数不能超过8KB  |<br>| -3   | 表示ziplist的字节数不能超过16KB |<br>| -4   | 表示ziplist的字节数不能超过32KB |<br>| -5   | 表示ziplist的字节数不能超过64KB |</p>
</li>
</ul>
<p>​除此之外，也可以通过<strong>list-max-ziplist-size</strong>参数配置最大的字节数。</p>
<h4 id="quicklistNode结构定义"><a href="#quicklistNode结构定义" class="headerlink" title="quicklistNode结构定义"></a>quicklistNode结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 指向ziplist压缩列表的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist压缩列表的字节数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* ziplist压缩列表的元素个数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* 编码格式：RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* 是否被压缩 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* 是否可以被压缩 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* 预留bit位*/</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>
<p><img src="/images/quicklist1.jpg" alt=""></p>
<h4 id="quicklist创建"><a href="#quicklist创建" class="headerlink" title="quicklist创建"></a>quicklist创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">quicklist *<span class="title">quicklistCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> *<span class="title">quicklist</span>;</span></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    quicklist = zmalloc(<span class="keyword">sizeof</span>(*quicklist));</span><br><span class="line">    <span class="comment">// 初始化头尾节点</span></span><br><span class="line">    quicklist-&gt;head = quicklist-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    quicklist-&gt;len = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;count = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;compress = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认为-2，表示ziplist的字节数最大不能超过8KB</span></span><br><span class="line">    quicklist-&gt;fill = <span class="number">-2</span>;</span><br><span class="line">    quicklist-&gt;bookmark_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> quicklist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>添加元素的时候可以在链表的头部或者尾部进行添加，以头部添加为例：</p>
<ol>
<li>首先调用_quicklistNodeAllowInsert方法判断是否允许添加元素到ziplist，如果允许，调用ziplistPush方法进行添加</li>
<li>如果_quicklistNodeAllowInsert不允许添加元素，则需要新创建一个quicklistNode，然后将元素添加到新创建的quicklistNode的压缩列表中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从头部添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="comment">// 判断是否允许添加</span></span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        <span class="comment">// 将元素添加到ziplit</span></span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新创建quicklistNode节点</span></span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新数量</span></span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>_quicklistNodeAllowInsert</strong></p>
<p><strong>_quicklistNodeAllowInsert</strong>方法用于判断是否允许在某个quicklistNode指向的压缩列表中添加元素。</p>
<p>在quicklist的结构体定义中，fill指定了ziplist中能包含的最大元素个数或者ziplist最大的字节数，_quicklistNodeAllowInsert方法就是判断ziplist中的元素个数或者ziplist的字节数是否超过了限制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node：当前的quicklistNode节点</span></span><br><span class="line"><span class="comment">// fill：ziplist中能包含的最大元素个数或者ziplist最大的字节数</span></span><br><span class="line"><span class="comment">// sz：要添加元素的大小</span></span><br><span class="line">REDIS_STATIC <span class="keyword">int</span> _quicklistNodeAllowInsert(<span class="keyword">const</span> quicklistNode *node,</span><br><span class="line">                                           <span class="keyword">const</span> <span class="keyword">int</span> fill, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!node))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ziplist_overhead;</span><br><span class="line">    <span class="comment">/* 判断要添加元素的大小是否小于254 */</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">254</span>)</span><br><span class="line">        ziplist_overhead = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断要添加元素的大小是否小于64 */</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">64</span>)</span><br><span class="line">        ziplist_overhead += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (likely(sz &lt; <span class="number">16384</span>))</span><br><span class="line">        ziplist_overhead += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算添加元素后的当前的quicklistNode的大小 + 新加入元素的大小 + 插入元素后ziplit的prevlen占用大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> new_sz = node-&gt;sz + sz + ziplist_overhead;</span><br><span class="line">    <span class="comment">// 判断添加元素后的ziplist的字节数是否超过了fill中设置的大小</span></span><br><span class="line">    <span class="keyword">if</span> (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sizeMeetsSafetyLimit(new_sz))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)node-&gt;count &lt; fill) <span class="comment">// 判断ziplist的元素个数是否超过了fill设置的大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ol>
<li><p>在Redis3.2版之前，Redis使用压缩列表和双向链表作为List的底层实现。当元素个数比较少并且元素长度比较小时，Redis使用压缩列表实现，否则Redis使用双向链表实现。</p>
</li>
<li><p>为了解决压缩列表在节点多的时候查找效率低的问题以及连锁更新问题，在Redis3.2版之后引入了quicklist，quicklist是一个双向链表，链表中的每一个节点是一个ziplist。</p>
</li>
<li><p>quicklist中限定了ziplist的大小，如果超过了限制的大小，新加入元素的时候会生成一个新的quicklistNode节点。</p>
</li>
<li><p>quicklist通过限定ziplist的大小来保证一个ziplist中的元素个数不会太多，如果需要连锁更新，也只在某个quicklistNode节点指向的ziplist中更新，不会引发整个链表的更新，以此来解决压缩列表存在的问题。</p>
</li>
</ol>
<p><strong>参考</strong></p>
<p>陈雷《Redis5设计与源码分析》</p>
<p><a href="https://time.geekbang.org/column/intro/430" target="_blank" rel="noopener">极客时间  -  Redis源码剖析与实战(蒋德钧)</a></p>
<p><strong>Redis版本：redis-6.2.5</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">shan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shan</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
